/*! For license information please see 150.0fc31f1e.iframe.bundle.js.LICENSE.txt */
(self.webpackChunkfe_nextjs_sem = self.webpackChunkfe_nextjs_sem || []).push([
  [150],
  {
    './node_modules/@swc/helpers/lib/_async_to_generator.js': (
      __unused_webpack_module,
      exports
    ) => {
      'use strict';
      function asyncGeneratorStep(
        gen,
        resolve,
        reject,
        _next,
        _throw,
        key,
        arg
      ) {
        try {
          var info = gen[key](arg),
            value = info.value;
        } catch (error) {
          return void reject(error);
        }
        info.done ? resolve(value) : Promise.resolve(value).then(_next, _throw);
      }
      function _asyncToGenerator(fn) {
        return function () {
          var self = this,
            args = arguments;
          return new Promise(function (resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
              asyncGeneratorStep(
                gen,
                resolve,
                reject,
                _next,
                _throw,
                'next',
                value
              );
            }
            function _throw(err) {
              asyncGeneratorStep(
                gen,
                resolve,
                reject,
                _next,
                _throw,
                'throw',
                err
              );
            }
            _next(void 0);
          });
        };
      }
      Object.defineProperty(exports, 'Z', {
        enumerable: !0,
        get: function () {
          return _asyncToGenerator;
        },
      });
    },
    './node_modules/chart.js/dist/chart.js': (
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) => {
      'use strict';
      function round(v) {
        return (v + 0.5) | 0;
      }
      __webpack_require__.d(__webpack_exports__, {
        uw: () => CategoryScale,
        kL: () => Chart,
        De: () => plugin_legend,
        ST: () => LineController,
        jn: () => LineElement,
        f$: () => LinearScale,
        od: () => PointElement,
        FB: () => TimeScale,
        u: () => plugin_tooltip,
        IQ: () => adapters,
      });
      const lim = (v, l, h) => Math.max(Math.min(v, h), l);
      function p2b(v) {
        return lim(round(2.55 * v), 0, 255);
      }
      function n2b(v) {
        return lim(round(255 * v), 0, 255);
      }
      function b2n(v) {
        return lim(round(v / 2.55) / 100, 0, 1);
      }
      function n2p(v) {
        return lim(round(100 * v), 0, 100);
      }
      const map$1 = {
          0: 0,
          1: 1,
          2: 2,
          3: 3,
          4: 4,
          5: 5,
          6: 6,
          7: 7,
          8: 8,
          9: 9,
          A: 10,
          B: 11,
          C: 12,
          D: 13,
          E: 14,
          F: 15,
          a: 10,
          b: 11,
          c: 12,
          d: 13,
          e: 14,
          f: 15,
        },
        hex = [...'0123456789ABCDEF'],
        h1 = (b) => hex[15 & b],
        h2 = (b) => hex[(240 & b) >> 4] + hex[15 & b],
        eq = (b) => (240 & b) >> 4 == (15 & b),
        isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
      const alpha = (a, f) => (a < 255 ? f(a) : '');
      const HUE_RE =
        /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
      function hsl2rgbn(h, s, l) {
        const a = s * Math.min(l, 1 - l),
          f = (n, k = (n + h / 30) % 12) =>
            l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        return [f(0), f(8), f(4)];
      }
      function hsv2rgbn(h, s, v) {
        const f = (n, k = (n + h / 60) % 6) =>
          v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
        return [f(5), f(3), f(1)];
      }
      function hwb2rgbn(h, w, b) {
        const rgb = hsl2rgbn(h, 1, 0.5);
        let i;
        for (
          w + b > 1 && ((i = 1 / (w + b)), (w *= i), (b *= i)), i = 0;
          i < 3;
          i++
        )
          (rgb[i] *= 1 - w - b), (rgb[i] += w);
        return rgb;
      }
      function rgb2hsl(v) {
        const r = v.r / 255,
          g = v.g / 255,
          b = v.b / 255,
          max = Math.max(r, g, b),
          min = Math.min(r, g, b),
          l = (max + min) / 2;
        let h, s, d;
        return (
          max !== min &&
            ((d = max - min),
            (s = l > 0.5 ? d / (2 - max - min) : d / (max + min)),
            (h = (function hueValue(r, g, b, d, max) {
              return r === max
                ? (g - b) / d + (g < b ? 6 : 0)
                : g === max
                ? (b - r) / d + 2
                : (r - g) / d + 4;
            })(r, g, b, d, max)),
            (h = 60 * h + 0.5)),
          [0 | h, s || 0, l]
        );
      }
      function calln(f, a, b, c) {
        return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
      }
      function hsl2rgb(h, s, l) {
        return calln(hsl2rgbn, h, s, l);
      }
      function hue(h) {
        return ((h % 360) + 360) % 360;
      }
      function hueParse(str) {
        const m = HUE_RE.exec(str);
        let v,
          a = 255;
        if (!m) return;
        m[5] !== v && (a = m[6] ? p2b(+m[5]) : n2b(+m[5]));
        const h = hue(+m[2]),
          p1 = +m[3] / 100,
          p2 = +m[4] / 100;
        return (
          (v =
            'hwb' === m[1]
              ? (function hwb2rgb(h, w, b) {
                  return calln(hwb2rgbn, h, w, b);
                })(h, p1, p2)
              : 'hsv' === m[1]
              ? (function hsv2rgb(h, s, v) {
                  return calln(hsv2rgbn, h, s, v);
                })(h, p1, p2)
              : hsl2rgb(h, p1, p2)),
          { r: v[0], g: v[1], b: v[2], a }
        );
      }
      const map = {
          x: 'dark',
          Z: 'light',
          Y: 're',
          X: 'blu',
          W: 'gr',
          V: 'medium',
          U: 'slate',
          A: 'ee',
          T: 'ol',
          S: 'or',
          B: 'ra',
          C: 'lateg',
          D: 'ights',
          R: 'in',
          Q: 'turquois',
          E: 'hi',
          P: 'ro',
          O: 'al',
          N: 'le',
          M: 'de',
          L: 'yello',
          F: 'en',
          K: 'ch',
          G: 'arks',
          H: 'ea',
          I: 'ightg',
          J: 'wh',
        },
        names$1 = {
          OiceXe: 'f0f8ff',
          antiquewEte: 'faebd7',
          aqua: 'ffff',
          aquamarRe: '7fffd4',
          azuY: 'f0ffff',
          beige: 'f5f5dc',
          bisque: 'ffe4c4',
          black: '0',
          blanKedOmond: 'ffebcd',
          Xe: 'ff',
          XeviTet: '8a2be2',
          bPwn: 'a52a2a',
          burlywood: 'deb887',
          caMtXe: '5f9ea0',
          KartYuse: '7fff00',
          KocTate: 'd2691e',
          cSO: 'ff7f50',
          cSnflowerXe: '6495ed',
          cSnsilk: 'fff8dc',
          crimson: 'dc143c',
          cyan: 'ffff',
          xXe: '8b',
          xcyan: '8b8b',
          xgTMnPd: 'b8860b',
          xWay: 'a9a9a9',
          xgYF: '6400',
          xgYy: 'a9a9a9',
          xkhaki: 'bdb76b',
          xmagFta: '8b008b',
          xTivegYF: '556b2f',
          xSange: 'ff8c00',
          xScEd: '9932cc',
          xYd: '8b0000',
          xsOmon: 'e9967a',
          xsHgYF: '8fbc8f',
          xUXe: '483d8b',
          xUWay: '2f4f4f',
          xUgYy: '2f4f4f',
          xQe: 'ced1',
          xviTet: '9400d3',
          dAppRk: 'ff1493',
          dApskyXe: 'bfff',
          dimWay: '696969',
          dimgYy: '696969',
          dodgerXe: '1e90ff',
          fiYbrick: 'b22222',
          flSOwEte: 'fffaf0',
          foYstWAn: '228b22',
          fuKsia: 'ff00ff',
          gaRsbSo: 'dcdcdc',
          ghostwEte: 'f8f8ff',
          gTd: 'ffd700',
          gTMnPd: 'daa520',
          Way: '808080',
          gYF: '8000',
          gYFLw: 'adff2f',
          gYy: '808080',
          honeyMw: 'f0fff0',
          hotpRk: 'ff69b4',
          RdianYd: 'cd5c5c',
          Rdigo: '4b0082',
          ivSy: 'fffff0',
          khaki: 'f0e68c',
          lavFMr: 'e6e6fa',
          lavFMrXsh: 'fff0f5',
          lawngYF: '7cfc00',
          NmoncEffon: 'fffacd',
          ZXe: 'add8e6',
          ZcSO: 'f08080',
          Zcyan: 'e0ffff',
          ZgTMnPdLw: 'fafad2',
          ZWay: 'd3d3d3',
          ZgYF: '90ee90',
          ZgYy: 'd3d3d3',
          ZpRk: 'ffb6c1',
          ZsOmon: 'ffa07a',
          ZsHgYF: '20b2aa',
          ZskyXe: '87cefa',
          ZUWay: '778899',
          ZUgYy: '778899',
          ZstAlXe: 'b0c4de',
          ZLw: 'ffffe0',
          lime: 'ff00',
          limegYF: '32cd32',
          lRF: 'faf0e6',
          magFta: 'ff00ff',
          maPon: '800000',
          VaquamarRe: '66cdaa',
          VXe: 'cd',
          VScEd: 'ba55d3',
          VpurpN: '9370db',
          VsHgYF: '3cb371',
          VUXe: '7b68ee',
          VsprRggYF: 'fa9a',
          VQe: '48d1cc',
          VviTetYd: 'c71585',
          midnightXe: '191970',
          mRtcYam: 'f5fffa',
          mistyPse: 'ffe4e1',
          moccasR: 'ffe4b5',
          navajowEte: 'ffdead',
          navy: '80',
          Tdlace: 'fdf5e6',
          Tive: '808000',
          TivedBb: '6b8e23',
          Sange: 'ffa500',
          SangeYd: 'ff4500',
          ScEd: 'da70d6',
          pOegTMnPd: 'eee8aa',
          pOegYF: '98fb98',
          pOeQe: 'afeeee',
          pOeviTetYd: 'db7093',
          papayawEp: 'ffefd5',
          pHKpuff: 'ffdab9',
          peru: 'cd853f',
          pRk: 'ffc0cb',
          plum: 'dda0dd',
          powMrXe: 'b0e0e6',
          purpN: '800080',
          YbeccapurpN: '663399',
          Yd: 'ff0000',
          Psybrown: 'bc8f8f',
          PyOXe: '4169e1',
          saddNbPwn: '8b4513',
          sOmon: 'fa8072',
          sandybPwn: 'f4a460',
          sHgYF: '2e8b57',
          sHshell: 'fff5ee',
          siFna: 'a0522d',
          silver: 'c0c0c0',
          skyXe: '87ceeb',
          UXe: '6a5acd',
          UWay: '708090',
          UgYy: '708090',
          snow: 'fffafa',
          sprRggYF: 'ff7f',
          stAlXe: '4682b4',
          tan: 'd2b48c',
          teO: '8080',
          tEstN: 'd8bfd8',
          tomato: 'ff6347',
          Qe: '40e0d0',
          viTet: 'ee82ee',
          JHt: 'f5deb3',
          wEte: 'ffffff',
          wEtesmoke: 'f5f5f5',
          Lw: 'ffff00',
          LwgYF: '9acd32',
        };
      let names;
      function nameParse(str) {
        names ||
          ((names = (function unpack() {
            const unpacked = {},
              keys = Object.keys(names$1),
              tkeys = Object.keys(map);
            let i, j, k, ok, nk;
            for (i = 0; i < keys.length; i++) {
              for (ok = nk = keys[i], j = 0; j < tkeys.length; j++)
                (k = tkeys[j]), (nk = nk.replace(k, map[k]));
              (k = parseInt(names$1[ok], 16)),
                (unpacked[nk] = [(k >> 16) & 255, (k >> 8) & 255, 255 & k]);
            }
            return unpacked;
          })()),
          (names.transparent = [0, 0, 0, 0]));
        const a = names[str.toLowerCase()];
        return (
          a && { r: a[0], g: a[1], b: a[2], a: 4 === a.length ? a[3] : 255 }
        );
      }
      const RGB_RE =
        /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
      const to = (v) =>
          v <= 0.0031308 ? 12.92 * v : 1.055 * Math.pow(v, 1 / 2.4) - 0.055,
        from = (v) =>
          v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
      function modHSL(v, i, ratio) {
        if (v) {
          let tmp = rgb2hsl(v);
          (tmp[i] = Math.max(
            0,
            Math.min(tmp[i] + tmp[i] * ratio, 0 === i ? 360 : 1)
          )),
            (tmp = hsl2rgb(tmp)),
            (v.r = tmp[0]),
            (v.g = tmp[1]),
            (v.b = tmp[2]);
        }
      }
      function clone(v, proto) {
        return v ? Object.assign(proto || {}, v) : v;
      }
      function fromObject(input) {
        var v = { r: 0, g: 0, b: 0, a: 255 };
        return (
          Array.isArray(input)
            ? input.length >= 3 &&
              ((v = { r: input[0], g: input[1], b: input[2], a: 255 }),
              input.length > 3 && (v.a = n2b(input[3])))
            : ((v = clone(input, { r: 0, g: 0, b: 0, a: 1 })).a = n2b(v.a)),
          v
        );
      }
      function functionParse(str) {
        return 'r' === str.charAt(0)
          ? (function rgbParse(str) {
              const m = RGB_RE.exec(str);
              let r,
                g,
                b,
                a = 255;
              if (m) {
                if (m[7] !== r) {
                  const v = +m[7];
                  a = m[8] ? p2b(v) : lim(255 * v, 0, 255);
                }
                return (
                  (r = +m[1]),
                  (g = +m[3]),
                  (b = +m[5]),
                  (r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255))),
                  (g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255))),
                  (b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255))),
                  { r, g, b, a }
                );
              }
            })(str)
          : hueParse(str);
      }
      class Color {
        constructor(input) {
          if (input instanceof Color) return input;
          const type = typeof input;
          let v;
          'object' === type
            ? (v = fromObject(input))
            : 'string' === type &&
              (v =
                (function hexParse(str) {
                  var ret,
                    len = str.length;
                  return (
                    '#' === str[0] &&
                      (4 === len || 5 === len
                        ? (ret = {
                            r: 255 & (17 * map$1[str[1]]),
                            g: 255 & (17 * map$1[str[2]]),
                            b: 255 & (17 * map$1[str[3]]),
                            a: 5 === len ? 17 * map$1[str[4]] : 255,
                          })
                        : (7 !== len && 9 !== len) ||
                          (ret = {
                            r: (map$1[str[1]] << 4) | map$1[str[2]],
                            g: (map$1[str[3]] << 4) | map$1[str[4]],
                            b: (map$1[str[5]] << 4) | map$1[str[6]],
                            a:
                              9 === len
                                ? (map$1[str[7]] << 4) | map$1[str[8]]
                                : 255,
                          })),
                    ret
                  );
                })(input) ||
                nameParse(input) ||
                functionParse(input)),
            (this._rgb = v),
            (this._valid = !!v);
        }
        get valid() {
          return this._valid;
        }
        get rgb() {
          var v = clone(this._rgb);
          return v && (v.a = b2n(v.a)), v;
        }
        set rgb(obj) {
          this._rgb = fromObject(obj);
        }
        rgbString() {
          return this._valid
            ? (function rgbString(v) {
                return (
                  v &&
                  (v.a < 255
                    ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`
                    : `rgb(${v.r}, ${v.g}, ${v.b})`)
                );
              })(this._rgb)
            : void 0;
        }
        hexString() {
          return this._valid
            ? (function hexString(v) {
                var f = isShort(v) ? h1 : h2;
                return v
                  ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)
                  : void 0;
              })(this._rgb)
            : void 0;
        }
        hslString() {
          return this._valid
            ? (function hslString(v) {
                if (!v) return;
                const a = rgb2hsl(v),
                  h = a[0],
                  s = n2p(a[1]),
                  l = n2p(a[2]);
                return v.a < 255
                  ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`
                  : `hsl(${h}, ${s}%, ${l}%)`;
              })(this._rgb)
            : void 0;
        }
        mix(color, weight) {
          if (color) {
            const c1 = this.rgb,
              c2 = color.rgb;
            let w2;
            const p = weight === w2 ? 0.5 : weight,
              w = 2 * p - 1,
              a = c1.a - c2.a,
              w1 = ((w * a == -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
            (w2 = 1 - w1),
              (c1.r = 255 & (w1 * c1.r + w2 * c2.r + 0.5)),
              (c1.g = 255 & (w1 * c1.g + w2 * c2.g + 0.5)),
              (c1.b = 255 & (w1 * c1.b + w2 * c2.b + 0.5)),
              (c1.a = p * c1.a + (1 - p) * c2.a),
              (this.rgb = c1);
          }
          return this;
        }
        interpolate(color, t) {
          return (
            color &&
              (this._rgb = (function interpolate(rgb1, rgb2, t) {
                const r = from(b2n(rgb1.r)),
                  g = from(b2n(rgb1.g)),
                  b = from(b2n(rgb1.b));
                return {
                  r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
                  g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
                  b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
                  a: rgb1.a + t * (rgb2.a - rgb1.a),
                };
              })(this._rgb, color._rgb, t)),
            this
          );
        }
        clone() {
          return new Color(this.rgb);
        }
        alpha(a) {
          return (this._rgb.a = n2b(a)), this;
        }
        clearer(ratio) {
          return (this._rgb.a *= 1 - ratio), this;
        }
        greyscale() {
          const rgb = this._rgb,
            val = round(0.3 * rgb.r + 0.59 * rgb.g + 0.11 * rgb.b);
          return (rgb.r = rgb.g = rgb.b = val), this;
        }
        opaquer(ratio) {
          return (this._rgb.a *= 1 + ratio), this;
        }
        negate() {
          const v = this._rgb;
          return (v.r = 255 - v.r), (v.g = 255 - v.g), (v.b = 255 - v.b), this;
        }
        lighten(ratio) {
          return modHSL(this._rgb, 2, ratio), this;
        }
        darken(ratio) {
          return modHSL(this._rgb, 2, -ratio), this;
        }
        saturate(ratio) {
          return modHSL(this._rgb, 1, ratio), this;
        }
        desaturate(ratio) {
          return modHSL(this._rgb, 1, -ratio), this;
        }
        rotate(deg) {
          return (
            (function rotate(v, deg) {
              var h = rgb2hsl(v);
              (h[0] = hue(h[0] + deg)),
                (h = hsl2rgb(h)),
                (v.r = h[0]),
                (v.g = h[1]),
                (v.b = h[2]);
            })(this._rgb, deg),
            this
          );
        }
      }
      function noop() {}
      const uid = (() => {
        let id = 0;
        return () => id++;
      })();
      function isNullOrUndef(value) {
        return null == value;
      }
      function isArray(value) {
        if (Array.isArray && Array.isArray(value)) return !0;
        const type = Object.prototype.toString.call(value);
        return '[object' === type.slice(0, 7) && 'Array]' === type.slice(-6);
      }
      function isObject(value) {
        return (
          null !== value &&
          '[object Object]' === Object.prototype.toString.call(value)
        );
      }
      function isNumberFinite(value) {
        return (
          ('number' == typeof value || value instanceof Number) &&
          isFinite(+value)
        );
      }
      function finiteOrDefault(value, defaultValue) {
        return isNumberFinite(value) ? value : defaultValue;
      }
      function valueOrDefault(value, defaultValue) {
        return void 0 === value ? defaultValue : value;
      }
      const toDimension = (value, dimension) =>
        'string' == typeof value && value.endsWith('%')
          ? (parseFloat(value) / 100) * dimension
          : +value;
      function callback(fn, args, thisArg) {
        if (fn && 'function' == typeof fn.call) return fn.apply(thisArg, args);
      }
      function each(loopable, fn, thisArg, reverse) {
        let i, len, keys;
        if (isArray(loopable))
          if (((len = loopable.length), reverse))
            for (i = len - 1; i >= 0; i--) fn.call(thisArg, loopable[i], i);
          else for (i = 0; i < len; i++) fn.call(thisArg, loopable[i], i);
        else if (isObject(loopable))
          for (
            keys = Object.keys(loopable), len = keys.length, i = 0;
            i < len;
            i++
          )
            fn.call(thisArg, loopable[keys[i]], keys[i]);
      }
      function _elementsEqual(a0, a1) {
        let i, ilen, v0, v1;
        if (!a0 || !a1 || a0.length !== a1.length) return !1;
        for (i = 0, ilen = a0.length; i < ilen; ++i)
          if (
            ((v0 = a0[i]),
            (v1 = a1[i]),
            v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index)
          )
            return !1;
        return !0;
      }
      function helpers_segment_clone(source) {
        if (isArray(source)) return source.map(helpers_segment_clone);
        if (isObject(source)) {
          const target = Object.create(null),
            keys = Object.keys(source),
            klen = keys.length;
          let k = 0;
          for (; k < klen; ++k)
            target[keys[k]] = helpers_segment_clone(source[keys[k]]);
          return target;
        }
        return source;
      }
      function isValidKey(key) {
        return -1 === ['__proto__', 'prototype', 'constructor'].indexOf(key);
      }
      function _merger(key, target, source, options) {
        if (!isValidKey(key)) return;
        const tval = target[key],
          sval = source[key];
        isObject(tval) && isObject(sval)
          ? merge(tval, sval, options)
          : (target[key] = helpers_segment_clone(sval));
      }
      function merge(target, source, options) {
        const sources = isArray(source) ? source : [source],
          ilen = sources.length;
        if (!isObject(target)) return target;
        const merger = (options = options || {}).merger || _merger;
        let current;
        for (let i = 0; i < ilen; ++i) {
          if (((current = sources[i]), !isObject(current))) continue;
          const keys = Object.keys(current);
          for (let k = 0, klen = keys.length; k < klen; ++k)
            merger(keys[k], target, current, options);
        }
        return target;
      }
      function mergeIf(target, source) {
        return merge(target, source, { merger: _mergerIf });
      }
      function _mergerIf(key, target, source) {
        if (!isValidKey(key)) return;
        const tval = target[key],
          sval = source[key];
        isObject(tval) && isObject(sval)
          ? mergeIf(tval, sval)
          : Object.prototype.hasOwnProperty.call(target, key) ||
            (target[key] = helpers_segment_clone(sval));
      }
      const keyResolvers = { '': (v) => v, x: (o) => o.x, y: (o) => o.y };
      function resolveObjectKey(obj, key) {
        const resolver =
          keyResolvers[key] ||
          (keyResolvers[key] = (function _getKeyResolver(key) {
            const keys = (function _splitKey(key) {
              const parts = key.split('.'),
                keys = [];
              let tmp = '';
              for (const part of parts)
                (tmp += part),
                  tmp.endsWith('\\')
                    ? (tmp = tmp.slice(0, -1) + '.')
                    : (keys.push(tmp), (tmp = ''));
              return keys;
            })(key);
            return (obj) => {
              for (const k of keys) {
                if ('' === k) break;
                obj = obj && obj[k];
              }
              return obj;
            };
          })(key));
        return resolver(obj);
      }
      function _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      }
      const defined = (value) => void 0 !== value,
        isFunction = (value) => 'function' == typeof value,
        setsEqual = (a, b) => {
          if (a.size !== b.size) return !1;
          for (const item of a) if (!b.has(item)) return !1;
          return !0;
        };
      const PI = Math.PI,
        TAU = 2 * PI,
        PITAU = TAU + PI,
        INFINITY = Number.POSITIVE_INFINITY,
        RAD_PER_DEG = PI / 180,
        HALF_PI = PI / 2,
        QUARTER_PI = PI / 4,
        TWO_THIRDS_PI = (2 * PI) / 3,
        log10 = Math.log10,
        sign = Math.sign;
      function almostEquals(x, y, epsilon) {
        return Math.abs(x - y) < epsilon;
      }
      function niceNum(range) {
        const roundedRange = Math.round(range);
        range = almostEquals(range, roundedRange, range / 1e3)
          ? roundedRange
          : range;
        const niceRange = Math.pow(10, Math.floor(log10(range))),
          fraction = range / niceRange;
        return (
          (fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10) *
          niceRange
        );
      }
      function isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      }
      function _setMinAndMaxByKey(array, target, property) {
        let i, ilen, value;
        for (i = 0, ilen = array.length; i < ilen; i++)
          (value = array[i][property]),
            isNaN(value) ||
              ((target.min = Math.min(target.min, value)),
              (target.max = Math.max(target.max, value)));
      }
      function toRadians(degrees) {
        return degrees * (PI / 180);
      }
      function toDegrees(radians) {
        return radians * (180 / PI);
      }
      function _decimalPlaces(x) {
        if (!isNumberFinite(x)) return;
        let e = 1,
          p = 0;
        for (; Math.round(x * e) / e !== x; ) (e *= 10), p++;
        return p;
      }
      function getAngleFromPoint(centrePoint, anglePoint) {
        const distanceFromXCenter = anglePoint.x - centrePoint.x,
          distanceFromYCenter = anglePoint.y - centrePoint.y,
          radialDistanceFromCenter = Math.sqrt(
            distanceFromXCenter * distanceFromXCenter +
              distanceFromYCenter * distanceFromYCenter
          );
        let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
        return (
          angle < -0.5 * PI && (angle += TAU),
          { angle, distance: radialDistanceFromCenter }
        );
      }
      function distanceBetweenPoints(pt1, pt2) {
        return Math.sqrt(
          Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2)
        );
      }
      function _angleDiff(a, b) {
        return ((a - b + PITAU) % TAU) - PI;
      }
      function _normalizeAngle(a) {
        return ((a % TAU) + TAU) % TAU;
      }
      function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
        const a = _normalizeAngle(angle),
          s = _normalizeAngle(start),
          e = _normalizeAngle(end),
          angleToStart = _normalizeAngle(s - a),
          angleToEnd = _normalizeAngle(e - a),
          startToAngle = _normalizeAngle(a - s),
          endToAngle = _normalizeAngle(a - e);
        return (
          a === s ||
          a === e ||
          (sameAngleIsFullCircle && s === e) ||
          (angleToStart > angleToEnd && startToAngle < endToAngle)
        );
      }
      function _limitValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
      }
      function _isBetween(value, start, end, epsilon = 1e-6) {
        return (
          value >= Math.min(start, end) - epsilon &&
          value <= Math.max(start, end) + epsilon
        );
      }
      function _lookup(table, value, cmp) {
        cmp = cmp || ((index) => table[index] < value);
        let mid,
          hi = table.length - 1,
          lo = 0;
        for (; hi - lo > 1; )
          (mid = (lo + hi) >> 1), cmp(mid) ? (lo = mid) : (hi = mid);
        return { lo, hi };
      }
      const _lookupByKey = (table, key, value, last) =>
          _lookup(
            table,
            value,
            last
              ? (index) => {
                  const ti = table[index][key];
                  return (
                    ti < value ||
                    (ti === value && table[index + 1][key] === value)
                  );
                }
              : (index) => table[index][key] < value
          ),
        _rlookupByKey = (table, key, value) =>
          _lookup(table, value, (index) => table[index][key] >= value);
      const arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];
      function unlistenArrayEvents(array, listener) {
        const stub = array._chartjs;
        if (!stub) return;
        const listeners = stub.listeners,
          index = listeners.indexOf(listener);
        -1 !== index && listeners.splice(index, 1),
          listeners.length > 0 ||
            (arrayEvents.forEach((key) => {
              delete array[key];
            }),
            delete array._chartjs);
      }
      function _arrayUnique(items) {
        const set = new Set();
        let i, ilen;
        for (i = 0, ilen = items.length; i < ilen; ++i) set.add(items[i]);
        return set.size === ilen ? items : Array.from(set);
      }
      const requestAnimFrame =
        'undefined' == typeof window
          ? function (callback) {
              return callback();
            }
          : window.requestAnimationFrame;
      function throttled(fn, thisArg) {
        let argsToUse = [],
          ticking = !1;
        return function (...args) {
          (argsToUse = args),
            ticking ||
              ((ticking = !0),
              requestAnimFrame.call(window, () => {
                (ticking = !1), fn.apply(thisArg, argsToUse);
              }));
        };
      }
      const _toLeftRightCenter = (align) =>
          'start' === align ? 'left' : 'end' === align ? 'right' : 'center',
        _alignStartEnd = (align, start, end) =>
          'start' === align ? start : 'end' === align ? end : (start + end) / 2;
      function _getStartAndCountOfVisiblePoints(
        meta,
        points,
        animationsDisabled
      ) {
        const pointCount = points.length;
        let start = 0,
          count = pointCount;
        if (meta._sorted) {
          const { iScale, _parsed } = meta,
            axis = iScale.axis,
            { min, max, minDefined, maxDefined } = iScale.getUserBounds();
          minDefined &&
            (start = _limitValue(
              Math.min(
                _lookupByKey(_parsed, iScale.axis, min).lo,
                animationsDisabled
                  ? pointCount
                  : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo
              ),
              0,
              pointCount - 1
            )),
            (count = maxDefined
              ? _limitValue(
                  Math.max(
                    _lookupByKey(_parsed, iScale.axis, max, !0).hi + 1,
                    animationsDisabled
                      ? 0
                      : _lookupByKey(
                          points,
                          axis,
                          iScale.getPixelForValue(max),
                          !0
                        ).hi + 1
                  ),
                  start,
                  pointCount
                ) - start
              : pointCount - start);
        }
        return { start, count };
      }
      function _scaleRangesChanged(meta) {
        const { xScale, yScale, _scaleRanges } = meta,
          newRanges = {
            xmin: xScale.min,
            xmax: xScale.max,
            ymin: yScale.min,
            ymax: yScale.max,
          };
        if (!_scaleRanges) return (meta._scaleRanges = newRanges), !0;
        const changed =
          _scaleRanges.xmin !== xScale.min ||
          _scaleRanges.xmax !== xScale.max ||
          _scaleRanges.ymin !== yScale.min ||
          _scaleRanges.ymax !== yScale.max;
        return Object.assign(_scaleRanges, newRanges), changed;
      }
      const atEdge = (t) => 0 === t || 1 === t,
        elasticIn = (t, s, p) =>
          -Math.pow(2, 10 * (t -= 1)) * Math.sin(((t - s) * TAU) / p),
        elasticOut = (t, s, p) =>
          Math.pow(2, -10 * t) * Math.sin(((t - s) * TAU) / p) + 1,
        effects = {
          linear: (t) => t,
          easeInQuad: (t) => t * t,
          easeOutQuad: (t) => -t * (t - 2),
          easeInOutQuad: (t) =>
            (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
          easeInCubic: (t) => t * t * t,
          easeOutCubic: (t) => (t -= 1) * t * t + 1,
          easeInOutCubic: (t) =>
            (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
          easeInQuart: (t) => t * t * t * t,
          easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
          easeInOutQuart: (t) =>
            (t /= 0.5) < 1
              ? 0.5 * t * t * t * t
              : -0.5 * ((t -= 2) * t * t * t - 2),
          easeInQuint: (t) => t * t * t * t * t,
          easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
          easeInOutQuint: (t) =>
            (t /= 0.5) < 1
              ? 0.5 * t * t * t * t * t
              : 0.5 * ((t -= 2) * t * t * t * t + 2),
          easeInSine: (t) => 1 - Math.cos(t * HALF_PI),
          easeOutSine: (t) => Math.sin(t * HALF_PI),
          easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
          easeInExpo: (t) => (0 === t ? 0 : Math.pow(2, 10 * (t - 1))),
          easeOutExpo: (t) => (1 === t ? 1 : 1 - Math.pow(2, -10 * t)),
          easeInOutExpo: (t) =>
            atEdge(t)
              ? t
              : t < 0.5
              ? 0.5 * Math.pow(2, 10 * (2 * t - 1))
              : 0.5 * (2 - Math.pow(2, -10 * (2 * t - 1))),
          easeInCirc: (t) => (t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1)),
          easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
          easeInOutCirc: (t) =>
            (t /= 0.5) < 1
              ? -0.5 * (Math.sqrt(1 - t * t) - 1)
              : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
          easeInElastic: (t) => (atEdge(t) ? t : elasticIn(t, 0.075, 0.3)),
          easeOutElastic: (t) => (atEdge(t) ? t : elasticOut(t, 0.075, 0.3)),
          easeInOutElastic(t) {
            const s = 0.1125;
            return atEdge(t)
              ? t
              : t < 0.5
              ? 0.5 * elasticIn(2 * t, s, 0.45)
              : 0.5 + 0.5 * elasticOut(2 * t - 1, s, 0.45);
          },
          easeInBack(t) {
            const s = 1.70158;
            return t * t * ((s + 1) * t - s);
          },
          easeOutBack(t) {
            const s = 1.70158;
            return (t -= 1) * t * ((s + 1) * t + s) + 1;
          },
          easeInOutBack(t) {
            let s = 1.70158;
            return (t /= 0.5) < 1
              ? t * t * ((1 + (s *= 1.525)) * t - s) * 0.5
              : 0.5 * ((t -= 2) * t * ((1 + (s *= 1.525)) * t + s) + 2);
          },
          easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
          easeOutBounce(t) {
            const m = 7.5625,
              d = 2.75;
            return t < 1 / d
              ? m * t * t
              : t < 2 / d
              ? m * (t -= 1.5 / d) * t + 0.75
              : t < 2.5 / d
              ? m * (t -= 2.25 / d) * t + 0.9375
              : m * (t -= 2.625 / d) * t + 0.984375;
          },
          easeInOutBounce: (t) =>
            t < 0.5
              ? 0.5 * effects.easeInBounce(2 * t)
              : 0.5 * effects.easeOutBounce(2 * t - 1) + 0.5,
        };
      function isPatternOrGradient(value) {
        if (value && 'object' == typeof value) {
          const type = value.toString();
          return (
            '[object CanvasPattern]' === type ||
            '[object CanvasGradient]' === type
          );
        }
        return !1;
      }
      function color(value) {
        return isPatternOrGradient(value) ? value : new Color(value);
      }
      function getHoverColor(value) {
        return isPatternOrGradient(value)
          ? value
          : new Color(value).saturate(0.5).darken(0.1).hexString();
      }
      const numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'],
        colors = ['color', 'borderColor', 'backgroundColor'];
      const intlCache = new Map();
      function formatNumber(num, locale, options) {
        return (function getNumberFormat(locale, options) {
          options = options || {};
          const cacheKey = locale + JSON.stringify(options);
          let formatter = intlCache.get(cacheKey);
          return (
            formatter ||
              ((formatter = new Intl.NumberFormat(locale, options)),
              intlCache.set(cacheKey, formatter)),
            formatter
          );
        })(locale, options).format(num);
      }
      const formatters = {
        values: (value) => (isArray(value) ? value : '' + value),
        numeric(tickValue, index, ticks) {
          if (0 === tickValue) return '0';
          const locale = this.chart.options.locale;
          let notation,
            delta = tickValue;
          if (ticks.length > 1) {
            const maxTick = Math.max(
              Math.abs(ticks[0].value),
              Math.abs(ticks[ticks.length - 1].value)
            );
            (maxTick < 1e-4 || maxTick > 1e15) && (notation = 'scientific'),
              (delta = (function calculateDelta(tickValue, ticks) {
                let delta =
                  ticks.length > 3
                    ? ticks[2].value - ticks[1].value
                    : ticks[1].value - ticks[0].value;
                Math.abs(delta) >= 1 &&
                  tickValue !== Math.floor(tickValue) &&
                  (delta = tickValue - Math.floor(tickValue));
                return delta;
              })(tickValue, ticks));
          }
          const logDelta = log10(Math.abs(delta)),
            numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0),
            options = {
              notation,
              minimumFractionDigits: numDecimal,
              maximumFractionDigits: numDecimal,
            };
          return (
            Object.assign(options, this.options.ticks.format),
            formatNumber(tickValue, locale, options)
          );
        },
        logarithmic(tickValue, index, ticks) {
          if (0 === tickValue) return '0';
          const remain =
            ticks[index].significand ||
            tickValue / Math.pow(10, Math.floor(log10(tickValue)));
          return [1, 2, 3, 5, 10, 15].includes(remain) ||
            index > 0.8 * ticks.length
            ? formatters.numeric.call(this, tickValue, index, ticks)
            : '';
        },
      };
      var Ticks = { formatters };
      const overrides = Object.create(null),
        descriptors = Object.create(null);
      function getScope$1(node, key) {
        if (!key) return node;
        const keys = key.split('.');
        for (let i = 0, n = keys.length; i < n; ++i) {
          const k = keys[i];
          node = node[k] || (node[k] = Object.create(null));
        }
        return node;
      }
      function set(root, scope, values) {
        return 'string' == typeof scope
          ? merge(getScope$1(root, scope), values)
          : merge(getScope$1(root, ''), scope);
      }
      class Defaults {
        constructor(_descriptors, _appliers) {
          (this.animation = void 0),
            (this.backgroundColor = 'rgba(0,0,0,0.1)'),
            (this.borderColor = 'rgba(0,0,0,0.1)'),
            (this.color = '#666'),
            (this.datasets = {}),
            (this.devicePixelRatio = (context) =>
              context.chart.platform.getDevicePixelRatio()),
            (this.elements = {}),
            (this.events = [
              'mousemove',
              'mouseout',
              'click',
              'touchstart',
              'touchmove',
            ]),
            (this.font = {
              family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
              size: 12,
              style: 'normal',
              lineHeight: 1.2,
              weight: null,
            }),
            (this.hover = {}),
            (this.hoverBackgroundColor = (ctx, options) =>
              getHoverColor(options.backgroundColor)),
            (this.hoverBorderColor = (ctx, options) =>
              getHoverColor(options.borderColor)),
            (this.hoverColor = (ctx, options) => getHoverColor(options.color)),
            (this.indexAxis = 'x'),
            (this.interaction = {
              mode: 'nearest',
              intersect: !0,
              includeInvisible: !1,
            }),
            (this.maintainAspectRatio = !0),
            (this.onHover = null),
            (this.onClick = null),
            (this.parsing = !0),
            (this.plugins = {}),
            (this.responsive = !0),
            (this.scale = void 0),
            (this.scales = {}),
            (this.showLine = !0),
            (this.drawActiveElementsOnTop = !0),
            this.describe(_descriptors),
            this.apply(_appliers);
        }
        set(scope, values) {
          return set(this, scope, values);
        }
        get(scope) {
          return getScope$1(this, scope);
        }
        describe(scope, values) {
          return set(descriptors, scope, values);
        }
        override(scope, values) {
          return set(overrides, scope, values);
        }
        route(scope, name, targetScope, targetName) {
          const scopeObject = getScope$1(this, scope),
            targetScopeObject = getScope$1(this, targetScope),
            privateName = '_' + name;
          Object.defineProperties(scopeObject, {
            [privateName]: { value: scopeObject[name], writable: !0 },
            [name]: {
              enumerable: !0,
              get() {
                const local = this[privateName],
                  target = targetScopeObject[targetName];
                return isObject(local)
                  ? Object.assign({}, target, local)
                  : valueOrDefault(local, target);
              },
              set(value) {
                this[privateName] = value;
              },
            },
          });
        }
        apply(appliers) {
          appliers.forEach((apply) => apply(this));
        }
      }
      var defaults = new Defaults(
        {
          _scriptable: (name) => !name.startsWith('on'),
          _indexable: (name) => 'events' !== name,
          hover: { _fallback: 'interaction' },
          interaction: { _scriptable: !1, _indexable: !1 },
        },
        [
          function applyAnimationsDefaults(defaults) {
            defaults.set('animation', {
              delay: void 0,
              duration: 1e3,
              easing: 'easeOutQuart',
              fn: void 0,
              from: void 0,
              loop: void 0,
              to: void 0,
              type: void 0,
            }),
              defaults.describe('animation', {
                _fallback: !1,
                _indexable: !1,
                _scriptable: (name) =>
                  'onProgress' !== name &&
                  'onComplete' !== name &&
                  'fn' !== name,
              }),
              defaults.set('animations', {
                colors: { type: 'color', properties: colors },
                numbers: { type: 'number', properties: numbers },
              }),
              defaults.describe('animations', { _fallback: 'animation' }),
              defaults.set('transitions', {
                active: { animation: { duration: 400 } },
                resize: { animation: { duration: 0 } },
                show: {
                  animations: {
                    colors: { from: 'transparent' },
                    visible: { type: 'boolean', duration: 0 },
                  },
                },
                hide: {
                  animations: {
                    colors: { to: 'transparent' },
                    visible: {
                      type: 'boolean',
                      easing: 'linear',
                      fn: (v) => 0 | v,
                    },
                  },
                },
              });
          },
          function applyLayoutsDefaults(defaults) {
            defaults.set('layout', {
              autoPadding: !0,
              padding: { top: 0, right: 0, bottom: 0, left: 0 },
            });
          },
          function applyScaleDefaults(defaults) {
            defaults.set('scale', {
              display: !0,
              offset: !1,
              reverse: !1,
              beginAtZero: !1,
              bounds: 'ticks',
              grace: 0,
              grid: {
                display: !0,
                lineWidth: 1,
                drawOnChartArea: !0,
                drawTicks: !0,
                tickLength: 8,
                tickWidth: (_ctx, options) => options.lineWidth,
                tickColor: (_ctx, options) => options.color,
                offset: !1,
              },
              border: { display: !0, dash: [], dashOffset: 0, width: 1 },
              title: { display: !1, text: '', padding: { top: 4, bottom: 4 } },
              ticks: {
                minRotation: 0,
                maxRotation: 50,
                mirror: !1,
                textStrokeWidth: 0,
                textStrokeColor: '',
                padding: 3,
                display: !0,
                autoSkip: !0,
                autoSkipPadding: 3,
                labelOffset: 0,
                callback: Ticks.formatters.values,
                minor: {},
                major: {},
                align: 'center',
                crossAlign: 'near',
                showLabelBackdrop: !1,
                backdropColor: 'rgba(255, 255, 255, 0.75)',
                backdropPadding: 2,
              },
            }),
              defaults.route('scale.ticks', 'color', '', 'color'),
              defaults.route('scale.grid', 'color', '', 'borderColor'),
              defaults.route('scale.border', 'color', '', 'borderColor'),
              defaults.route('scale.title', 'color', '', 'color'),
              defaults.describe('scale', {
                _fallback: !1,
                _scriptable: (name) =>
                  !name.startsWith('before') &&
                  !name.startsWith('after') &&
                  'callback' !== name &&
                  'parser' !== name,
                _indexable: (name) =>
                  'borderDash' !== name &&
                  'tickBorderDash' !== name &&
                  'dash' !== name,
              }),
              defaults.describe('scales', { _fallback: 'scale' }),
              defaults.describe('scale.ticks', {
                _scriptable: (name) =>
                  'backdropPadding' !== name && 'callback' !== name,
                _indexable: (name) => 'backdropPadding' !== name,
              });
          },
        ]
      );
      function _measureText(ctx, data, gc, longest, string) {
        let textWidth = data[string];
        return (
          textWidth ||
            ((textWidth = data[string] = ctx.measureText(string).width),
            gc.push(string)),
          textWidth > longest && (longest = textWidth),
          longest
        );
      }
      function _alignPixel(chart, pixel, width) {
        const devicePixelRatio = chart.currentDevicePixelRatio,
          halfWidth = 0 !== width ? Math.max(width / 2, 0.5) : 0;
        return (
          Math.round((pixel - halfWidth) * devicePixelRatio) /
            devicePixelRatio +
          halfWidth
        );
      }
      function clearCanvas(canvas, ctx) {
        (ctx = ctx || canvas.getContext('2d')).save(),
          ctx.resetTransform(),
          ctx.clearRect(0, 0, canvas.width, canvas.height),
          ctx.restore();
      }
      function drawPoint(ctx, options, x, y) {
        drawPointLegend(ctx, options, x, y, null);
      }
      function drawPointLegend(ctx, options, x, y, w) {
        let type,
          xOffset,
          yOffset,
          size,
          cornerRadius,
          width,
          xOffsetW,
          yOffsetW;
        const style = options.pointStyle,
          rotation = options.rotation,
          radius = options.radius;
        let rad = (rotation || 0) * RAD_PER_DEG;
        if (
          style &&
          'object' == typeof style &&
          ((type = style.toString()),
          '[object HTMLImageElement]' === type ||
            '[object HTMLCanvasElement]' === type)
        )
          return (
            ctx.save(),
            ctx.translate(x, y),
            ctx.rotate(rad),
            ctx.drawImage(
              style,
              -style.width / 2,
              -style.height / 2,
              style.width,
              style.height
            ),
            void ctx.restore()
          );
        if (!(isNaN(radius) || radius <= 0)) {
          switch ((ctx.beginPath(), style)) {
            default:
              w
                ? ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU)
                : ctx.arc(x, y, radius, 0, TAU),
                ctx.closePath();
              break;
            case 'triangle':
              (width = w ? w / 2 : radius),
                ctx.moveTo(
                  x + Math.sin(rad) * width,
                  y - Math.cos(rad) * radius
                ),
                (rad += TWO_THIRDS_PI),
                ctx.lineTo(
                  x + Math.sin(rad) * width,
                  y - Math.cos(rad) * radius
                ),
                (rad += TWO_THIRDS_PI),
                ctx.lineTo(
                  x + Math.sin(rad) * width,
                  y - Math.cos(rad) * radius
                ),
                ctx.closePath();
              break;
            case 'rectRounded':
              (cornerRadius = 0.516 * radius),
                (size = radius - cornerRadius),
                (xOffset = Math.cos(rad + QUARTER_PI) * size),
                (xOffsetW =
                  Math.cos(rad + QUARTER_PI) *
                  (w ? w / 2 - cornerRadius : size)),
                (yOffset = Math.sin(rad + QUARTER_PI) * size),
                (yOffsetW =
                  Math.sin(rad + QUARTER_PI) *
                  (w ? w / 2 - cornerRadius : size)),
                ctx.arc(
                  x - xOffsetW,
                  y - yOffset,
                  cornerRadius,
                  rad - PI,
                  rad - HALF_PI
                ),
                ctx.arc(
                  x + yOffsetW,
                  y - xOffset,
                  cornerRadius,
                  rad - HALF_PI,
                  rad
                ),
                ctx.arc(
                  x + xOffsetW,
                  y + yOffset,
                  cornerRadius,
                  rad,
                  rad + HALF_PI
                ),
                ctx.arc(
                  x - yOffsetW,
                  y + xOffset,
                  cornerRadius,
                  rad + HALF_PI,
                  rad + PI
                ),
                ctx.closePath();
              break;
            case 'rect':
              if (!rotation) {
                (size = Math.SQRT1_2 * radius),
                  (width = w ? w / 2 : size),
                  ctx.rect(x - width, y - size, 2 * width, 2 * size);
                break;
              }
              rad += QUARTER_PI;
            case 'rectRot':
              (xOffsetW = Math.cos(rad) * (w ? w / 2 : radius)),
                (xOffset = Math.cos(rad) * radius),
                (yOffset = Math.sin(rad) * radius),
                (yOffsetW = Math.sin(rad) * (w ? w / 2 : radius)),
                ctx.moveTo(x - xOffsetW, y - yOffset),
                ctx.lineTo(x + yOffsetW, y - xOffset),
                ctx.lineTo(x + xOffsetW, y + yOffset),
                ctx.lineTo(x - yOffsetW, y + xOffset),
                ctx.closePath();
              break;
            case 'crossRot':
              rad += QUARTER_PI;
            case 'cross':
              (xOffsetW = Math.cos(rad) * (w ? w / 2 : radius)),
                (xOffset = Math.cos(rad) * radius),
                (yOffset = Math.sin(rad) * radius),
                (yOffsetW = Math.sin(rad) * (w ? w / 2 : radius)),
                ctx.moveTo(x - xOffsetW, y - yOffset),
                ctx.lineTo(x + xOffsetW, y + yOffset),
                ctx.moveTo(x + yOffsetW, y - xOffset),
                ctx.lineTo(x - yOffsetW, y + xOffset);
              break;
            case 'star':
              (xOffsetW = Math.cos(rad) * (w ? w / 2 : radius)),
                (xOffset = Math.cos(rad) * radius),
                (yOffset = Math.sin(rad) * radius),
                (yOffsetW = Math.sin(rad) * (w ? w / 2 : radius)),
                ctx.moveTo(x - xOffsetW, y - yOffset),
                ctx.lineTo(x + xOffsetW, y + yOffset),
                ctx.moveTo(x + yOffsetW, y - xOffset),
                ctx.lineTo(x - yOffsetW, y + xOffset),
                (rad += QUARTER_PI),
                (xOffsetW = Math.cos(rad) * (w ? w / 2 : radius)),
                (xOffset = Math.cos(rad) * radius),
                (yOffset = Math.sin(rad) * radius),
                (yOffsetW = Math.sin(rad) * (w ? w / 2 : radius)),
                ctx.moveTo(x - xOffsetW, y - yOffset),
                ctx.lineTo(x + xOffsetW, y + yOffset),
                ctx.moveTo(x + yOffsetW, y - xOffset),
                ctx.lineTo(x - yOffsetW, y + xOffset);
              break;
            case 'line':
              (xOffset = w ? w / 2 : Math.cos(rad) * radius),
                (yOffset = Math.sin(rad) * radius),
                ctx.moveTo(x - xOffset, y - yOffset),
                ctx.lineTo(x + xOffset, y + yOffset);
              break;
            case 'dash':
              ctx.moveTo(x, y),
                ctx.lineTo(
                  x + Math.cos(rad) * (w ? w / 2 : radius),
                  y + Math.sin(rad) * radius
                );
              break;
            case !1:
              ctx.closePath();
          }
          ctx.fill(), options.borderWidth > 0 && ctx.stroke();
        }
      }
      function _isPointInArea(point, area, margin) {
        return (
          (margin = margin || 0.5),
          !area ||
            (point &&
              point.x > area.left - margin &&
              point.x < area.right + margin &&
              point.y > area.top - margin &&
              point.y < area.bottom + margin)
        );
      }
      function clipArea(ctx, area) {
        ctx.save(),
          ctx.beginPath(),
          ctx.rect(
            area.left,
            area.top,
            area.right - area.left,
            area.bottom - area.top
          ),
          ctx.clip();
      }
      function unclipArea(ctx) {
        ctx.restore();
      }
      function _steppedLineTo(ctx, previous, target, flip, mode) {
        if (!previous) return ctx.lineTo(target.x, target.y);
        if ('middle' === mode) {
          const midpoint = (previous.x + target.x) / 2;
          ctx.lineTo(midpoint, previous.y), ctx.lineTo(midpoint, target.y);
        } else
          ('after' === mode) != !!flip
            ? ctx.lineTo(previous.x, target.y)
            : ctx.lineTo(target.x, previous.y);
        ctx.lineTo(target.x, target.y);
      }
      function _bezierCurveTo(ctx, previous, target, flip) {
        if (!previous) return ctx.lineTo(target.x, target.y);
        ctx.bezierCurveTo(
          flip ? previous.cp1x : previous.cp2x,
          flip ? previous.cp1y : previous.cp2y,
          flip ? target.cp2x : target.cp1x,
          flip ? target.cp2y : target.cp1y,
          target.x,
          target.y
        );
      }
      function renderText(ctx, text, x, y, font, opts = {}) {
        const lines = isArray(text) ? text : [text],
          stroke = opts.strokeWidth > 0 && '' !== opts.strokeColor;
        let i, line;
        for (
          ctx.save(),
            ctx.font = font.string,
            (function setRenderOpts(ctx, opts) {
              opts.translation &&
                ctx.translate(opts.translation[0], opts.translation[1]);
              isNullOrUndef(opts.rotation) || ctx.rotate(opts.rotation);
              opts.color && (ctx.fillStyle = opts.color);
              opts.textAlign && (ctx.textAlign = opts.textAlign);
              opts.textBaseline && (ctx.textBaseline = opts.textBaseline);
            })(ctx, opts),
            i = 0;
          i < lines.length;
          ++i
        )
          (line = lines[i]),
            opts.backdrop && drawBackdrop(ctx, opts.backdrop),
            stroke &&
              (opts.strokeColor && (ctx.strokeStyle = opts.strokeColor),
              isNullOrUndef(opts.strokeWidth) ||
                (ctx.lineWidth = opts.strokeWidth),
              ctx.strokeText(line, x, y, opts.maxWidth)),
            ctx.fillText(line, x, y, opts.maxWidth),
            decorateText(ctx, x, y, line, opts),
            (y += font.lineHeight);
        ctx.restore();
      }
      function decorateText(ctx, x, y, line, opts) {
        if (opts.strikethrough || opts.underline) {
          const metrics = ctx.measureText(line),
            left = x - metrics.actualBoundingBoxLeft,
            right = x + metrics.actualBoundingBoxRight,
            top = y - metrics.actualBoundingBoxAscent,
            bottom = y + metrics.actualBoundingBoxDescent,
            yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
          (ctx.strokeStyle = ctx.fillStyle),
            ctx.beginPath(),
            (ctx.lineWidth = opts.decorationWidth || 2),
            ctx.moveTo(left, yDecoration),
            ctx.lineTo(right, yDecoration),
            ctx.stroke();
        }
      }
      function drawBackdrop(ctx, opts) {
        const oldColor = ctx.fillStyle;
        (ctx.fillStyle = opts.color),
          ctx.fillRect(opts.left, opts.top, opts.width, opts.height),
          (ctx.fillStyle = oldColor);
      }
      function addRoundedRectPath(ctx, rect) {
        const { x, y, w, h, radius } = rect;
        ctx.arc(
          x + radius.topLeft,
          y + radius.topLeft,
          radius.topLeft,
          -HALF_PI,
          PI,
          !0
        ),
          ctx.lineTo(x, y + h - radius.bottomLeft),
          ctx.arc(
            x + radius.bottomLeft,
            y + h - radius.bottomLeft,
            radius.bottomLeft,
            PI,
            HALF_PI,
            !0
          ),
          ctx.lineTo(x + w - radius.bottomRight, y + h),
          ctx.arc(
            x + w - radius.bottomRight,
            y + h - radius.bottomRight,
            radius.bottomRight,
            HALF_PI,
            0,
            !0
          ),
          ctx.lineTo(x + w, y + radius.topRight),
          ctx.arc(
            x + w - radius.topRight,
            y + radius.topRight,
            radius.topRight,
            0,
            -HALF_PI,
            !0
          ),
          ctx.lineTo(x + radius.topLeft, y);
      }
      const LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,
        FONT_STYLE =
          /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
      function toLineHeight(value, size) {
        const matches = ('' + value).match(LINE_HEIGHT);
        if (!matches || 'normal' === matches[1]) return 1.2 * size;
        switch (((value = +matches[2]), matches[3])) {
          case 'px':
            return value;
          case '%':
            value /= 100;
        }
        return size * value;
      }
      const numberOrZero = (v) => +v || 0;
      function _readValueToProps(value, props) {
        const ret = {},
          objProps = isObject(props),
          keys = objProps ? Object.keys(props) : props,
          read = isObject(value)
            ? objProps
              ? (prop) => valueOrDefault(value[prop], value[props[prop]])
              : (prop) => value[prop]
            : () => value;
        for (const prop of keys) ret[prop] = numberOrZero(read(prop));
        return ret;
      }
      function toTRBL(value) {
        return _readValueToProps(value, {
          top: 'y',
          right: 'x',
          bottom: 'y',
          left: 'x',
        });
      }
      function toTRBLCorners(value) {
        return _readValueToProps(value, [
          'topLeft',
          'topRight',
          'bottomLeft',
          'bottomRight',
        ]);
      }
      function toPadding(value) {
        const obj = toTRBL(value);
        return (
          (obj.width = obj.left + obj.right),
          (obj.height = obj.top + obj.bottom),
          obj
        );
      }
      function toFont(options, fallback) {
        (options = options || {}), (fallback = fallback || defaults.font);
        let size = valueOrDefault(options.size, fallback.size);
        'string' == typeof size && (size = parseInt(size, 10));
        let style = valueOrDefault(options.style, fallback.style);
        style &&
          !('' + style).match(FONT_STYLE) &&
          (console.warn('Invalid font style specified: "' + style + '"'),
          (style = void 0));
        const font = {
          family: valueOrDefault(options.family, fallback.family),
          lineHeight: toLineHeight(
            valueOrDefault(options.lineHeight, fallback.lineHeight),
            size
          ),
          size,
          style,
          weight: valueOrDefault(options.weight, fallback.weight),
          string: '',
        };
        return (
          (font.string = (function toFontString(font) {
            return !font ||
              isNullOrUndef(font.size) ||
              isNullOrUndef(font.family)
              ? null
              : (font.style ? font.style + ' ' : '') +
                  (font.weight ? font.weight + ' ' : '') +
                  font.size +
                  'px ' +
                  font.family;
          })(font)),
          font
        );
      }
      function resolve(inputs, context, index, info) {
        let i,
          ilen,
          value,
          cacheable = !0;
        for (i = 0, ilen = inputs.length; i < ilen; ++i)
          if (
            ((value = inputs[i]),
            void 0 !== value &&
              (void 0 !== context &&
                'function' == typeof value &&
                ((value = value(context)), (cacheable = !1)),
              void 0 !== index &&
                isArray(value) &&
                ((value = value[index % value.length]), (cacheable = !1)),
              void 0 !== value))
          )
            return info && !cacheable && (info.cacheable = !1), value;
      }
      function createContext(parentContext, context) {
        return Object.assign(Object.create(parentContext), context);
      }
      function _createResolver(
        scopes,
        prefixes = [''],
        rootScopes = scopes,
        fallback,
        getTarget = () => scopes[0]
      ) {
        defined(fallback) || (fallback = _resolve('_fallback', scopes));
        const cache = {
          [Symbol.toStringTag]: 'Object',
          _cacheable: !0,
          _scopes: scopes,
          _rootScopes: rootScopes,
          _fallback: fallback,
          _getTarget: getTarget,
          override: (scope) =>
            _createResolver([scope, ...scopes], prefixes, rootScopes, fallback),
        };
        return new Proxy(cache, {
          deleteProperty: (target, prop) => (
            delete target[prop], delete target._keys, delete scopes[0][prop], !0
          ),
          get: (target, prop) =>
            _cached(target, prop, () =>
              (function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
                let value;
                for (const prefix of prefixes)
                  if (
                    ((value = _resolve(readKey(prefix, prop), scopes)),
                    defined(value))
                  )
                    return needsSubResolver(prop, value)
                      ? createSubResolver(scopes, proxy, prop, value)
                      : value;
              })(prop, prefixes, scopes, target)
            ),
          getOwnPropertyDescriptor: (target, prop) =>
            Reflect.getOwnPropertyDescriptor(target._scopes[0], prop),
          getPrototypeOf: () => Reflect.getPrototypeOf(scopes[0]),
          has: (target, prop) => getKeysFromAllScopes(target).includes(prop),
          ownKeys: (target) => getKeysFromAllScopes(target),
          set(target, prop, value) {
            const storage = target._storage || (target._storage = getTarget());
            return (
              (target[prop] = storage[prop] = value), delete target._keys, !0
            );
          },
        });
      }
      function _attachContext(proxy, context, subProxy, descriptorDefaults) {
        const cache = {
          _cacheable: !1,
          _proxy: proxy,
          _context: context,
          _subProxy: subProxy,
          _stack: new Set(),
          _descriptors: _descriptors(proxy, descriptorDefaults),
          setContext: (ctx) =>
            _attachContext(proxy, ctx, subProxy, descriptorDefaults),
          override: (scope) =>
            _attachContext(
              proxy.override(scope),
              context,
              subProxy,
              descriptorDefaults
            ),
        };
        return new Proxy(cache, {
          deleteProperty: (target, prop) => (
            delete target[prop], delete proxy[prop], !0
          ),
          get: (target, prop, receiver) =>
            _cached(target, prop, () =>
              (function _resolveWithContext(target, prop, receiver) {
                const {
                  _proxy,
                  _context,
                  _subProxy,
                  _descriptors: descriptors,
                } = target;
                let value = _proxy[prop];
                isFunction(value) &&
                  descriptors.isScriptable(prop) &&
                  (value = (function _resolveScriptable(
                    prop,
                    value,
                    target,
                    receiver
                  ) {
                    const { _proxy, _context, _subProxy, _stack } = target;
                    if (_stack.has(prop))
                      throw new Error(
                        'Recursion detected: ' +
                          Array.from(_stack).join('->') +
                          '->' +
                          prop
                      );
                    _stack.add(prop),
                      (value = value(_context, _subProxy || receiver)),
                      _stack.delete(prop),
                      needsSubResolver(prop, value) &&
                        (value = createSubResolver(
                          _proxy._scopes,
                          _proxy,
                          prop,
                          value
                        ));
                    return value;
                  })(prop, value, target, receiver));
                isArray(value) &&
                  value.length &&
                  (value = (function _resolveArray(
                    prop,
                    value,
                    target,
                    isIndexable
                  ) {
                    const {
                      _proxy,
                      _context,
                      _subProxy,
                      _descriptors: descriptors,
                    } = target;
                    if (defined(_context.index) && isIndexable(prop))
                      value = value[_context.index % value.length];
                    else if (isObject(value[0])) {
                      const arr = value,
                        scopes = _proxy._scopes.filter((s) => s !== arr);
                      value = [];
                      for (const item of arr) {
                        const resolver = createSubResolver(
                          scopes,
                          _proxy,
                          prop,
                          item
                        );
                        value.push(
                          _attachContext(
                            resolver,
                            _context,
                            _subProxy && _subProxy[prop],
                            descriptors
                          )
                        );
                      }
                    }
                    return value;
                  })(prop, value, target, descriptors.isIndexable));
                needsSubResolver(prop, value) &&
                  (value = _attachContext(
                    value,
                    _context,
                    _subProxy && _subProxy[prop],
                    descriptors
                  ));
                return value;
              })(target, prop, receiver)
            ),
          getOwnPropertyDescriptor: (target, prop) =>
            target._descriptors.allKeys
              ? Reflect.has(proxy, prop)
                ? { enumerable: !0, configurable: !0 }
                : void 0
              : Reflect.getOwnPropertyDescriptor(proxy, prop),
          getPrototypeOf: () => Reflect.getPrototypeOf(proxy),
          has: (target, prop) => Reflect.has(proxy, prop),
          ownKeys: () => Reflect.ownKeys(proxy),
          set: (target, prop, value) => (
            (proxy[prop] = value), delete target[prop], !0
          ),
        });
      }
      function _descriptors(
        proxy,
        defaults = { scriptable: !0, indexable: !0 }
      ) {
        const {
          _scriptable = defaults.scriptable,
          _indexable = defaults.indexable,
          _allKeys = defaults.allKeys,
        } = proxy;
        return {
          allKeys: _allKeys,
          scriptable: _scriptable,
          indexable: _indexable,
          isScriptable: isFunction(_scriptable)
            ? _scriptable
            : () => _scriptable,
          isIndexable: isFunction(_indexable) ? _indexable : () => _indexable,
        };
      }
      const readKey = (prefix, name) =>
          prefix ? prefix + _capitalize(name) : name,
        needsSubResolver = (prop, value) =>
          isObject(value) &&
          'adapters' !== prop &&
          (null === Object.getPrototypeOf(value) ||
            value.constructor === Object);
      function _cached(target, prop, resolve) {
        if (Object.prototype.hasOwnProperty.call(target, prop))
          return target[prop];
        const value = resolve();
        return (target[prop] = value), value;
      }
      function resolveFallback(fallback, prop, value) {
        return isFunction(fallback) ? fallback(prop, value) : fallback;
      }
      const getScope = (key, parent) =>
        !0 === key
          ? parent
          : 'string' == typeof key
          ? resolveObjectKey(parent, key)
          : void 0;
      function addScopes(set, parentScopes, key, parentFallback, value) {
        for (const parent of parentScopes) {
          const scope = getScope(key, parent);
          if (scope) {
            set.add(scope);
            const fallback = resolveFallback(scope._fallback, key, value);
            if (
              defined(fallback) &&
              fallback !== key &&
              fallback !== parentFallback
            )
              return fallback;
          } else if (
            !1 === scope &&
            defined(parentFallback) &&
            key !== parentFallback
          )
            return null;
        }
        return !1;
      }
      function createSubResolver(parentScopes, resolver, prop, value) {
        const rootScopes = resolver._rootScopes,
          fallback = resolveFallback(resolver._fallback, prop, value),
          allScopes = [...parentScopes, ...rootScopes],
          set = new Set();
        set.add(value);
        let key = addScopesFromKey(
          set,
          allScopes,
          prop,
          fallback || prop,
          value
        );
        return (
          null !== key &&
          (!defined(fallback) ||
            fallback === prop ||
            ((key = addScopesFromKey(set, allScopes, fallback, key, value)),
            null !== key)) &&
          _createResolver(Array.from(set), [''], rootScopes, fallback, () =>
            (function subGetTarget(resolver, prop, value) {
              const parent = resolver._getTarget();
              prop in parent || (parent[prop] = {});
              const target = parent[prop];
              if (isArray(target) && isObject(value)) return value;
              return target || {};
            })(resolver, prop, value)
          )
        );
      }
      function addScopesFromKey(set, allScopes, key, fallback, item) {
        for (; key; ) key = addScopes(set, allScopes, key, fallback, item);
        return key;
      }
      function _resolve(key, scopes) {
        for (const scope of scopes) {
          if (!scope) continue;
          const value = scope[key];
          if (defined(value)) return value;
        }
      }
      function getKeysFromAllScopes(target) {
        let keys = target._keys;
        return (
          keys ||
            (keys = target._keys =
              (function resolveKeysFromAllScopes(scopes) {
                const set = new Set();
                for (const scope of scopes)
                  for (const key of Object.keys(scope).filter(
                    (k) => !k.startsWith('_')
                  ))
                    set.add(key);
                return Array.from(set);
              })(target._scopes)),
          keys
        );
      }
      const EPSILON = Number.EPSILON || 1e-14,
        getPoint = (points, i) =>
          i < points.length && !points[i].skip && points[i],
        getValueAxis = (indexAxis) => ('x' === indexAxis ? 'y' : 'x');
      function splineCurve(firstPoint, middlePoint, afterPoint, t) {
        const previous = firstPoint.skip ? middlePoint : firstPoint,
          current = middlePoint,
          next = afterPoint.skip ? middlePoint : afterPoint,
          d01 = distanceBetweenPoints(current, previous),
          d12 = distanceBetweenPoints(next, current);
        let s01 = d01 / (d01 + d12),
          s12 = d12 / (d01 + d12);
        (s01 = isNaN(s01) ? 0 : s01), (s12 = isNaN(s12) ? 0 : s12);
        const fa = t * s01,
          fb = t * s12;
        return {
          previous: {
            x: current.x - fa * (next.x - previous.x),
            y: current.y - fa * (next.y - previous.y),
          },
          next: {
            x: current.x + fb * (next.x - previous.x),
            y: current.y + fb * (next.y - previous.y),
          },
        };
      }
      function splineCurveMonotone(points, indexAxis = 'x') {
        const valueAxis = getValueAxis(indexAxis),
          pointsLen = points.length,
          deltaK = Array(pointsLen).fill(0),
          mK = Array(pointsLen);
        let i,
          pointBefore,
          pointCurrent,
          pointAfter = getPoint(points, 0);
        for (i = 0; i < pointsLen; ++i)
          if (
            ((pointBefore = pointCurrent),
            (pointCurrent = pointAfter),
            (pointAfter = getPoint(points, i + 1)),
            pointCurrent)
          ) {
            if (pointAfter) {
              const slopeDelta =
                pointAfter[indexAxis] - pointCurrent[indexAxis];
              deltaK[i] =
                0 !== slopeDelta
                  ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) /
                    slopeDelta
                  : 0;
            }
            mK[i] = pointBefore
              ? pointAfter
                ? sign(deltaK[i - 1]) !== sign(deltaK[i])
                  ? 0
                  : (deltaK[i - 1] + deltaK[i]) / 2
                : deltaK[i - 1]
              : deltaK[i];
          }
        !(function monotoneAdjust(points, deltaK, mK) {
          const pointsLen = points.length;
          let alphaK,
            betaK,
            tauK,
            squaredMagnitude,
            pointCurrent,
            pointAfter = getPoint(points, 0);
          for (let i = 0; i < pointsLen - 1; ++i)
            (pointCurrent = pointAfter),
              (pointAfter = getPoint(points, i + 1)),
              pointCurrent &&
                pointAfter &&
                (almostEquals(deltaK[i], 0, EPSILON)
                  ? (mK[i] = mK[i + 1] = 0)
                  : ((alphaK = mK[i] / deltaK[i]),
                    (betaK = mK[i + 1] / deltaK[i]),
                    (squaredMagnitude =
                      Math.pow(alphaK, 2) + Math.pow(betaK, 2)),
                    squaredMagnitude <= 9 ||
                      ((tauK = 3 / Math.sqrt(squaredMagnitude)),
                      (mK[i] = alphaK * tauK * deltaK[i]),
                      (mK[i + 1] = betaK * tauK * deltaK[i]))));
        })(points, deltaK, mK),
          (function monotoneCompute(points, mK, indexAxis = 'x') {
            const valueAxis = getValueAxis(indexAxis),
              pointsLen = points.length;
            let delta,
              pointBefore,
              pointCurrent,
              pointAfter = getPoint(points, 0);
            for (let i = 0; i < pointsLen; ++i) {
              if (
                ((pointBefore = pointCurrent),
                (pointCurrent = pointAfter),
                (pointAfter = getPoint(points, i + 1)),
                !pointCurrent)
              )
                continue;
              const iPixel = pointCurrent[indexAxis],
                vPixel = pointCurrent[valueAxis];
              pointBefore &&
                ((delta = (iPixel - pointBefore[indexAxis]) / 3),
                (pointCurrent[`cp1${indexAxis}`] = iPixel - delta),
                (pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i])),
                pointAfter &&
                  ((delta = (pointAfter[indexAxis] - iPixel) / 3),
                  (pointCurrent[`cp2${indexAxis}`] = iPixel + delta),
                  (pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i]));
            }
          })(points, mK, indexAxis);
      }
      function capControlPoint(pt, min, max) {
        return Math.max(Math.min(pt, max), min);
      }
      function _updateBezierControlPoints(
        points,
        options,
        area,
        loop,
        indexAxis
      ) {
        let i, ilen, point, controlPoints;
        if (
          (options.spanGaps && (points = points.filter((pt) => !pt.skip)),
          'monotone' === options.cubicInterpolationMode)
        )
          splineCurveMonotone(points, indexAxis);
        else {
          let prev = loop ? points[points.length - 1] : points[0];
          for (i = 0, ilen = points.length; i < ilen; ++i)
            (point = points[i]),
              (controlPoints = splineCurve(
                prev,
                point,
                points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],
                options.tension
              )),
              (point.cp1x = controlPoints.previous.x),
              (point.cp1y = controlPoints.previous.y),
              (point.cp2x = controlPoints.next.x),
              (point.cp2y = controlPoints.next.y),
              (prev = point);
        }
        options.capBezierPoints &&
          (function capBezierPoints(points, area) {
            let i,
              ilen,
              point,
              inArea,
              inAreaPrev,
              inAreaNext = _isPointInArea(points[0], area);
            for (i = 0, ilen = points.length; i < ilen; ++i)
              (inAreaPrev = inArea),
                (inArea = inAreaNext),
                (inAreaNext =
                  i < ilen - 1 && _isPointInArea(points[i + 1], area)),
                inArea &&
                  ((point = points[i]),
                  inAreaPrev &&
                    ((point.cp1x = capControlPoint(
                      point.cp1x,
                      area.left,
                      area.right
                    )),
                    (point.cp1y = capControlPoint(
                      point.cp1y,
                      area.top,
                      area.bottom
                    ))),
                  inAreaNext &&
                    ((point.cp2x = capControlPoint(
                      point.cp2x,
                      area.left,
                      area.right
                    )),
                    (point.cp2y = capControlPoint(
                      point.cp2y,
                      area.top,
                      area.bottom
                    ))));
          })(points, area);
      }
      function _isDomSupported() {
        return 'undefined' != typeof window && 'undefined' != typeof document;
      }
      function _getParentNode(domNode) {
        let parent = domNode.parentNode;
        return (
          parent &&
            '[object ShadowRoot]' === parent.toString() &&
            (parent = parent.host),
          parent
        );
      }
      function parseMaxStyle(styleValue, node, parentProperty) {
        let valueInPixels;
        return (
          'string' == typeof styleValue
            ? ((valueInPixels = parseInt(styleValue, 10)),
              -1 !== styleValue.indexOf('%') &&
                (valueInPixels =
                  (valueInPixels / 100) * node.parentNode[parentProperty]))
            : (valueInPixels = styleValue),
          valueInPixels
        );
      }
      const getComputedStyle = (element) =>
        element.ownerDocument.defaultView.getComputedStyle(element, null);
      const positions = ['top', 'right', 'bottom', 'left'];
      function getPositionedStyle(styles, style, suffix) {
        const result = {};
        suffix = suffix ? '-' + suffix : '';
        for (let i = 0; i < 4; i++) {
          const pos = positions[i];
          result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;
        }
        return (
          (result.width = result.left + result.right),
          (result.height = result.top + result.bottom),
          result
        );
      }
      const useOffsetPos = (x, y, target) =>
        (x > 0 || y > 0) && (!target || !target.shadowRoot);
      function getRelativePosition(event, chart) {
        if ('native' in event) return event;
        const { canvas, currentDevicePixelRatio } = chart,
          style = getComputedStyle(canvas),
          borderBox = 'border-box' === style.boxSizing,
          paddings = getPositionedStyle(style, 'padding'),
          borders = getPositionedStyle(style, 'border', 'width'),
          { x, y, box } = (function getCanvasPosition(e, canvas) {
            const touches = e.touches,
              source = touches && touches.length ? touches[0] : e,
              { offsetX, offsetY } = source;
            let x,
              y,
              box = !1;
            if (useOffsetPos(offsetX, offsetY, e.target))
              (x = offsetX), (y = offsetY);
            else {
              const rect = canvas.getBoundingClientRect();
              (x = source.clientX - rect.left),
                (y = source.clientY - rect.top),
                (box = !0);
            }
            return { x, y, box };
          })(event, canvas),
          xOffset = paddings.left + (box && borders.left),
          yOffset = paddings.top + (box && borders.top);
        let { width, height } = chart;
        return (
          borderBox &&
            ((width -= paddings.width + borders.width),
            (height -= paddings.height + borders.height)),
          {
            x: Math.round(
              (((x - xOffset) / width) * canvas.width) / currentDevicePixelRatio
            ),
            y: Math.round(
              (((y - yOffset) / height) * canvas.height) /
                currentDevicePixelRatio
            ),
          }
        );
      }
      const round1 = (v) => Math.round(10 * v) / 10;
      function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
        const style = getComputedStyle(canvas),
          margins = getPositionedStyle(style, 'margin'),
          maxWidth =
            parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY,
          maxHeight =
            parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY,
          containerSize = (function getContainerSize(canvas, width, height) {
            let maxWidth, maxHeight;
            if (void 0 === width || void 0 === height) {
              const container = _getParentNode(canvas);
              if (container) {
                const rect = container.getBoundingClientRect(),
                  containerStyle = getComputedStyle(container),
                  containerBorder = getPositionedStyle(
                    containerStyle,
                    'border',
                    'width'
                  ),
                  containerPadding = getPositionedStyle(
                    containerStyle,
                    'padding'
                  );
                (width =
                  rect.width - containerPadding.width - containerBorder.width),
                  (height =
                    rect.height -
                    containerPadding.height -
                    containerBorder.height),
                  (maxWidth = parseMaxStyle(
                    containerStyle.maxWidth,
                    container,
                    'clientWidth'
                  )),
                  (maxHeight = parseMaxStyle(
                    containerStyle.maxHeight,
                    container,
                    'clientHeight'
                  ));
              } else
                (width = canvas.clientWidth), (height = canvas.clientHeight);
            }
            return {
              width,
              height,
              maxWidth: maxWidth || INFINITY,
              maxHeight: maxHeight || INFINITY,
            };
          })(canvas, bbWidth, bbHeight);
        let { width, height } = containerSize;
        if ('content-box' === style.boxSizing) {
          const borders = getPositionedStyle(style, 'border', 'width'),
            paddings = getPositionedStyle(style, 'padding');
          (width -= paddings.width + borders.width),
            (height -= paddings.height + borders.height);
        }
        (width = Math.max(0, width - margins.width)),
          (height = Math.max(
            0,
            aspectRatio ? width / aspectRatio : height - margins.height
          )),
          (width = round1(Math.min(width, maxWidth, containerSize.maxWidth))),
          (height = round1(
            Math.min(height, maxHeight, containerSize.maxHeight)
          )),
          width && !height && (height = round1(width / 2));
        return (
          (void 0 !== bbWidth || void 0 !== bbHeight) &&
            aspectRatio &&
            containerSize.height &&
            height > containerSize.height &&
            ((height = containerSize.height),
            (width = round1(Math.floor(height * aspectRatio)))),
          { width, height }
        );
      }
      function retinaScale(chart, forceRatio, forceStyle) {
        const pixelRatio = forceRatio || 1,
          deviceHeight = Math.floor(chart.height * pixelRatio),
          deviceWidth = Math.floor(chart.width * pixelRatio);
        (chart.height = Math.floor(chart.height)),
          (chart.width = Math.floor(chart.width));
        const canvas = chart.canvas;
        return (
          canvas.style &&
            (forceStyle || (!canvas.style.height && !canvas.style.width)) &&
            ((canvas.style.height = `${chart.height}px`),
            (canvas.style.width = `${chart.width}px`)),
          (chart.currentDevicePixelRatio !== pixelRatio ||
            canvas.height !== deviceHeight ||
            canvas.width !== deviceWidth) &&
            ((chart.currentDevicePixelRatio = pixelRatio),
            (canvas.height = deviceHeight),
            (canvas.width = deviceWidth),
            chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0),
            !0)
        );
      }
      const supportsEventListenerOptions = (function () {
        let passiveSupported = !1;
        try {
          const options = {
            get passive() {
              return (passiveSupported = !0), !1;
            },
          };
          window.addEventListener('test', null, options),
            window.removeEventListener('test', null, options);
        } catch (e) {}
        return passiveSupported;
      })();
      function readUsedSize(element, property) {
        const value = (function getStyle(el, property) {
            return getComputedStyle(el).getPropertyValue(property);
          })(element, property),
          matches = value && value.match(/^(\d+)(\.\d+)?px$/);
        return matches ? +matches[1] : void 0;
      }
      function _pointInLine(p1, p2, t, mode) {
        return { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
      }
      function _steppedInterpolation(p1, p2, t, mode) {
        return {
          x: p1.x + t * (p2.x - p1.x),
          y:
            'middle' === mode
              ? t < 0.5
                ? p1.y
                : p2.y
              : 'after' === mode
              ? t < 1
                ? p1.y
                : p2.y
              : t > 0
              ? p2.y
              : p1.y,
        };
      }
      function _bezierInterpolation(p1, p2, t, mode) {
        const cp1 = { x: p1.cp2x, y: p1.cp2y },
          cp2 = { x: p2.cp1x, y: p2.cp1y },
          a = _pointInLine(p1, cp1, t),
          b = _pointInLine(cp1, cp2, t),
          c = _pointInLine(cp2, p2, t),
          d = _pointInLine(a, b, t),
          e = _pointInLine(b, c, t);
        return _pointInLine(d, e, t);
      }
      const getRightToLeftAdapter = function (rectX, width) {
          return {
            x: (x) => rectX + rectX + width - x,
            setWidth(w) {
              width = w;
            },
            textAlign: (align) =>
              'center' === align ? align : 'right' === align ? 'left' : 'right',
            xPlus: (x, value) => x - value,
            leftForLtr: (x, itemWidth) => x - itemWidth,
          };
        },
        getLeftToRightAdapter = function () {
          return {
            x: (x) => x,
            setWidth(w) {},
            textAlign: (align) => align,
            xPlus: (x, value) => x + value,
            leftForLtr: (x, _itemWidth) => x,
          };
        };
      function getRtlAdapter(rtl, rectX, width) {
        return rtl
          ? getRightToLeftAdapter(rectX, width)
          : getLeftToRightAdapter();
      }
      function overrideTextDirection(ctx, direction) {
        let style, original;
        ('ltr' !== direction && 'rtl' !== direction) ||
          ((style = ctx.canvas.style),
          (original = [
            style.getPropertyValue('direction'),
            style.getPropertyPriority('direction'),
          ]),
          style.setProperty('direction', direction, 'important'),
          (ctx.prevTextDirection = original));
      }
      function restoreTextDirection(ctx, original) {
        void 0 !== original &&
          (delete ctx.prevTextDirection,
          ctx.canvas.style.setProperty('direction', original[0], original[1]));
      }
      function propertyFn(property) {
        return 'angle' === property
          ? {
              between: _angleBetween,
              compare: _angleDiff,
              normalize: _normalizeAngle,
            }
          : {
              between: _isBetween,
              compare: (a, b) => a - b,
              normalize: (x) => x,
            };
      }
      function normalizeSegment({ start, end, count, loop, style }) {
        return {
          start: start % count,
          end: end % count,
          loop: loop && (end - start + 1) % count == 0,
          style,
        };
      }
      function _boundSegment(segment, points, bounds) {
        if (!bounds) return [segment];
        const { property, start: startBound, end: endBound } = bounds,
          count = points.length,
          { compare, between, normalize } = propertyFn(property),
          { start, end, loop, style } = (function getSegment(
            segment,
            points,
            bounds
          ) {
            const { property, start: startBound, end: endBound } = bounds,
              { between, normalize } = propertyFn(property),
              count = points.length;
            let i,
              ilen,
              { start, end, loop } = segment;
            if (loop) {
              for (
                start += count, end += count, i = 0, ilen = count;
                i < ilen &&
                between(
                  normalize(points[start % count][property]),
                  startBound,
                  endBound
                );
                ++i
              )
                start--, end--;
              (start %= count), (end %= count);
            }
            return (
              end < start && (end += count),
              { start, end, loop, style: segment.style }
            );
          })(segment, points, bounds),
          result = [];
        let value,
          point,
          prevValue,
          inside = !1,
          subStart = null;
        const shouldStart = () =>
            inside ||
            (between(startBound, prevValue, value) &&
              0 !== compare(startBound, prevValue)),
          shouldStop = () =>
            !inside ||
            0 === compare(endBound, value) ||
            between(endBound, prevValue, value);
        for (let i = start, prev = start; i <= end; ++i)
          (point = points[i % count]),
            point.skip ||
              ((value = normalize(point[property])),
              value !== prevValue &&
                ((inside = between(value, startBound, endBound)),
                null === subStart &&
                  shouldStart() &&
                  (subStart = 0 === compare(value, startBound) ? i : prev),
                null !== subStart &&
                  shouldStop() &&
                  (result.push(
                    normalizeSegment({
                      start: subStart,
                      end: i,
                      loop,
                      count,
                      style,
                    })
                  ),
                  (subStart = null)),
                (prev = i),
                (prevValue = value)));
        return (
          null !== subStart &&
            result.push(
              normalizeSegment({ start: subStart, end, loop, count, style })
            ),
          result
        );
      }
      function _boundSegments(line, bounds) {
        const result = [],
          segments = line.segments;
        for (let i = 0; i < segments.length; i++) {
          const sub = _boundSegment(segments[i], line.points, bounds);
          sub.length && result.push(...sub);
        }
        return result;
      }
      function splitByStyles(line, segments, points, segmentOptions) {
        return segmentOptions && segmentOptions.setContext && points
          ? (function doSplitByStyles(line, segments, points, segmentOptions) {
              const chartContext = line._chart.getContext(),
                baseStyle = readStyle(line.options),
                {
                  _datasetIndex: datasetIndex,
                  options: { spanGaps },
                } = line,
                count = points.length,
                result = [];
              let prevStyle = baseStyle,
                start = segments[0].start,
                i = start;
              function addStyle(s, e, l, st) {
                const dir = spanGaps ? -1 : 1;
                if (s !== e) {
                  for (s += count; points[s % count].skip; ) s -= dir;
                  for (; points[e % count].skip; ) e += dir;
                  s % count != e % count &&
                    (result.push({
                      start: s % count,
                      end: e % count,
                      loop: l,
                      style: st,
                    }),
                    (prevStyle = st),
                    (start = e % count));
                }
              }
              for (const segment of segments) {
                start = spanGaps ? start : segment.start;
                let style,
                  prev = points[start % count];
                for (i = start + 1; i <= segment.end; i++) {
                  const pt = points[i % count];
                  (style = readStyle(
                    segmentOptions.setContext(
                      createContext(chartContext, {
                        type: 'segment',
                        p0: prev,
                        p1: pt,
                        p0DataIndex: (i - 1) % count,
                        p1DataIndex: i % count,
                        datasetIndex,
                      })
                    )
                  )),
                    styleChanged(style, prevStyle) &&
                      addStyle(start, i - 1, segment.loop, prevStyle),
                    (prev = pt),
                    (prevStyle = style);
                }
                start < i - 1 &&
                  addStyle(start, i - 1, segment.loop, prevStyle);
              }
              return result;
            })(line, segments, points, segmentOptions)
          : segments;
      }
      function readStyle(options) {
        return {
          backgroundColor: options.backgroundColor,
          borderCapStyle: options.borderCapStyle,
          borderDash: options.borderDash,
          borderDashOffset: options.borderDashOffset,
          borderJoinStyle: options.borderJoinStyle,
          borderWidth: options.borderWidth,
          borderColor: options.borderColor,
        };
      }
      function styleChanged(style, prevStyle) {
        return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
      }
      class Animator {
        constructor() {
          (this._request = null),
            (this._charts = new Map()),
            (this._running = !1),
            (this._lastDate = void 0);
        }
        _notify(chart, anims, date, type) {
          const callbacks = anims.listeners[type],
            numSteps = anims.duration;
          callbacks.forEach((fn) =>
            fn({
              chart,
              initial: anims.initial,
              numSteps,
              currentStep: Math.min(date - anims.start, numSteps),
            })
          );
        }
        _refresh() {
          this._request ||
            ((this._running = !0),
            (this._request = requestAnimFrame.call(window, () => {
              this._update(),
                (this._request = null),
                this._running && this._refresh();
            })));
        }
        _update(date = Date.now()) {
          let remaining = 0;
          this._charts.forEach((anims, chart) => {
            if (!anims.running || !anims.items.length) return;
            const items = anims.items;
            let item,
              i = items.length - 1,
              draw = !1;
            for (; i >= 0; --i)
              (item = items[i]),
                item._active
                  ? (item._total > anims.duration &&
                      (anims.duration = item._total),
                    item.tick(date),
                    (draw = !0))
                  : ((items[i] = items[items.length - 1]), items.pop());
            draw &&
              (chart.draw(), this._notify(chart, anims, date, 'progress')),
              items.length ||
                ((anims.running = !1),
                this._notify(chart, anims, date, 'complete'),
                (anims.initial = !1)),
              (remaining += items.length);
          }),
            (this._lastDate = date),
            0 === remaining && (this._running = !1);
        }
        _getAnims(chart) {
          const charts = this._charts;
          let anims = charts.get(chart);
          return (
            anims ||
              ((anims = {
                running: !1,
                initial: !0,
                items: [],
                listeners: { complete: [], progress: [] },
              }),
              charts.set(chart, anims)),
            anims
          );
        }
        listen(chart, event, cb) {
          this._getAnims(chart).listeners[event].push(cb);
        }
        add(chart, items) {
          items && items.length && this._getAnims(chart).items.push(...items);
        }
        has(chart) {
          return this._getAnims(chart).items.length > 0;
        }
        start(chart) {
          const anims = this._charts.get(chart);
          anims &&
            ((anims.running = !0),
            (anims.start = Date.now()),
            (anims.duration = anims.items.reduce(
              (acc, cur) => Math.max(acc, cur._duration),
              0
            )),
            this._refresh());
        }
        running(chart) {
          if (!this._running) return !1;
          const anims = this._charts.get(chart);
          return !!(anims && anims.running && anims.items.length);
        }
        stop(chart) {
          const anims = this._charts.get(chart);
          if (!anims || !anims.items.length) return;
          const items = anims.items;
          let i = items.length - 1;
          for (; i >= 0; --i) items[i].cancel();
          (anims.items = []),
            this._notify(chart, anims, Date.now(), 'complete');
        }
        remove(chart) {
          return this._charts.delete(chart);
        }
      }
      var animator = new Animator();
      const interpolators = {
        boolean: (from, to, factor) => (factor > 0.5 ? to : from),
        color(from, to, factor) {
          const c0 = color(from || 'transparent'),
            c1 = c0.valid && color(to || 'transparent');
          return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;
        },
        number: (from, to, factor) => from + (to - from) * factor,
      };
      class Animation {
        constructor(cfg, target, prop, to) {
          const currentValue = target[prop];
          to = resolve([cfg.to, to, currentValue, cfg.from]);
          const from = resolve([cfg.from, currentValue, to]);
          (this._active = !0),
            (this._fn = cfg.fn || interpolators[cfg.type || typeof from]),
            (this._easing = effects[cfg.easing] || effects.linear),
            (this._start = Math.floor(Date.now() + (cfg.delay || 0))),
            (this._duration = this._total = Math.floor(cfg.duration)),
            (this._loop = !!cfg.loop),
            (this._target = target),
            (this._prop = prop),
            (this._from = from),
            (this._to = to),
            (this._promises = void 0);
        }
        active() {
          return this._active;
        }
        update(cfg, to, date) {
          if (this._active) {
            this._notify(!1);
            const currentValue = this._target[this._prop],
              elapsed = date - this._start,
              remain = this._duration - elapsed;
            (this._start = date),
              (this._duration = Math.floor(Math.max(remain, cfg.duration))),
              (this._total += elapsed),
              (this._loop = !!cfg.loop),
              (this._to = resolve([cfg.to, to, currentValue, cfg.from])),
              (this._from = resolve([cfg.from, currentValue, to]));
          }
        }
        cancel() {
          this._active &&
            (this.tick(Date.now()), (this._active = !1), this._notify(!1));
        }
        tick(date) {
          const elapsed = date - this._start,
            duration = this._duration,
            prop = this._prop,
            from = this._from,
            loop = this._loop,
            to = this._to;
          let factor;
          if (
            ((this._active = from !== to && (loop || elapsed < duration)),
            !this._active)
          )
            return (this._target[prop] = to), void this._notify(!0);
          elapsed < 0
            ? (this._target[prop] = from)
            : ((factor = (elapsed / duration) % 2),
              (factor = loop && factor > 1 ? 2 - factor : factor),
              (factor = this._easing(Math.min(1, Math.max(0, factor)))),
              (this._target[prop] = this._fn(from, to, factor)));
        }
        wait() {
          const promises = this._promises || (this._promises = []);
          return new Promise((res, rej) => {
            promises.push({ res, rej });
          });
        }
        _notify(resolved) {
          const method = resolved ? 'res' : 'rej',
            promises = this._promises || [];
          for (let i = 0; i < promises.length; i++) promises[i][method]();
        }
      }
      class Animations {
        constructor(chart, config) {
          (this._chart = chart),
            (this._properties = new Map()),
            this.configure(config);
        }
        configure(config) {
          if (!isObject(config)) return;
          const animationOptions = Object.keys(defaults.animation),
            animatedProps = this._properties;
          Object.getOwnPropertyNames(config).forEach((key) => {
            const cfg = config[key];
            if (!isObject(cfg)) return;
            const resolved = {};
            for (const option of animationOptions)
              resolved[option] = cfg[option];
            ((isArray(cfg.properties) && cfg.properties) || [key]).forEach(
              (prop) => {
                (prop !== key && animatedProps.has(prop)) ||
                  animatedProps.set(prop, resolved);
              }
            );
          });
        }
        _animateOptions(target, values) {
          const newOptions = values.options,
            options = (function resolveTargetOptions(target, newOptions) {
              if (!newOptions) return;
              let options = target.options;
              if (!options) return void (target.options = newOptions);
              options.$shared &&
                (target.options = options =
                  Object.assign({}, options, { $shared: !1, $animations: {} }));
              return options;
            })(target, newOptions);
          if (!options) return [];
          const animations = this._createAnimations(options, newOptions);
          return (
            newOptions.$shared &&
              (function awaitAll(animations, properties) {
                const running = [],
                  keys = Object.keys(properties);
                for (let i = 0; i < keys.length; i++) {
                  const anim = animations[keys[i]];
                  anim && anim.active() && running.push(anim.wait());
                }
                return Promise.all(running);
              })(target.options.$animations, newOptions).then(
                () => {
                  target.options = newOptions;
                },
                () => {}
              ),
            animations
          );
        }
        _createAnimations(target, values) {
          const animatedProps = this._properties,
            animations = [],
            running = target.$animations || (target.$animations = {}),
            props = Object.keys(values),
            date = Date.now();
          let i;
          for (i = props.length - 1; i >= 0; --i) {
            const prop = props[i];
            if ('$' === prop.charAt(0)) continue;
            if ('options' === prop) {
              animations.push(...this._animateOptions(target, values));
              continue;
            }
            const value = values[prop];
            let animation = running[prop];
            const cfg = animatedProps.get(prop);
            if (animation) {
              if (cfg && animation.active()) {
                animation.update(cfg, value, date);
                continue;
              }
              animation.cancel();
            }
            cfg && cfg.duration
              ? ((running[prop] = animation =
                  new Animation(cfg, target, prop, value)),
                animations.push(animation))
              : (target[prop] = value);
          }
          return animations;
        }
        update(target, values) {
          if (0 === this._properties.size)
            return void Object.assign(target, values);
          const animations = this._createAnimations(target, values);
          return animations.length
            ? (animator.add(this._chart, animations), !0)
            : void 0;
        }
      }
      function scaleClip(scale, allowedOverflow) {
        const opts = (scale && scale.options) || {},
          reverse = opts.reverse,
          min = void 0 === opts.min ? allowedOverflow : 0,
          max = void 0 === opts.max ? allowedOverflow : 0;
        return { start: reverse ? max : min, end: reverse ? min : max };
      }
      function getSortedDatasetIndices(chart, filterVisible) {
        const keys = [],
          metasets = chart._getSortedDatasetMetas(filterVisible);
        let i, ilen;
        for (i = 0, ilen = metasets.length; i < ilen; ++i)
          keys.push(metasets[i].index);
        return keys;
      }
      function applyStack(stack, value, dsIndex, options = {}) {
        const keys = stack.keys,
          singleMode = 'single' === options.mode;
        let i, ilen, datasetIndex, otherValue;
        if (null !== value) {
          for (i = 0, ilen = keys.length; i < ilen; ++i) {
            if (((datasetIndex = +keys[i]), datasetIndex === dsIndex)) {
              if (options.all) continue;
              break;
            }
            (otherValue = stack.values[datasetIndex]),
              isNumberFinite(otherValue) &&
                (singleMode ||
                  0 === value ||
                  sign(value) === sign(otherValue)) &&
                (value += otherValue);
          }
          return value;
        }
      }
      function isStacked(scale, meta) {
        const stacked = scale && scale.options.stacked;
        return stacked || (void 0 === stacked && void 0 !== meta.stack);
      }
      function getOrCreateStack(stacks, stackKey, indexValue) {
        const subStack = stacks[stackKey] || (stacks[stackKey] = {});
        return subStack[indexValue] || (subStack[indexValue] = {});
      }
      function getLastIndexInStack(stack, vScale, positive, type) {
        for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
          const value = stack[meta.index];
          if ((positive && value > 0) || (!positive && value < 0))
            return meta.index;
        }
        return null;
      }
      function updateStacks(controller, parsed) {
        const { chart, _cachedMeta: meta } = controller,
          stacks = chart._stacks || (chart._stacks = {}),
          { iScale, vScale, index: datasetIndex } = meta,
          iAxis = iScale.axis,
          vAxis = vScale.axis,
          key = (function getStackKey(indexScale, valueScale, meta) {
            return `${indexScale.id}.${valueScale.id}.${
              meta.stack || meta.type
            }`;
          })(iScale, vScale, meta),
          ilen = parsed.length;
        let stack;
        for (let i = 0; i < ilen; ++i) {
          const item = parsed[i],
            { [iAxis]: index, [vAxis]: value } = item;
          (stack = (item._stacks || (item._stacks = {}))[vAxis] =
            getOrCreateStack(stacks, key, index)),
            (stack[datasetIndex] = value),
            (stack._top = getLastIndexInStack(stack, vScale, !0, meta.type)),
            (stack._bottom = getLastIndexInStack(stack, vScale, !1, meta.type));
          (stack._visualValues || (stack._visualValues = {}))[datasetIndex] =
            value;
        }
      }
      function getFirstScaleId(chart, axis) {
        const scales = chart.scales;
        return Object.keys(scales)
          .filter((key) => scales[key].axis === axis)
          .shift();
      }
      function clearStacks(meta, items) {
        const datasetIndex = meta.controller.index,
          axis = meta.vScale && meta.vScale.axis;
        if (axis) {
          items = items || meta._parsed;
          for (const parsed of items) {
            const stacks = parsed._stacks;
            if (
              !stacks ||
              void 0 === stacks[axis] ||
              void 0 === stacks[axis][datasetIndex]
            )
              return;
            delete stacks[axis][datasetIndex],
              void 0 !== stacks[axis]._visualValues &&
                void 0 !== stacks[axis]._visualValues[datasetIndex] &&
                delete stacks[axis]._visualValues[datasetIndex];
          }
        }
      }
      const isDirectUpdateMode = (mode) => 'reset' === mode || 'none' === mode,
        cloneIfNotShared = (cached, shared) =>
          shared ? cached : Object.assign({}, cached);
      class DatasetController {
        static defaults = {};
        static datasetElementType = null;
        static dataElementType = null;
        constructor(chart, datasetIndex) {
          (this.chart = chart),
            (this._ctx = chart.ctx),
            (this.index = datasetIndex),
            (this._cachedDataOpts = {}),
            (this._cachedMeta = this.getMeta()),
            (this._type = this._cachedMeta.type),
            (this.options = void 0),
            (this._parsing = !1),
            (this._data = void 0),
            (this._objectData = void 0),
            (this._sharedOptions = void 0),
            (this._drawStart = void 0),
            (this._drawCount = void 0),
            (this.enableOptionSharing = !1),
            (this.supportsDecimation = !1),
            (this.$context = void 0),
            (this._syncList = []),
            (this.datasetElementType = new.target.datasetElementType),
            (this.dataElementType = new.target.dataElementType),
            this.initialize();
        }
        initialize() {
          const meta = this._cachedMeta;
          this.configure(),
            this.linkScales(),
            (meta._stacked = isStacked(meta.vScale, meta)),
            this.addElements(),
            this.options.fill &&
              !this.chart.isPluginEnabled('filler') &&
              console.warn(
                "Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options"
              );
        }
        updateIndex(datasetIndex) {
          this.index !== datasetIndex && clearStacks(this._cachedMeta),
            (this.index = datasetIndex);
        }
        linkScales() {
          const chart = this.chart,
            meta = this._cachedMeta,
            dataset = this.getDataset(),
            chooseId = (axis, x, y, r) =>
              'x' === axis ? x : 'r' === axis ? r : y,
            xid = (meta.xAxisID = valueOrDefault(
              dataset.xAxisID,
              getFirstScaleId(chart, 'x')
            )),
            yid = (meta.yAxisID = valueOrDefault(
              dataset.yAxisID,
              getFirstScaleId(chart, 'y')
            )),
            rid = (meta.rAxisID = valueOrDefault(
              dataset.rAxisID,
              getFirstScaleId(chart, 'r')
            )),
            indexAxis = meta.indexAxis,
            iid = (meta.iAxisID = chooseId(indexAxis, xid, yid, rid)),
            vid = (meta.vAxisID = chooseId(indexAxis, yid, xid, rid));
          (meta.xScale = this.getScaleForId(xid)),
            (meta.yScale = this.getScaleForId(yid)),
            (meta.rScale = this.getScaleForId(rid)),
            (meta.iScale = this.getScaleForId(iid)),
            (meta.vScale = this.getScaleForId(vid));
        }
        getDataset() {
          return this.chart.data.datasets[this.index];
        }
        getMeta() {
          return this.chart.getDatasetMeta(this.index);
        }
        getScaleForId(scaleID) {
          return this.chart.scales[scaleID];
        }
        _getOtherScale(scale) {
          const meta = this._cachedMeta;
          return scale === meta.iScale ? meta.vScale : meta.iScale;
        }
        reset() {
          this._update('reset');
        }
        _destroy() {
          const meta = this._cachedMeta;
          this._data && unlistenArrayEvents(this._data, this),
            meta._stacked && clearStacks(meta);
        }
        _dataCheck() {
          const dataset = this.getDataset(),
            data = dataset.data || (dataset.data = []),
            _data = this._data;
          if (isObject(data))
            this._data = (function convertObjectDataToArray(data) {
              const keys = Object.keys(data),
                adata = new Array(keys.length);
              let i, ilen, key;
              for (i = 0, ilen = keys.length; i < ilen; ++i)
                (key = keys[i]), (adata[i] = { x: key, y: data[key] });
              return adata;
            })(data);
          else if (_data !== data) {
            if (_data) {
              unlistenArrayEvents(_data, this);
              const meta = this._cachedMeta;
              clearStacks(meta), (meta._parsed = []);
            }
            data &&
              Object.isExtensible(data) &&
              (function listenArrayEvents(array, listener) {
                array._chartjs
                  ? array._chartjs.listeners.push(listener)
                  : (Object.defineProperty(array, '_chartjs', {
                      configurable: !0,
                      enumerable: !1,
                      value: { listeners: [listener] },
                    }),
                    arrayEvents.forEach((key) => {
                      const method = '_onData' + _capitalize(key),
                        base = array[key];
                      Object.defineProperty(array, key, {
                        configurable: !0,
                        enumerable: !1,
                        value(...args) {
                          const res = base.apply(this, args);
                          return (
                            array._chartjs.listeners.forEach((object) => {
                              'function' == typeof object[method] &&
                                object[method](...args);
                            }),
                            res
                          );
                        },
                      });
                    }));
              })(data, this),
              (this._syncList = []),
              (this._data = data);
          }
        }
        addElements() {
          const meta = this._cachedMeta;
          this._dataCheck(),
            this.datasetElementType &&
              (meta.dataset = new this.datasetElementType());
        }
        buildOrUpdateElements(resetNewElements) {
          const meta = this._cachedMeta,
            dataset = this.getDataset();
          let stackChanged = !1;
          this._dataCheck();
          const oldStacked = meta._stacked;
          (meta._stacked = isStacked(meta.vScale, meta)),
            meta.stack !== dataset.stack &&
              ((stackChanged = !0),
              clearStacks(meta),
              (meta.stack = dataset.stack)),
            this._resyncElements(resetNewElements),
            (stackChanged || oldStacked !== meta._stacked) &&
              updateStacks(this, meta._parsed);
        }
        configure() {
          const config = this.chart.config,
            scopeKeys = config.datasetScopeKeys(this._type),
            scopes = config.getOptionScopes(this.getDataset(), scopeKeys, !0);
          (this.options = config.createResolver(scopes, this.getContext())),
            (this._parsing = this.options.parsing),
            (this._cachedDataOpts = {});
        }
        parse(start, count) {
          const { _cachedMeta: meta, _data: data } = this,
            { iScale, _stacked } = meta,
            iAxis = iScale.axis;
          let i,
            cur,
            parsed,
            sorted = (0 === start && count === data.length) || meta._sorted,
            prev = start > 0 && meta._parsed[start - 1];
          if (!1 === this._parsing)
            (meta._parsed = data), (meta._sorted = !0), (parsed = data);
          else {
            parsed = isArray(data[start])
              ? this.parseArrayData(meta, data, start, count)
              : isObject(data[start])
              ? this.parseObjectData(meta, data, start, count)
              : this.parsePrimitiveData(meta, data, start, count);
            const isNotInOrderComparedToPrev = () =>
              null === cur[iAxis] || (prev && cur[iAxis] < prev[iAxis]);
            for (i = 0; i < count; ++i)
              (meta._parsed[i + start] = cur = parsed[i]),
                sorted &&
                  (isNotInOrderComparedToPrev() && (sorted = !1), (prev = cur));
            meta._sorted = sorted;
          }
          _stacked && updateStacks(this, parsed);
        }
        parsePrimitiveData(meta, data, start, count) {
          const { iScale, vScale } = meta,
            iAxis = iScale.axis,
            vAxis = vScale.axis,
            labels = iScale.getLabels(),
            singleScale = iScale === vScale,
            parsed = new Array(count);
          let i, ilen, index;
          for (i = 0, ilen = count; i < ilen; ++i)
            (index = i + start),
              (parsed[i] = {
                [iAxis]: singleScale || iScale.parse(labels[index], index),
                [vAxis]: vScale.parse(data[index], index),
              });
          return parsed;
        }
        parseArrayData(meta, data, start, count) {
          const { xScale, yScale } = meta,
            parsed = new Array(count);
          let i, ilen, index, item;
          for (i = 0, ilen = count; i < ilen; ++i)
            (index = i + start),
              (item = data[index]),
              (parsed[i] = {
                x: xScale.parse(item[0], index),
                y: yScale.parse(item[1], index),
              });
          return parsed;
        }
        parseObjectData(meta, data, start, count) {
          const { xScale, yScale } = meta,
            { xAxisKey = 'x', yAxisKey = 'y' } = this._parsing,
            parsed = new Array(count);
          let i, ilen, index, item;
          for (i = 0, ilen = count; i < ilen; ++i)
            (index = i + start),
              (item = data[index]),
              (parsed[i] = {
                x: xScale.parse(resolveObjectKey(item, xAxisKey), index),
                y: yScale.parse(resolveObjectKey(item, yAxisKey), index),
              });
          return parsed;
        }
        getParsed(index) {
          return this._cachedMeta._parsed[index];
        }
        getDataElement(index) {
          return this._cachedMeta.data[index];
        }
        applyStack(scale, parsed, mode) {
          const chart = this.chart,
            meta = this._cachedMeta,
            value = parsed[scale.axis];
          return applyStack(
            {
              keys: getSortedDatasetIndices(chart, !0),
              values: parsed._stacks[scale.axis]._visualValues,
            },
            value,
            meta.index,
            { mode }
          );
        }
        updateRangeFromParsed(range, scale, parsed, stack) {
          const parsedValue = parsed[scale.axis];
          let value = null === parsedValue ? NaN : parsedValue;
          const values = stack && parsed._stacks[scale.axis];
          stack &&
            values &&
            ((stack.values = values),
            (value = applyStack(stack, parsedValue, this._cachedMeta.index))),
            (range.min = Math.min(range.min, value)),
            (range.max = Math.max(range.max, value));
        }
        getMinMax(scale, canStack) {
          const meta = this._cachedMeta,
            _parsed = meta._parsed,
            sorted = meta._sorted && scale === meta.iScale,
            ilen = _parsed.length,
            otherScale = this._getOtherScale(scale),
            stack = ((canStack, meta, chart) =>
              canStack &&
              !meta.hidden &&
              meta._stacked && {
                keys: getSortedDatasetIndices(chart, !0),
                values: null,
              })(canStack, meta, this.chart),
            range = {
              min: Number.POSITIVE_INFINITY,
              max: Number.NEGATIVE_INFINITY,
            },
            { min: otherMin, max: otherMax } = (function getUserBounds(scale) {
              const { min, max, minDefined, maxDefined } =
                scale.getUserBounds();
              return {
                min: minDefined ? min : Number.NEGATIVE_INFINITY,
                max: maxDefined ? max : Number.POSITIVE_INFINITY,
              };
            })(otherScale);
          let i, parsed;
          function _skip() {
            parsed = _parsed[i];
            const otherValue = parsed[otherScale.axis];
            return (
              !isNumberFinite(parsed[scale.axis]) ||
              otherMin > otherValue ||
              otherMax < otherValue
            );
          }
          for (
            i = 0;
            i < ilen &&
            (_skip() ||
              (this.updateRangeFromParsed(range, scale, parsed, stack),
              !sorted));
            ++i
          );
          if (sorted)
            for (i = ilen - 1; i >= 0; --i)
              if (!_skip()) {
                this.updateRangeFromParsed(range, scale, parsed, stack);
                break;
              }
          return range;
        }
        getAllParsedValues(scale) {
          const parsed = this._cachedMeta._parsed,
            values = [];
          let i, ilen, value;
          for (i = 0, ilen = parsed.length; i < ilen; ++i)
            (value = parsed[i][scale.axis]),
              isNumberFinite(value) && values.push(value);
          return values;
        }
        getMaxOverflow() {
          return !1;
        }
        getLabelAndValue(index) {
          const meta = this._cachedMeta,
            iScale = meta.iScale,
            vScale = meta.vScale,
            parsed = this.getParsed(index);
          return {
            label: iScale
              ? '' + iScale.getLabelForValue(parsed[iScale.axis])
              : '',
            value: vScale
              ? '' + vScale.getLabelForValue(parsed[vScale.axis])
              : '',
          };
        }
        _update(mode) {
          const meta = this._cachedMeta;
          this.update(mode || 'default'),
            (meta._clip = (function toClip(value) {
              let t, r, b, l;
              return (
                isObject(value)
                  ? ((t = value.top),
                    (r = value.right),
                    (b = value.bottom),
                    (l = value.left))
                  : (t = r = b = l = value),
                { top: t, right: r, bottom: b, left: l, disabled: !1 === value }
              );
            })(
              valueOrDefault(
                this.options.clip,
                (function defaultClip(xScale, yScale, allowedOverflow) {
                  if (!1 === allowedOverflow) return !1;
                  const x = scaleClip(xScale, allowedOverflow),
                    y = scaleClip(yScale, allowedOverflow);
                  return {
                    top: y.end,
                    right: x.end,
                    bottom: y.start,
                    left: x.start,
                  };
                })(meta.xScale, meta.yScale, this.getMaxOverflow())
              )
            ));
        }
        update(mode) {}
        draw() {
          const ctx = this._ctx,
            chart = this.chart,
            meta = this._cachedMeta,
            elements = meta.data || [],
            area = chart.chartArea,
            active = [],
            start = this._drawStart || 0,
            count = this._drawCount || elements.length - start,
            drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
          let i;
          for (
            meta.dataset && meta.dataset.draw(ctx, area, start, count),
              i = start;
            i < start + count;
            ++i
          ) {
            const element = elements[i];
            element.hidden ||
              (element.active && drawActiveElementsOnTop
                ? active.push(element)
                : element.draw(ctx, area));
          }
          for (i = 0; i < active.length; ++i) active[i].draw(ctx, area);
        }
        getStyle(index, active) {
          const mode = active ? 'active' : 'default';
          return void 0 === index && this._cachedMeta.dataset
            ? this.resolveDatasetElementOptions(mode)
            : this.resolveDataElementOptions(index || 0, mode);
        }
        getContext(index, active, mode) {
          const dataset = this.getDataset();
          let context;
          if (index >= 0 && index < this._cachedMeta.data.length) {
            const element = this._cachedMeta.data[index];
            (context =
              element.$context ||
              (element.$context = (function createDataContext(
                parent,
                index,
                element
              ) {
                return createContext(parent, {
                  active: !1,
                  dataIndex: index,
                  parsed: void 0,
                  raw: void 0,
                  element,
                  index,
                  mode: 'default',
                  type: 'data',
                });
              })(this.getContext(), index, element))),
              (context.parsed = this.getParsed(index)),
              (context.raw = dataset.data[index]),
              (context.index = context.dataIndex = index);
          } else
            (context =
              this.$context ||
              (this.$context = (function createDatasetContext(parent, index) {
                return createContext(parent, {
                  active: !1,
                  dataset: void 0,
                  datasetIndex: index,
                  index,
                  mode: 'default',
                  type: 'dataset',
                });
              })(this.chart.getContext(), this.index))),
              (context.dataset = dataset),
              (context.index = context.datasetIndex = this.index);
          return (context.active = !!active), (context.mode = mode), context;
        }
        resolveDatasetElementOptions(mode) {
          return this._resolveElementOptions(this.datasetElementType.id, mode);
        }
        resolveDataElementOptions(index, mode) {
          return this._resolveElementOptions(
            this.dataElementType.id,
            mode,
            index
          );
        }
        _resolveElementOptions(elementType, mode = 'default', index) {
          const active = 'active' === mode,
            cache = this._cachedDataOpts,
            cacheKey = elementType + '-' + mode,
            cached = cache[cacheKey],
            sharing = this.enableOptionSharing && defined(index);
          if (cached) return cloneIfNotShared(cached, sharing);
          const config = this.chart.config,
            scopeKeys = config.datasetElementScopeKeys(this._type, elementType),
            prefixes = active
              ? [`${elementType}Hover`, 'hover', elementType, '']
              : [elementType, ''],
            scopes = config.getOptionScopes(this.getDataset(), scopeKeys),
            names = Object.keys(defaults.elements[elementType]),
            values = config.resolveNamedOptions(
              scopes,
              names,
              () => this.getContext(index, active, mode),
              prefixes
            );
          return (
            values.$shared &&
              ((values.$shared = sharing),
              (cache[cacheKey] = Object.freeze(
                cloneIfNotShared(values, sharing)
              ))),
            values
          );
        }
        _resolveAnimations(index, transition, active) {
          const chart = this.chart,
            cache = this._cachedDataOpts,
            cacheKey = `animation-${transition}`,
            cached = cache[cacheKey];
          if (cached) return cached;
          let options;
          if (!1 !== chart.options.animation) {
            const config = this.chart.config,
              scopeKeys = config.datasetAnimationScopeKeys(
                this._type,
                transition
              ),
              scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
            options = config.createResolver(
              scopes,
              this.getContext(index, active, transition)
            );
          }
          const animations = new Animations(
            chart,
            options && options.animations
          );
          return (
            options &&
              options._cacheable &&
              (cache[cacheKey] = Object.freeze(animations)),
            animations
          );
        }
        getSharedOptions(options) {
          if (options.$shared)
            return (
              this._sharedOptions ||
              (this._sharedOptions = Object.assign({}, options))
            );
        }
        includeOptions(mode, sharedOptions) {
          return (
            !sharedOptions ||
            isDirectUpdateMode(mode) ||
            this.chart._animationsDisabled
          );
        }
        _getSharedOptions(start, mode) {
          const firstOpts = this.resolveDataElementOptions(start, mode),
            previouslySharedOptions = this._sharedOptions,
            sharedOptions = this.getSharedOptions(firstOpts),
            includeOptions =
              this.includeOptions(mode, sharedOptions) ||
              sharedOptions !== previouslySharedOptions;
          return (
            this.updateSharedOptions(sharedOptions, mode, firstOpts),
            { sharedOptions, includeOptions }
          );
        }
        updateElement(element, index, properties, mode) {
          isDirectUpdateMode(mode)
            ? Object.assign(element, properties)
            : this._resolveAnimations(index, mode).update(element, properties);
        }
        updateSharedOptions(sharedOptions, mode, newOptions) {
          sharedOptions &&
            !isDirectUpdateMode(mode) &&
            this._resolveAnimations(void 0, mode).update(
              sharedOptions,
              newOptions
            );
        }
        _setStyle(element, index, mode, active) {
          element.active = active;
          const options = this.getStyle(index, active);
          this._resolveAnimations(index, mode, active).update(element, {
            options: (!active && this.getSharedOptions(options)) || options,
          });
        }
        removeHoverStyle(element, datasetIndex, index) {
          this._setStyle(element, index, 'active', !1);
        }
        setHoverStyle(element, datasetIndex, index) {
          this._setStyle(element, index, 'active', !0);
        }
        _removeDatasetHoverStyle() {
          const element = this._cachedMeta.dataset;
          element && this._setStyle(element, void 0, 'active', !1);
        }
        _setDatasetHoverStyle() {
          const element = this._cachedMeta.dataset;
          element && this._setStyle(element, void 0, 'active', !0);
        }
        _resyncElements(resetNewElements) {
          const data = this._data,
            elements = this._cachedMeta.data;
          for (const [method, arg1, arg2] of this._syncList)
            this[method](arg1, arg2);
          this._syncList = [];
          const numMeta = elements.length,
            numData = data.length,
            count = Math.min(numData, numMeta);
          count && this.parse(0, count),
            numData > numMeta
              ? this._insertElements(
                  numMeta,
                  numData - numMeta,
                  resetNewElements
                )
              : numData < numMeta &&
                this._removeElements(numData, numMeta - numData);
        }
        _insertElements(start, count, resetNewElements = !0) {
          const meta = this._cachedMeta,
            data = meta.data,
            end = start + count;
          let i;
          const move = (arr) => {
            for (arr.length += count, i = arr.length - 1; i >= end; i--)
              arr[i] = arr[i - count];
          };
          for (move(data), i = start; i < end; ++i)
            data[i] = new this.dataElementType();
          this._parsing && move(meta._parsed),
            this.parse(start, count),
            resetNewElements &&
              this.updateElements(data, start, count, 'reset');
        }
        updateElements(element, start, count, mode) {}
        _removeElements(start, count) {
          const meta = this._cachedMeta;
          if (this._parsing) {
            const removed = meta._parsed.splice(start, count);
            meta._stacked && clearStacks(meta, removed);
          }
          meta.data.splice(start, count);
        }
        _sync(args) {
          if (this._parsing) this._syncList.push(args);
          else {
            const [method, arg1, arg2] = args;
            this[method](arg1, arg2);
          }
          this.chart._dataChanges.push([this.index, ...args]);
        }
        _onDataPush() {
          const count = arguments.length;
          this._sync([
            '_insertElements',
            this.getDataset().data.length - count,
            count,
          ]);
        }
        _onDataPop() {
          this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);
        }
        _onDataShift() {
          this._sync(['_removeElements', 0, 1]);
        }
        _onDataSplice(start, count) {
          count && this._sync(['_removeElements', start, count]);
          const newCount = arguments.length - 2;
          newCount && this._sync(['_insertElements', start, newCount]);
        }
        _onDataUnshift() {
          this._sync(['_insertElements', 0, arguments.length]);
        }
      }
      class LineController extends DatasetController {
        static id = 'line';
        static defaults = {
          datasetElementType: 'line',
          dataElementType: 'point',
          showLine: !0,
          spanGaps: !1,
        };
        static overrides = {
          scales: {
            _index_: { type: 'category' },
            _value_: { type: 'linear' },
          },
        };
        initialize() {
          (this.enableOptionSharing = !0),
            (this.supportsDecimation = !0),
            super.initialize();
        }
        update(mode) {
          const meta = this._cachedMeta,
            { dataset: line, data: points = [], _dataset } = meta,
            animationsDisabled = this.chart._animationsDisabled;
          let { start, count } = _getStartAndCountOfVisiblePoints(
            meta,
            points,
            animationsDisabled
          );
          (this._drawStart = start),
            (this._drawCount = count),
            _scaleRangesChanged(meta) && ((start = 0), (count = points.length)),
            (line._chart = this.chart),
            (line._datasetIndex = this.index),
            (line._decimated = !!_dataset._decimated),
            (line.points = points);
          const options = this.resolveDatasetElementOptions(mode);
          this.options.showLine || (options.borderWidth = 0),
            (options.segment = this.options.segment),
            this.updateElement(
              line,
              void 0,
              { animated: !animationsDisabled, options },
              mode
            ),
            this.updateElements(points, start, count, mode);
        }
        updateElements(points, start, count, mode) {
          const reset = 'reset' === mode,
            { iScale, vScale, _stacked, _dataset } = this._cachedMeta,
            { sharedOptions, includeOptions } = this._getSharedOptions(
              start,
              mode
            ),
            iAxis = iScale.axis,
            vAxis = vScale.axis,
            { spanGaps, segment } = this.options,
            maxGapLength = isNumber(spanGaps)
              ? spanGaps
              : Number.POSITIVE_INFINITY,
            directUpdate =
              this.chart._animationsDisabled || reset || 'none' === mode,
            end = start + count,
            pointsCount = points.length;
          let prevParsed = start > 0 && this.getParsed(start - 1);
          for (let i = 0; i < pointsCount; ++i) {
            const point = points[i],
              properties = directUpdate ? point : {};
            if (i < start || i >= end) {
              properties.skip = !0;
              continue;
            }
            const parsed = this.getParsed(i),
              nullData = isNullOrUndef(parsed[vAxis]),
              iPixel = (properties[iAxis] = iScale.getPixelForValue(
                parsed[iAxis],
                i
              )),
              vPixel = (properties[vAxis] =
                reset || nullData
                  ? vScale.getBasePixel()
                  : vScale.getPixelForValue(
                      _stacked
                        ? this.applyStack(vScale, parsed, _stacked)
                        : parsed[vAxis],
                      i
                    ));
            (properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData),
              (properties.stop =
                i > 0 &&
                Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength),
              segment &&
                ((properties.parsed = parsed),
                (properties.raw = _dataset.data[i])),
              includeOptions &&
                (properties.options =
                  sharedOptions ||
                  this.resolveDataElementOptions(
                    i,
                    point.active ? 'active' : mode
                  )),
              directUpdate || this.updateElement(point, i, properties, mode),
              (prevParsed = parsed);
          }
        }
        getMaxOverflow() {
          const meta = this._cachedMeta,
            dataset = meta.dataset,
            border = (dataset.options && dataset.options.borderWidth) || 0,
            data = meta.data || [];
          if (!data.length) return border;
          const firstPoint = data[0].size(this.resolveDataElementOptions(0)),
            lastPoint = data[data.length - 1].size(
              this.resolveDataElementOptions(data.length - 1)
            );
          return Math.max(border, firstPoint, lastPoint) / 2;
        }
        draw() {
          const meta = this._cachedMeta;
          meta.dataset.updateControlPoints(
            this.chart.chartArea,
            meta.iScale.axis
          ),
            super.draw();
        }
      }
      function chart_abstract() {
        throw new Error(
          'This method is not implemented: Check that a complete date adapter is provided.'
        );
      }
      class DateAdapterBase {
        static override(members) {
          Object.assign(DateAdapterBase.prototype, members);
        }
        constructor(options) {
          this.options = options || {};
        }
        init() {}
        formats() {
          return chart_abstract();
        }
        parse() {
          return chart_abstract();
        }
        format() {
          return chart_abstract();
        }
        add() {
          return chart_abstract();
        }
        diff() {
          return chart_abstract();
        }
        startOf() {
          return chart_abstract();
        }
        endOf() {
          return chart_abstract();
        }
      }
      var adapters = { _date: DateAdapterBase };
      function binarySearch(metaset, axis, value, intersect) {
        const { controller, data, _sorted } = metaset,
          iScale = controller._cachedMeta.iScale;
        if (
          iScale &&
          axis === iScale.axis &&
          'r' !== axis &&
          _sorted &&
          data.length
        ) {
          const lookupMethod = iScale._reversePixels
            ? _rlookupByKey
            : _lookupByKey;
          if (!intersect) return lookupMethod(data, axis, value);
          if (controller._sharedOptions) {
            const el = data[0],
              range = 'function' == typeof el.getRange && el.getRange(axis);
            if (range) {
              const start = lookupMethod(data, axis, value - range),
                end = lookupMethod(data, axis, value + range);
              return { lo: start.lo, hi: end.hi };
            }
          }
        }
        return { lo: 0, hi: data.length - 1 };
      }
      function evaluateInteractionItems(
        chart,
        axis,
        position,
        handler,
        intersect
      ) {
        const metasets = chart.getSortedVisibleDatasetMetas(),
          value = position[axis];
        for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
          const { index, data } = metasets[i],
            { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
          for (let j = lo; j <= hi; ++j) {
            const element = data[j];
            element.skip || handler(element, index, j);
          }
        }
      }
      function getIntersectItems(
        chart,
        position,
        axis,
        useFinalPosition,
        includeInvisible
      ) {
        const items = [];
        if (!includeInvisible && !chart.isPointInArea(position)) return items;
        return (
          evaluateInteractionItems(
            chart,
            axis,
            position,
            function (element, datasetIndex, index) {
              (includeInvisible ||
                _isPointInArea(element, chart.chartArea, 0)) &&
                element.inRange(position.x, position.y, useFinalPosition) &&
                items.push({ element, datasetIndex, index });
            },
            !0
          ),
          items
        );
      }
      function getNearestCartesianItems(
        chart,
        position,
        axis,
        intersect,
        useFinalPosition,
        includeInvisible
      ) {
        let items = [];
        const distanceMetric = (function getDistanceMetricForAxis(axis) {
          const useX = -1 !== axis.indexOf('x'),
            useY = -1 !== axis.indexOf('y');
          return function (pt1, pt2) {
            const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0,
              deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
            return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
          };
        })(axis);
        let minDistance = Number.POSITIVE_INFINITY;
        return (
          evaluateInteractionItems(
            chart,
            axis,
            position,
            function evaluationFunc(element, datasetIndex, index) {
              const inRange = element.inRange(
                position.x,
                position.y,
                useFinalPosition
              );
              if (intersect && !inRange) return;
              const center = element.getCenterPoint(useFinalPosition);
              if (
                !(!!includeInvisible || chart.isPointInArea(center)) &&
                !inRange
              )
                return;
              const distance = distanceMetric(position, center);
              distance < minDistance
                ? ((items = [{ element, datasetIndex, index }]),
                  (minDistance = distance))
                : distance === minDistance &&
                  items.push({ element, datasetIndex, index });
            }
          ),
          items
        );
      }
      function getNearestItems(
        chart,
        position,
        axis,
        intersect,
        useFinalPosition,
        includeInvisible
      ) {
        return includeInvisible || chart.isPointInArea(position)
          ? 'r' !== axis || intersect
            ? getNearestCartesianItems(
                chart,
                position,
                axis,
                intersect,
                useFinalPosition,
                includeInvisible
              )
            : (function getNearestRadialItems(
                chart,
                position,
                axis,
                useFinalPosition
              ) {
                let items = [];
                return (
                  evaluateInteractionItems(
                    chart,
                    axis,
                    position,
                    function evaluationFunc(element, datasetIndex, index) {
                      const { startAngle, endAngle } = element.getProps(
                          ['startAngle', 'endAngle'],
                          useFinalPosition
                        ),
                        { angle } = getAngleFromPoint(element, {
                          x: position.x,
                          y: position.y,
                        });
                      _angleBetween(angle, startAngle, endAngle) &&
                        items.push({ element, datasetIndex, index });
                    }
                  ),
                  items
                );
              })(chart, position, axis, useFinalPosition)
          : [];
      }
      function getAxisItems(
        chart,
        position,
        axis,
        intersect,
        useFinalPosition
      ) {
        const items = [],
          rangeMethod = 'x' === axis ? 'inXRange' : 'inYRange';
        let intersectsItem = !1;
        return (
          evaluateInteractionItems(
            chart,
            axis,
            position,
            (element, datasetIndex, index) => {
              element[rangeMethod](position[axis], useFinalPosition) &&
                (items.push({ element, datasetIndex, index }),
                (intersectsItem =
                  intersectsItem ||
                  element.inRange(position.x, position.y, useFinalPosition)));
            }
          ),
          intersect && !intersectsItem ? [] : items
        );
      }
      var Interaction = {
        evaluateInteractionItems,
        modes: {
          index(chart, e, options, useFinalPosition) {
            const position = getRelativePosition(e, chart),
              axis = options.axis || 'x',
              includeInvisible = options.includeInvisible || !1,
              items = options.intersect
                ? getIntersectItems(
                    chart,
                    position,
                    axis,
                    useFinalPosition,
                    includeInvisible
                  )
                : getNearestItems(
                    chart,
                    position,
                    axis,
                    !1,
                    useFinalPosition,
                    includeInvisible
                  ),
              elements = [];
            return items.length
              ? (chart.getSortedVisibleDatasetMetas().forEach((meta) => {
                  const index = items[0].index,
                    element = meta.data[index];
                  element &&
                    !element.skip &&
                    elements.push({ element, datasetIndex: meta.index, index });
                }),
                elements)
              : [];
          },
          dataset(chart, e, options, useFinalPosition) {
            const position = getRelativePosition(e, chart),
              axis = options.axis || 'xy',
              includeInvisible = options.includeInvisible || !1;
            let items = options.intersect
              ? getIntersectItems(
                  chart,
                  position,
                  axis,
                  useFinalPosition,
                  includeInvisible
                )
              : getNearestItems(
                  chart,
                  position,
                  axis,
                  !1,
                  useFinalPosition,
                  includeInvisible
                );
            if (items.length > 0) {
              const datasetIndex = items[0].datasetIndex,
                data = chart.getDatasetMeta(datasetIndex).data;
              items = [];
              for (let i = 0; i < data.length; ++i)
                items.push({ element: data[i], datasetIndex, index: i });
            }
            return items;
          },
          point: (chart, e, options, useFinalPosition) =>
            getIntersectItems(
              chart,
              getRelativePosition(e, chart),
              options.axis || 'xy',
              useFinalPosition,
              options.includeInvisible || !1
            ),
          nearest(chart, e, options, useFinalPosition) {
            const position = getRelativePosition(e, chart),
              axis = options.axis || 'xy',
              includeInvisible = options.includeInvisible || !1;
            return getNearestItems(
              chart,
              position,
              axis,
              options.intersect,
              useFinalPosition,
              includeInvisible
            );
          },
          x: (chart, e, options, useFinalPosition) =>
            getAxisItems(
              chart,
              getRelativePosition(e, chart),
              'x',
              options.intersect,
              useFinalPosition
            ),
          y: (chart, e, options, useFinalPosition) =>
            getAxisItems(
              chart,
              getRelativePosition(e, chart),
              'y',
              options.intersect,
              useFinalPosition
            ),
        },
      };
      const STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];
      function filterByPosition(array, position) {
        return array.filter((v) => v.pos === position);
      }
      function filterDynamicPositionByAxis(array, axis) {
        return array.filter(
          (v) => -1 === STATIC_POSITIONS.indexOf(v.pos) && v.box.axis === axis
        );
      }
      function sortByWeight(array, reverse) {
        return array.sort((a, b) => {
          const v0 = reverse ? b : a,
            v1 = reverse ? a : b;
          return v0.weight === v1.weight
            ? v0.index - v1.index
            : v0.weight - v1.weight;
        });
      }
      function setLayoutDims(layouts, params) {
        const stacks = (function buildStacks(layouts) {
            const stacks = {};
            for (const wrap of layouts) {
              const { stack, pos, stackWeight } = wrap;
              if (!stack || !STATIC_POSITIONS.includes(pos)) continue;
              const _stack =
                stacks[stack] ||
                (stacks[stack] = { count: 0, placed: 0, weight: 0, size: 0 });
              _stack.count++, (_stack.weight += stackWeight);
            }
            return stacks;
          })(layouts),
          { vBoxMaxWidth, hBoxMaxHeight } = params;
        let i, ilen, layout;
        for (i = 0, ilen = layouts.length; i < ilen; ++i) {
          layout = layouts[i];
          const { fullSize } = layout.box,
            stack = stacks[layout.stack],
            factor = stack && layout.stackWeight / stack.weight;
          layout.horizontal
            ? ((layout.width = factor
                ? factor * vBoxMaxWidth
                : fullSize && params.availableWidth),
              (layout.height = hBoxMaxHeight))
            : ((layout.width = vBoxMaxWidth),
              (layout.height = factor
                ? factor * hBoxMaxHeight
                : fullSize && params.availableHeight));
        }
        return stacks;
      }
      function getCombinedMax(maxPadding, chartArea, a, b) {
        return (
          Math.max(maxPadding[a], chartArea[a]) +
          Math.max(maxPadding[b], chartArea[b])
        );
      }
      function updateMaxPadding(maxPadding, boxPadding) {
        (maxPadding.top = Math.max(maxPadding.top, boxPadding.top)),
          (maxPadding.left = Math.max(maxPadding.left, boxPadding.left)),
          (maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom)),
          (maxPadding.right = Math.max(maxPadding.right, boxPadding.right));
      }
      function updateDims(chartArea, params, layout, stacks) {
        const { pos, box } = layout,
          maxPadding = chartArea.maxPadding;
        if (!isObject(pos)) {
          layout.size && (chartArea[pos] -= layout.size);
          const stack = stacks[layout.stack] || { size: 0, count: 1 };
          (stack.size = Math.max(
            stack.size,
            layout.horizontal ? box.height : box.width
          )),
            (layout.size = stack.size / stack.count),
            (chartArea[pos] += layout.size);
        }
        box.getPadding && updateMaxPadding(maxPadding, box.getPadding());
        const newWidth = Math.max(
            0,
            params.outerWidth -
              getCombinedMax(maxPadding, chartArea, 'left', 'right')
          ),
          newHeight = Math.max(
            0,
            params.outerHeight -
              getCombinedMax(maxPadding, chartArea, 'top', 'bottom')
          ),
          widthChanged = newWidth !== chartArea.w,
          heightChanged = newHeight !== chartArea.h;
        return (
          (chartArea.w = newWidth),
          (chartArea.h = newHeight),
          layout.horizontal
            ? { same: widthChanged, other: heightChanged }
            : { same: heightChanged, other: widthChanged }
        );
      }
      function getMargins(horizontal, chartArea) {
        const maxPadding = chartArea.maxPadding;
        function marginForPositions(positions) {
          const margin = { left: 0, top: 0, right: 0, bottom: 0 };
          return (
            positions.forEach((pos) => {
              margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
            }),
            margin
          );
        }
        return marginForPositions(
          horizontal ? ['left', 'right'] : ['top', 'bottom']
        );
      }
      function fitBoxes(boxes, chartArea, params, stacks) {
        const refitBoxes = [];
        let i, ilen, layout, box, refit, changed;
        for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
          (layout = boxes[i]),
            (box = layout.box),
            box.update(
              layout.width || chartArea.w,
              layout.height || chartArea.h,
              getMargins(layout.horizontal, chartArea)
            );
          const { same, other } = updateDims(chartArea, params, layout, stacks);
          (refit |= same && refitBoxes.length),
            (changed = changed || other),
            box.fullSize || refitBoxes.push(layout);
        }
        return (
          (refit && fitBoxes(refitBoxes, chartArea, params, stacks)) || changed
        );
      }
      function setBoxDims(box, left, top, width, height) {
        (box.top = top),
          (box.left = left),
          (box.right = left + width),
          (box.bottom = top + height),
          (box.width = width),
          (box.height = height);
      }
      function placeBoxes(boxes, chartArea, params, stacks) {
        const userPadding = params.padding;
        let { x, y } = chartArea;
        for (const layout of boxes) {
          const box = layout.box,
            stack = stacks[layout.stack] || { count: 1, placed: 0, weight: 1 },
            weight = layout.stackWeight / stack.weight || 1;
          if (layout.horizontal) {
            const width = chartArea.w * weight,
              height = stack.size || box.height;
            defined(stack.start) && (y = stack.start),
              box.fullSize
                ? setBoxDims(
                    box,
                    userPadding.left,
                    y,
                    params.outerWidth - userPadding.right - userPadding.left,
                    height
                  )
                : setBoxDims(
                    box,
                    chartArea.left + stack.placed,
                    y,
                    width,
                    height
                  ),
              (stack.start = y),
              (stack.placed += width),
              (y = box.bottom);
          } else {
            const height1 = chartArea.h * weight,
              width1 = stack.size || box.width;
            defined(stack.start) && (x = stack.start),
              box.fullSize
                ? setBoxDims(
                    box,
                    x,
                    userPadding.top,
                    width1,
                    params.outerHeight - userPadding.bottom - userPadding.top
                  )
                : setBoxDims(
                    box,
                    x,
                    chartArea.top + stack.placed,
                    width1,
                    height1
                  ),
              (stack.start = x),
              (stack.placed += height1),
              (x = box.right);
          }
        }
        (chartArea.x = x), (chartArea.y = y);
      }
      var layouts = {
        addBox(chart, item) {
          chart.boxes || (chart.boxes = []),
            (item.fullSize = item.fullSize || !1),
            (item.position = item.position || 'top'),
            (item.weight = item.weight || 0),
            (item._layers =
              item._layers ||
              function () {
                return [
                  {
                    z: 0,
                    draw(chartArea) {
                      item.draw(chartArea);
                    },
                  },
                ];
              }),
            chart.boxes.push(item);
        },
        removeBox(chart, layoutItem) {
          const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
          -1 !== index && chart.boxes.splice(index, 1);
        },
        configure(chart, item, options) {
          (item.fullSize = options.fullSize),
            (item.position = options.position),
            (item.weight = options.weight);
        },
        update(chart, width, height, minPadding) {
          if (!chart) return;
          const padding = toPadding(chart.options.layout.padding),
            availableWidth = Math.max(width - padding.width, 0),
            availableHeight = Math.max(height - padding.height, 0),
            boxes = (function buildLayoutBoxes(boxes) {
              const layoutBoxes = (function wrapBoxes(boxes) {
                  const layoutBoxes = [];
                  let i, ilen, box, pos, stack, stackWeight;
                  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i)
                    (box = boxes[i]),
                      ({
                        position: pos,
                        options: { stack, stackWeight = 1 },
                      } = box),
                      layoutBoxes.push({
                        index: i,
                        box,
                        pos,
                        horizontal: box.isHorizontal(),
                        weight: box.weight,
                        stack: stack && pos + stack,
                        stackWeight,
                      });
                  return layoutBoxes;
                })(boxes),
                fullSize = sortByWeight(
                  layoutBoxes.filter((wrap) => wrap.box.fullSize),
                  !0
                ),
                left = sortByWeight(filterByPosition(layoutBoxes, 'left'), !0),
                right = sortByWeight(filterByPosition(layoutBoxes, 'right')),
                top = sortByWeight(filterByPosition(layoutBoxes, 'top'), !0),
                bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom')),
                centerHorizontal = filterDynamicPositionByAxis(
                  layoutBoxes,
                  'x'
                ),
                centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');
              return {
                fullSize,
                leftAndTop: left.concat(top),
                rightAndBottom: right
                  .concat(centerVertical)
                  .concat(bottom)
                  .concat(centerHorizontal),
                chartArea: filterByPosition(layoutBoxes, 'chartArea'),
                vertical: left.concat(right).concat(centerVertical),
                horizontal: top.concat(bottom).concat(centerHorizontal),
              };
            })(chart.boxes),
            verticalBoxes = boxes.vertical,
            horizontalBoxes = boxes.horizontal;
          each(chart.boxes, (box) => {
            'function' == typeof box.beforeLayout && box.beforeLayout();
          });
          const visibleVerticalBoxCount =
              verticalBoxes.reduce(
                (total, wrap) =>
                  wrap.box.options && !1 === wrap.box.options.display
                    ? total
                    : total + 1,
                0
              ) || 1,
            params = Object.freeze({
              outerWidth: width,
              outerHeight: height,
              padding,
              availableWidth,
              availableHeight,
              vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
              hBoxMaxHeight: availableHeight / 2,
            }),
            maxPadding = Object.assign({}, padding);
          updateMaxPadding(maxPadding, toPadding(minPadding));
          const chartArea = Object.assign(
              {
                maxPadding,
                w: availableWidth,
                h: availableHeight,
                x: padding.left,
                y: padding.top,
              },
              padding
            ),
            stacks = setLayoutDims(
              verticalBoxes.concat(horizontalBoxes),
              params
            );
          fitBoxes(boxes.fullSize, chartArea, params, stacks),
            fitBoxes(verticalBoxes, chartArea, params, stacks),
            fitBoxes(horizontalBoxes, chartArea, params, stacks) &&
              fitBoxes(verticalBoxes, chartArea, params, stacks),
            (function handleMaxPadding(chartArea) {
              const maxPadding = chartArea.maxPadding;
              function updatePos(pos) {
                const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
                return (chartArea[pos] += change), change;
              }
              (chartArea.y += updatePos('top')),
                (chartArea.x += updatePos('left')),
                updatePos('right'),
                updatePos('bottom');
            })(chartArea),
            placeBoxes(boxes.leftAndTop, chartArea, params, stacks),
            (chartArea.x += chartArea.w),
            (chartArea.y += chartArea.h),
            placeBoxes(boxes.rightAndBottom, chartArea, params, stacks),
            (chart.chartArea = {
              left: chartArea.left,
              top: chartArea.top,
              right: chartArea.left + chartArea.w,
              bottom: chartArea.top + chartArea.h,
              height: chartArea.h,
              width: chartArea.w,
            }),
            each(boxes.chartArea, (layout) => {
              const box = layout.box;
              Object.assign(box, chart.chartArea),
                box.update(chartArea.w, chartArea.h, {
                  left: 0,
                  top: 0,
                  right: 0,
                  bottom: 0,
                });
            });
        },
      };
      class BasePlatform {
        acquireContext(canvas, aspectRatio) {}
        releaseContext(context) {
          return !1;
        }
        addEventListener(chart, type, listener) {}
        removeEventListener(chart, type, listener) {}
        getDevicePixelRatio() {
          return 1;
        }
        getMaximumSize(element, width, height, aspectRatio) {
          return (
            (width = Math.max(0, width || element.width)),
            (height = height || element.height),
            {
              width,
              height: Math.max(
                0,
                aspectRatio ? Math.floor(width / aspectRatio) : height
              ),
            }
          );
        }
        isAttached(canvas) {
          return !0;
        }
        updateConfig(config) {}
      }
      class BasicPlatform extends BasePlatform {
        acquireContext(item) {
          return (item && item.getContext && item.getContext('2d')) || null;
        }
        updateConfig(config) {
          config.options.animation = !1;
        }
      }
      const EXPANDO_KEY = '$chartjs',
        EVENT_TYPES = {
          touchstart: 'mousedown',
          touchmove: 'mousemove',
          touchend: 'mouseup',
          pointerenter: 'mouseenter',
          pointerdown: 'mousedown',
          pointermove: 'mousemove',
          pointerup: 'mouseup',
          pointerleave: 'mouseout',
          pointerout: 'mouseout',
        },
        isNullOrEmpty = (value) => null === value || '' === value;
      const eventListenerOptions = !!supportsEventListenerOptions && {
        passive: !0,
      };
      function removeListener(chart, type, listener) {
        chart.canvas.removeEventListener(type, listener, eventListenerOptions);
      }
      function nodeListContains(nodeList, canvas) {
        for (const node of nodeList)
          if (node === canvas || node.contains(canvas)) return !0;
      }
      function createAttachObserver(chart, type, listener) {
        const canvas = chart.canvas,
          observer = new MutationObserver((entries) => {
            let trigger = !1;
            for (const entry of entries)
              (trigger = trigger || nodeListContains(entry.addedNodes, canvas)),
                (trigger =
                  trigger && !nodeListContains(entry.removedNodes, canvas));
            trigger && listener();
          });
        return (
          observer.observe(document, { childList: !0, subtree: !0 }), observer
        );
      }
      function createDetachObserver(chart, type, listener) {
        const canvas = chart.canvas,
          observer = new MutationObserver((entries) => {
            let trigger = !1;
            for (const entry of entries)
              (trigger =
                trigger || nodeListContains(entry.removedNodes, canvas)),
                (trigger =
                  trigger && !nodeListContains(entry.addedNodes, canvas));
            trigger && listener();
          });
        return (
          observer.observe(document, { childList: !0, subtree: !0 }), observer
        );
      }
      const drpListeningCharts = new Map();
      let oldDevicePixelRatio = 0;
      function onWindowResize() {
        const dpr = window.devicePixelRatio;
        dpr !== oldDevicePixelRatio &&
          ((oldDevicePixelRatio = dpr),
          drpListeningCharts.forEach((resize, chart) => {
            chart.currentDevicePixelRatio !== dpr && resize();
          }));
      }
      function createResizeObserver(chart, type, listener) {
        const canvas = chart.canvas,
          container = canvas && _getParentNode(canvas);
        if (!container) return;
        const resize = throttled((width, height) => {
            const w = container.clientWidth;
            listener(width, height), w < container.clientWidth && listener();
          }, window),
          observer = new ResizeObserver((entries) => {
            const entry = entries[0],
              width = entry.contentRect.width,
              height = entry.contentRect.height;
            (0 === width && 0 === height) || resize(width, height);
          });
        return (
          observer.observe(container),
          (function listenDevicePixelRatioChanges(chart, resize) {
            drpListeningCharts.size ||
              window.addEventListener('resize', onWindowResize),
              drpListeningCharts.set(chart, resize);
          })(chart, resize),
          observer
        );
      }
      function releaseObserver(chart, type, observer) {
        observer && observer.disconnect(),
          'resize' === type &&
            (function unlistenDevicePixelRatioChanges(chart) {
              drpListeningCharts.delete(chart),
                drpListeningCharts.size ||
                  window.removeEventListener('resize', onWindowResize);
            })(chart);
      }
      function createProxyAndListen(chart, type, listener) {
        const canvas = chart.canvas,
          proxy = throttled((event) => {
            null !== chart.ctx &&
              listener(
                (function fromNativeEvent(event, chart) {
                  const type = EVENT_TYPES[event.type] || event.type,
                    { x, y } = getRelativePosition(event, chart);
                  return {
                    type,
                    chart,
                    native: event,
                    x: void 0 !== x ? x : null,
                    y: void 0 !== y ? y : null,
                  };
                })(event, chart)
              );
          }, chart);
        return (
          (function addListener(node, type, listener) {
            node.addEventListener(type, listener, eventListenerOptions);
          })(canvas, type, proxy),
          proxy
        );
      }
      class DomPlatform extends BasePlatform {
        acquireContext(canvas, aspectRatio) {
          const context =
            canvas && canvas.getContext && canvas.getContext('2d');
          return context && context.canvas === canvas
            ? ((function initCanvas(canvas, aspectRatio) {
                const style = canvas.style,
                  renderHeight = canvas.getAttribute('height'),
                  renderWidth = canvas.getAttribute('width');
                if (
                  ((canvas[EXPANDO_KEY] = {
                    initial: {
                      height: renderHeight,
                      width: renderWidth,
                      style: {
                        display: style.display,
                        height: style.height,
                        width: style.width,
                      },
                    },
                  }),
                  (style.display = style.display || 'block'),
                  (style.boxSizing = style.boxSizing || 'border-box'),
                  isNullOrEmpty(renderWidth))
                ) {
                  const displayWidth = readUsedSize(canvas, 'width');
                  void 0 !== displayWidth && (canvas.width = displayWidth);
                }
                if (isNullOrEmpty(renderHeight))
                  if ('' === canvas.style.height)
                    canvas.height = canvas.width / (aspectRatio || 2);
                  else {
                    const displayHeight = readUsedSize(canvas, 'height');
                    void 0 !== displayHeight && (canvas.height = displayHeight);
                  }
                return canvas;
              })(canvas, aspectRatio),
              context)
            : null;
        }
        releaseContext(context) {
          const canvas = context.canvas;
          if (!canvas[EXPANDO_KEY]) return !1;
          const initial = canvas[EXPANDO_KEY].initial;
          ['height', 'width'].forEach((prop) => {
            const value = initial[prop];
            isNullOrUndef(value)
              ? canvas.removeAttribute(prop)
              : canvas.setAttribute(prop, value);
          });
          const style = initial.style || {};
          return (
            Object.keys(style).forEach((key) => {
              canvas.style[key] = style[key];
            }),
            (canvas.width = canvas.width),
            delete canvas[EXPANDO_KEY],
            !0
          );
        }
        addEventListener(chart, type, listener) {
          this.removeEventListener(chart, type);
          const proxies = chart.$proxies || (chart.$proxies = {}),
            handler =
              {
                attach: createAttachObserver,
                detach: createDetachObserver,
                resize: createResizeObserver,
              }[type] || createProxyAndListen;
          proxies[type] = handler(chart, type, listener);
        }
        removeEventListener(chart, type) {
          const proxies = chart.$proxies || (chart.$proxies = {}),
            proxy = proxies[type];
          if (!proxy) return;
          ((
            {
              attach: releaseObserver,
              detach: releaseObserver,
              resize: releaseObserver,
            }[type] || removeListener
          )(chart, type, proxy),
            (proxies[type] = void 0));
        }
        getDevicePixelRatio() {
          return window.devicePixelRatio;
        }
        getMaximumSize(canvas, width, height, aspectRatio) {
          return getMaximumSize(canvas, width, height, aspectRatio);
        }
        isAttached(canvas) {
          const container = _getParentNode(canvas);
          return !(!container || !container.isConnected);
        }
      }
      class Element {
        static defaults = {};
        static defaultRoutes = void 0;
        active = !1;
        tooltipPosition(useFinalPosition) {
          const { x, y } = this.getProps(['x', 'y'], useFinalPosition);
          return { x, y };
        }
        hasValue() {
          return isNumber(this.x) && isNumber(this.y);
        }
        getProps(props, final) {
          const anims = this.$animations;
          if (!final || !anims) return this;
          const ret = {};
          return (
            props.forEach((prop) => {
              ret[prop] =
                anims[prop] && anims[prop].active()
                  ? anims[prop]._to
                  : this[prop];
            }),
            ret
          );
        }
      }
      function autoSkip(scale, ticks) {
        const tickOpts = scale.options.ticks,
          determinedMaxTicks = (function determineMaxTicks(scale) {
            const offset = scale.options.offset,
              tickLength = scale._tickSize(),
              maxScale = scale._length / tickLength + (offset ? 0 : 1),
              maxChart = scale._maxLength / tickLength;
            return Math.floor(Math.min(maxScale, maxChart));
          })(scale),
          ticksLimit = Math.min(
            tickOpts.maxTicksLimit || determinedMaxTicks,
            determinedMaxTicks
          ),
          majorIndices = tickOpts.major.enabled
            ? (function getMajorIndices(ticks) {
                const result = [];
                let i, ilen;
                for (i = 0, ilen = ticks.length; i < ilen; i++)
                  ticks[i].major && result.push(i);
                return result;
              })(ticks)
            : [],
          numMajorIndices = majorIndices.length,
          first = majorIndices[0],
          last = majorIndices[numMajorIndices - 1],
          newTicks = [];
        if (numMajorIndices > ticksLimit)
          return (
            (function skipMajors(ticks, newTicks, majorIndices, spacing) {
              let i,
                count = 0,
                next = majorIndices[0];
              for (spacing = Math.ceil(spacing), i = 0; i < ticks.length; i++)
                i === next &&
                  (newTicks.push(ticks[i]),
                  count++,
                  (next = majorIndices[count * spacing]));
            })(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit),
            newTicks
          );
        const spacing = (function calculateSpacing(
          majorIndices,
          ticks,
          ticksLimit
        ) {
          const evenMajorSpacing = (function getEvenSpacing(arr) {
              const len = arr.length;
              let i, diff;
              if (len < 2) return !1;
              for (diff = arr[0], i = 1; i < len; ++i)
                if (arr[i] - arr[i - 1] !== diff) return !1;
              return diff;
            })(majorIndices),
            spacing = ticks.length / ticksLimit;
          if (!evenMajorSpacing) return Math.max(spacing, 1);
          const factors = (function _factorize(value) {
            const result = [],
              sqrt = Math.sqrt(value);
            let i;
            for (i = 1; i < sqrt; i++)
              value % i == 0 && (result.push(i), result.push(value / i));
            return (
              sqrt === (0 | sqrt) && result.push(sqrt),
              result.sort((a, b) => a - b).pop(),
              result
            );
          })(evenMajorSpacing);
          for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
            const factor = factors[i];
            if (factor > spacing) return factor;
          }
          return Math.max(spacing, 1);
        })(majorIndices, ticks, ticksLimit);
        if (numMajorIndices > 0) {
          let i, ilen;
          const avgMajorSpacing =
            numMajorIndices > 1
              ? Math.round((last - first) / (numMajorIndices - 1))
              : null;
          for (
            skip(
              ticks,
              newTicks,
              spacing,
              isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing,
              first
            ),
              i = 0,
              ilen = numMajorIndices - 1;
            i < ilen;
            i++
          )
            skip(
              ticks,
              newTicks,
              spacing,
              majorIndices[i],
              majorIndices[i + 1]
            );
          return (
            skip(
              ticks,
              newTicks,
              spacing,
              last,
              isNullOrUndef(avgMajorSpacing)
                ? ticks.length
                : last + avgMajorSpacing
            ),
            newTicks
          );
        }
        return skip(ticks, newTicks, spacing), newTicks;
      }
      function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
        const start = valueOrDefault(majorStart, 0),
          end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
        let length,
          i,
          next,
          count = 0;
        for (
          spacing = Math.ceil(spacing),
            majorEnd &&
              ((length = majorEnd - majorStart),
              (spacing = length / Math.floor(length / spacing))),
            next = start;
          next < 0;

        )
          count++, (next = Math.round(start + count * spacing));
        for (i = Math.max(start, 0); i < end; i++)
          i === next &&
            (newTicks.push(ticks[i]),
            count++,
            (next = Math.round(start + count * spacing)));
      }
      const reverseAlign = (align) =>
          'left' === align ? 'right' : 'right' === align ? 'left' : align,
        offsetFromEdge = (scale, edge, offset) =>
          'top' === edge || 'left' === edge
            ? scale[edge] + offset
            : scale[edge] - offset;
      function sample(arr, numItems) {
        const result = [],
          increment = arr.length / numItems,
          len = arr.length;
        let i = 0;
        for (; i < len; i += increment) result.push(arr[Math.floor(i)]);
        return result;
      }
      function getPixelForGridLine(scale, index, offsetGridLines) {
        const length = scale.ticks.length,
          validIndex = Math.min(index, length - 1),
          start = scale._startPixel,
          end = scale._endPixel;
        let offset,
          lineValue = scale.getPixelForTick(validIndex);
        if (
          !(
            offsetGridLines &&
            ((offset =
              1 === length
                ? Math.max(lineValue - start, end - lineValue)
                : 0 === index
                ? (scale.getPixelForTick(1) - lineValue) / 2
                : (lineValue - scale.getPixelForTick(validIndex - 1)) / 2),
            (lineValue += validIndex < index ? offset : -offset),
            lineValue < start - 1e-6 || lineValue > end + 1e-6)
          )
        )
          return lineValue;
      }
      function getTickMarkLength(options) {
        return options.drawTicks ? options.tickLength : 0;
      }
      function getTitleHeight(options, fallback) {
        if (!options.display) return 0;
        const font = toFont(options.font, fallback),
          padding = toPadding(options.padding);
        return (
          (isArray(options.text) ? options.text.length : 1) * font.lineHeight +
          padding.height
        );
      }
      function titleAlign(align, position, reverse) {
        let ret = _toLeftRightCenter(align);
        return (
          ((reverse && 'right' !== position) ||
            (!reverse && 'right' === position)) &&
            (ret = reverseAlign(ret)),
          ret
        );
      }
      class Scale extends Element {
        constructor(cfg) {
          super(),
            (this.id = cfg.id),
            (this.type = cfg.type),
            (this.options = void 0),
            (this.ctx = cfg.ctx),
            (this.chart = cfg.chart),
            (this.top = void 0),
            (this.bottom = void 0),
            (this.left = void 0),
            (this.right = void 0),
            (this.width = void 0),
            (this.height = void 0),
            (this._margins = { left: 0, right: 0, top: 0, bottom: 0 }),
            (this.maxWidth = void 0),
            (this.maxHeight = void 0),
            (this.paddingTop = void 0),
            (this.paddingBottom = void 0),
            (this.paddingLeft = void 0),
            (this.paddingRight = void 0),
            (this.axis = void 0),
            (this.labelRotation = void 0),
            (this.min = void 0),
            (this.max = void 0),
            (this._range = void 0),
            (this.ticks = []),
            (this._gridLineItems = null),
            (this._labelItems = null),
            (this._labelSizes = null),
            (this._length = 0),
            (this._maxLength = 0),
            (this._longestTextCache = {}),
            (this._startPixel = void 0),
            (this._endPixel = void 0),
            (this._reversePixels = !1),
            (this._userMax = void 0),
            (this._userMin = void 0),
            (this._suggestedMax = void 0),
            (this._suggestedMin = void 0),
            (this._ticksLength = 0),
            (this._borderValue = 0),
            (this._cache = {}),
            (this._dataLimitsCached = !1),
            (this.$context = void 0);
        }
        init(options) {
          (this.options = options.setContext(this.getContext())),
            (this.axis = options.axis),
            (this._userMin = this.parse(options.min)),
            (this._userMax = this.parse(options.max)),
            (this._suggestedMin = this.parse(options.suggestedMin)),
            (this._suggestedMax = this.parse(options.suggestedMax));
        }
        parse(raw, index) {
          return raw;
        }
        getUserBounds() {
          let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
          return (
            (_userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY)),
            (_userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY)),
            (_suggestedMin = finiteOrDefault(
              _suggestedMin,
              Number.POSITIVE_INFINITY
            )),
            (_suggestedMax = finiteOrDefault(
              _suggestedMax,
              Number.NEGATIVE_INFINITY
            )),
            {
              min: finiteOrDefault(_userMin, _suggestedMin),
              max: finiteOrDefault(_userMax, _suggestedMax),
              minDefined: isNumberFinite(_userMin),
              maxDefined: isNumberFinite(_userMax),
            }
          );
        }
        getMinMax(canStack) {
          let range,
            { min, max, minDefined, maxDefined } = this.getUserBounds();
          if (minDefined && maxDefined) return { min, max };
          const metas = this.getMatchingVisibleMetas();
          for (let i = 0, ilen = metas.length; i < ilen; ++i)
            (range = metas[i].controller.getMinMax(this, canStack)),
              minDefined || (min = Math.min(min, range.min)),
              maxDefined || (max = Math.max(max, range.max));
          return (
            (min = maxDefined && min > max ? max : min),
            (max = minDefined && min > max ? min : max),
            {
              min: finiteOrDefault(min, finiteOrDefault(max, min)),
              max: finiteOrDefault(max, finiteOrDefault(min, max)),
            }
          );
        }
        getPadding() {
          return {
            left: this.paddingLeft || 0,
            top: this.paddingTop || 0,
            right: this.paddingRight || 0,
            bottom: this.paddingBottom || 0,
          };
        }
        getTicks() {
          return this.ticks;
        }
        getLabels() {
          const data = this.chart.data;
          return (
            this.options.labels ||
            (this.isHorizontal() ? data.xLabels : data.yLabels) ||
            data.labels ||
            []
          );
        }
        getLabelItems(chartArea = this.chart.chartArea) {
          return (
            this._labelItems ||
            (this._labelItems = this._computeLabelItems(chartArea))
          );
        }
        beforeLayout() {
          (this._cache = {}), (this._dataLimitsCached = !1);
        }
        beforeUpdate() {
          callback(this.options.beforeUpdate, [this]);
        }
        update(maxWidth, maxHeight, margins) {
          const { beginAtZero, grace, ticks: tickOpts } = this.options,
            sampleSize = tickOpts.sampleSize;
          this.beforeUpdate(),
            (this.maxWidth = maxWidth),
            (this.maxHeight = maxHeight),
            (this._margins = margins =
              Object.assign({ left: 0, right: 0, top: 0, bottom: 0 }, margins)),
            (this.ticks = null),
            (this._labelSizes = null),
            (this._gridLineItems = null),
            (this._labelItems = null),
            this.beforeSetDimensions(),
            this.setDimensions(),
            this.afterSetDimensions(),
            (this._maxLength = this.isHorizontal()
              ? this.width + margins.left + margins.right
              : this.height + margins.top + margins.bottom),
            this._dataLimitsCached ||
              (this.beforeDataLimits(),
              this.determineDataLimits(),
              this.afterDataLimits(),
              (this._range = (function _addGrace(minmax, grace, beginAtZero) {
                const { min, max } = minmax,
                  change = toDimension(grace, (max - min) / 2),
                  keepZero = (value, add) =>
                    beginAtZero && 0 === value ? 0 : value + add;
                return {
                  min: keepZero(min, -Math.abs(change)),
                  max: keepZero(max, change),
                };
              })(this, grace, beginAtZero)),
              (this._dataLimitsCached = !0)),
            this.beforeBuildTicks(),
            (this.ticks = this.buildTicks() || []),
            this.afterBuildTicks();
          const samplingEnabled = sampleSize < this.ticks.length;
          this._convertTicksToLabels(
            samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks
          ),
            this.configure(),
            this.beforeCalculateLabelRotation(),
            this.calculateLabelRotation(),
            this.afterCalculateLabelRotation(),
            tickOpts.display &&
              (tickOpts.autoSkip || 'auto' === tickOpts.source) &&
              ((this.ticks = autoSkip(this, this.ticks)),
              (this._labelSizes = null),
              this.afterAutoSkip()),
            samplingEnabled && this._convertTicksToLabels(this.ticks),
            this.beforeFit(),
            this.fit(),
            this.afterFit(),
            this.afterUpdate();
        }
        configure() {
          let startPixel,
            endPixel,
            reversePixels = this.options.reverse;
          this.isHorizontal()
            ? ((startPixel = this.left), (endPixel = this.right))
            : ((startPixel = this.top),
              (endPixel = this.bottom),
              (reversePixels = !reversePixels)),
            (this._startPixel = startPixel),
            (this._endPixel = endPixel),
            (this._reversePixels = reversePixels),
            (this._length = endPixel - startPixel),
            (this._alignToPixels = this.options.alignToPixels);
        }
        afterUpdate() {
          callback(this.options.afterUpdate, [this]);
        }
        beforeSetDimensions() {
          callback(this.options.beforeSetDimensions, [this]);
        }
        setDimensions() {
          this.isHorizontal()
            ? ((this.width = this.maxWidth),
              (this.left = 0),
              (this.right = this.width))
            : ((this.height = this.maxHeight),
              (this.top = 0),
              (this.bottom = this.height)),
            (this.paddingLeft = 0),
            (this.paddingTop = 0),
            (this.paddingRight = 0),
            (this.paddingBottom = 0);
        }
        afterSetDimensions() {
          callback(this.options.afterSetDimensions, [this]);
        }
        _callHooks(name) {
          this.chart.notifyPlugins(name, this.getContext()),
            callback(this.options[name], [this]);
        }
        beforeDataLimits() {
          this._callHooks('beforeDataLimits');
        }
        determineDataLimits() {}
        afterDataLimits() {
          this._callHooks('afterDataLimits');
        }
        beforeBuildTicks() {
          this._callHooks('beforeBuildTicks');
        }
        buildTicks() {
          return [];
        }
        afterBuildTicks() {
          this._callHooks('afterBuildTicks');
        }
        beforeTickToLabelConversion() {
          callback(this.options.beforeTickToLabelConversion, [this]);
        }
        generateTickLabels(ticks) {
          const tickOpts = this.options.ticks;
          let i, ilen, tick;
          for (i = 0, ilen = ticks.length; i < ilen; i++)
            (tick = ticks[i]),
              (tick.label = callback(
                tickOpts.callback,
                [tick.value, i, ticks],
                this
              ));
        }
        afterTickToLabelConversion() {
          callback(this.options.afterTickToLabelConversion, [this]);
        }
        beforeCalculateLabelRotation() {
          callback(this.options.beforeCalculateLabelRotation, [this]);
        }
        calculateLabelRotation() {
          const options = this.options,
            tickOpts = options.ticks,
            numTicks = this.ticks.length,
            minRotation = tickOpts.minRotation || 0,
            maxRotation = tickOpts.maxRotation;
          let tickWidth,
            maxHeight,
            maxLabelDiagonal,
            labelRotation = minRotation;
          if (
            !this._isVisible() ||
            !tickOpts.display ||
            minRotation >= maxRotation ||
            numTicks <= 1 ||
            !this.isHorizontal()
          )
            return void (this.labelRotation = minRotation);
          const labelSizes = this._getLabelSizes(),
            maxLabelWidth = labelSizes.widest.width,
            maxLabelHeight = labelSizes.highest.height,
            maxWidth = _limitValue(
              this.chart.width - maxLabelWidth,
              0,
              this.maxWidth
            );
          (tickWidth = options.offset
            ? this.maxWidth / numTicks
            : maxWidth / (numTicks - 1)),
            maxLabelWidth + 6 > tickWidth &&
              ((tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1))),
              (maxHeight =
                this.maxHeight -
                getTickMarkLength(options.grid) -
                tickOpts.padding -
                getTitleHeight(options.title, this.chart.options.font)),
              (maxLabelDiagonal = Math.sqrt(
                maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight
              )),
              (labelRotation = toDegrees(
                Math.min(
                  Math.asin(
                    _limitValue(
                      (labelSizes.highest.height + 6) / tickWidth,
                      -1,
                      1
                    )
                  ),
                  Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) -
                    Math.asin(
                      _limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1)
                    )
                )
              )),
              (labelRotation = Math.max(
                minRotation,
                Math.min(maxRotation, labelRotation)
              ))),
            (this.labelRotation = labelRotation);
        }
        afterCalculateLabelRotation() {
          callback(this.options.afterCalculateLabelRotation, [this]);
        }
        afterAutoSkip() {}
        beforeFit() {
          callback(this.options.beforeFit, [this]);
        }
        fit() {
          const minSize = { width: 0, height: 0 },
            {
              chart,
              options: { ticks: tickOpts, title: titleOpts, grid: gridOpts },
            } = this,
            display = this._isVisible(),
            isHorizontal = this.isHorizontal();
          if (display) {
            const titleHeight = getTitleHeight(titleOpts, chart.options.font);
            if (
              (isHorizontal
                ? ((minSize.width = this.maxWidth),
                  (minSize.height = getTickMarkLength(gridOpts) + titleHeight))
                : ((minSize.height = this.maxHeight),
                  (minSize.width = getTickMarkLength(gridOpts) + titleHeight)),
              tickOpts.display && this.ticks.length)
            ) {
              const { first, last, widest, highest } = this._getLabelSizes(),
                tickPadding = 2 * tickOpts.padding,
                angleRadians = toRadians(this.labelRotation),
                cos = Math.cos(angleRadians),
                sin = Math.sin(angleRadians);
              if (isHorizontal) {
                const labelHeight = tickOpts.mirror
                  ? 0
                  : sin * widest.width + cos * highest.height;
                minSize.height = Math.min(
                  this.maxHeight,
                  minSize.height + labelHeight + tickPadding
                );
              } else {
                const labelWidth = tickOpts.mirror
                  ? 0
                  : cos * widest.width + sin * highest.height;
                minSize.width = Math.min(
                  this.maxWidth,
                  minSize.width + labelWidth + tickPadding
                );
              }
              this._calculatePadding(first, last, sin, cos);
            }
          }
          this._handleMargins(),
            isHorizontal
              ? ((this.width = this._length =
                  chart.width - this._margins.left - this._margins.right),
                (this.height = minSize.height))
              : ((this.width = minSize.width),
                (this.height = this._length =
                  chart.height - this._margins.top - this._margins.bottom));
        }
        _calculatePadding(first, last, sin, cos) {
          const {
              ticks: { align, padding },
              position,
            } = this.options,
            isRotated = 0 !== this.labelRotation,
            labelsBelowTicks = 'top' !== position && 'x' === this.axis;
          if (this.isHorizontal()) {
            const offsetLeft = this.getPixelForTick(0) - this.left,
              offsetRight =
                this.right - this.getPixelForTick(this.ticks.length - 1);
            let paddingLeft = 0,
              paddingRight = 0;
            isRotated
              ? labelsBelowTicks
                ? ((paddingLeft = cos * first.width),
                  (paddingRight = sin * last.height))
                : ((paddingLeft = sin * first.height),
                  (paddingRight = cos * last.width))
              : 'start' === align
              ? (paddingRight = last.width)
              : 'end' === align
              ? (paddingLeft = first.width)
              : 'inner' !== align &&
                ((paddingLeft = first.width / 2),
                (paddingRight = last.width / 2)),
              (this.paddingLeft = Math.max(
                ((paddingLeft - offsetLeft + padding) * this.width) /
                  (this.width - offsetLeft),
                0
              )),
              (this.paddingRight = Math.max(
                ((paddingRight - offsetRight + padding) * this.width) /
                  (this.width - offsetRight),
                0
              ));
          } else {
            let paddingTop = last.height / 2,
              paddingBottom = first.height / 2;
            'start' === align
              ? ((paddingTop = 0), (paddingBottom = first.height))
              : 'end' === align &&
                ((paddingTop = last.height), (paddingBottom = 0)),
              (this.paddingTop = paddingTop + padding),
              (this.paddingBottom = paddingBottom + padding);
          }
        }
        _handleMargins() {
          this._margins &&
            ((this._margins.left = Math.max(
              this.paddingLeft,
              this._margins.left
            )),
            (this._margins.top = Math.max(this.paddingTop, this._margins.top)),
            (this._margins.right = Math.max(
              this.paddingRight,
              this._margins.right
            )),
            (this._margins.bottom = Math.max(
              this.paddingBottom,
              this._margins.bottom
            )));
        }
        afterFit() {
          callback(this.options.afterFit, [this]);
        }
        isHorizontal() {
          const { axis, position } = this.options;
          return 'top' === position || 'bottom' === position || 'x' === axis;
        }
        isFullSize() {
          return this.options.fullSize;
        }
        _convertTicksToLabels(ticks) {
          let i, ilen;
          for (
            this.beforeTickToLabelConversion(),
              this.generateTickLabels(ticks),
              i = 0,
              ilen = ticks.length;
            i < ilen;
            i++
          )
            isNullOrUndef(ticks[i].label) && (ticks.splice(i, 1), ilen--, i--);
          this.afterTickToLabelConversion();
        }
        _getLabelSizes() {
          let labelSizes = this._labelSizes;
          if (!labelSizes) {
            const sampleSize = this.options.ticks.sampleSize;
            let ticks = this.ticks;
            sampleSize < ticks.length && (ticks = sample(ticks, sampleSize)),
              (this._labelSizes = labelSizes =
                this._computeLabelSizes(ticks, ticks.length));
          }
          return labelSizes;
        }
        _computeLabelSizes(ticks, length) {
          const { ctx, _longestTextCache: caches } = this,
            widths = [],
            heights = [];
          let i,
            j,
            jlen,
            label,
            tickFont,
            fontString,
            cache,
            lineHeight,
            width,
            height,
            nestedLabel,
            widestLabelSize = 0,
            highestLabelSize = 0;
          for (i = 0; i < length; ++i) {
            if (
              ((label = ticks[i].label),
              (tickFont = this._resolveTickFontOptions(i)),
              (ctx.font = fontString = tickFont.string),
              (cache = caches[fontString] =
                caches[fontString] || { data: {}, gc: [] }),
              (lineHeight = tickFont.lineHeight),
              (width = height = 0),
              isNullOrUndef(label) || isArray(label))
            ) {
              if (isArray(label))
                for (j = 0, jlen = label.length; j < jlen; ++j)
                  (nestedLabel = label[j]),
                    isNullOrUndef(nestedLabel) ||
                      isArray(nestedLabel) ||
                      ((width = _measureText(
                        ctx,
                        cache.data,
                        cache.gc,
                        width,
                        nestedLabel
                      )),
                      (height += lineHeight));
            } else
              (width = _measureText(ctx, cache.data, cache.gc, width, label)),
                (height = lineHeight);
            widths.push(width),
              heights.push(height),
              (widestLabelSize = Math.max(width, widestLabelSize)),
              (highestLabelSize = Math.max(height, highestLabelSize));
          }
          !(function garbageCollect(caches, length) {
            each(caches, (cache) => {
              const gc = cache.gc,
                gcLen = gc.length / 2;
              let i;
              if (gcLen > length) {
                for (i = 0; i < gcLen; ++i) delete cache.data[gc[i]];
                gc.splice(0, gcLen);
              }
            });
          })(caches, length);
          const widest = widths.indexOf(widestLabelSize),
            highest = heights.indexOf(highestLabelSize),
            valueAt = (idx) => ({
              width: widths[idx] || 0,
              height: heights[idx] || 0,
            });
          return {
            first: valueAt(0),
            last: valueAt(length - 1),
            widest: valueAt(widest),
            highest: valueAt(highest),
            widths,
            heights,
          };
        }
        getLabelForValue(value) {
          return value;
        }
        getPixelForValue(value, index) {
          return NaN;
        }
        getValueForPixel(pixel) {}
        getPixelForTick(index) {
          const ticks = this.ticks;
          return index < 0 || index > ticks.length - 1
            ? null
            : this.getPixelForValue(ticks[index].value);
        }
        getPixelForDecimal(decimal) {
          this._reversePixels && (decimal = 1 - decimal);
          const pixel = this._startPixel + decimal * this._length;
          return (function _int16Range(value) {
            return _limitValue(value, -32768, 32767);
          })(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
        }
        getDecimalForPixel(pixel) {
          const decimal = (pixel - this._startPixel) / this._length;
          return this._reversePixels ? 1 - decimal : decimal;
        }
        getBasePixel() {
          return this.getPixelForValue(this.getBaseValue());
        }
        getBaseValue() {
          const { min, max } = this;
          return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
        }
        getContext(index) {
          const ticks = this.ticks || [];
          if (index >= 0 && index < ticks.length) {
            const tick = ticks[index];
            return (
              tick.$context ||
              (tick.$context = (function createTickContext(
                parent,
                index,
                tick
              ) {
                return createContext(parent, { tick, index, type: 'tick' });
              })(this.getContext(), index, tick))
            );
          }
          return (
            this.$context ||
            (this.$context = (function createScaleContext(parent, scale) {
              return createContext(parent, { scale, type: 'scale' });
            })(this.chart.getContext(), this))
          );
        }
        _tickSize() {
          const optionTicks = this.options.ticks,
            rot = toRadians(this.labelRotation),
            cos = Math.abs(Math.cos(rot)),
            sin = Math.abs(Math.sin(rot)),
            labelSizes = this._getLabelSizes(),
            padding = optionTicks.autoSkipPadding || 0,
            w = labelSizes ? labelSizes.widest.width + padding : 0,
            h = labelSizes ? labelSizes.highest.height + padding : 0;
          return this.isHorizontal()
            ? h * cos > w * sin
              ? w / cos
              : h / sin
            : h * sin < w * cos
            ? h / cos
            : w / sin;
        }
        _isVisible() {
          const display = this.options.display;
          return 'auto' !== display
            ? !!display
            : this.getMatchingVisibleMetas().length > 0;
        }
        _computeGridLineItems(chartArea) {
          const axis = this.axis,
            chart = this.chart,
            options = this.options,
            { grid, position, border } = options,
            offset = grid.offset,
            isHorizontal = this.isHorizontal(),
            ticksLength = this.ticks.length + (offset ? 1 : 0),
            tl = getTickMarkLength(grid),
            items = [],
            borderOpts = border.setContext(this.getContext()),
            axisWidth = borderOpts.display ? borderOpts.width : 0,
            axisHalfWidth = axisWidth / 2,
            alignBorderValue = function (pixel) {
              return _alignPixel(chart, pixel, axisWidth);
            };
          let borderValue,
            i,
            lineValue,
            alignedLineValue,
            tx1,
            ty1,
            tx2,
            ty2,
            x1,
            y1,
            x2,
            y2;
          if ('top' === position)
            (borderValue = alignBorderValue(this.bottom)),
              (ty1 = this.bottom - tl),
              (ty2 = borderValue - axisHalfWidth),
              (y1 = alignBorderValue(chartArea.top) + axisHalfWidth),
              (y2 = chartArea.bottom);
          else if ('bottom' === position)
            (borderValue = alignBorderValue(this.top)),
              (y1 = chartArea.top),
              (y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth),
              (ty1 = borderValue + axisHalfWidth),
              (ty2 = this.top + tl);
          else if ('left' === position)
            (borderValue = alignBorderValue(this.right)),
              (tx1 = this.right - tl),
              (tx2 = borderValue - axisHalfWidth),
              (x1 = alignBorderValue(chartArea.left) + axisHalfWidth),
              (x2 = chartArea.right);
          else if ('right' === position)
            (borderValue = alignBorderValue(this.left)),
              (x1 = chartArea.left),
              (x2 = alignBorderValue(chartArea.right) - axisHalfWidth),
              (tx1 = borderValue + axisHalfWidth),
              (tx2 = this.left + tl);
          else if ('x' === axis) {
            if ('center' === position)
              borderValue = alignBorderValue(
                (chartArea.top + chartArea.bottom) / 2 + 0.5
              );
            else if (isObject(position)) {
              const positionAxisID = Object.keys(position)[0],
                value = position[positionAxisID];
              borderValue = alignBorderValue(
                this.chart.scales[positionAxisID].getPixelForValue(value)
              );
            }
            (y1 = chartArea.top),
              (y2 = chartArea.bottom),
              (ty1 = borderValue + axisHalfWidth),
              (ty2 = ty1 + tl);
          } else if ('y' === axis) {
            if ('center' === position)
              borderValue = alignBorderValue(
                (chartArea.left + chartArea.right) / 2
              );
            else if (isObject(position)) {
              const positionAxisID1 = Object.keys(position)[0],
                value1 = position[positionAxisID1];
              borderValue = alignBorderValue(
                this.chart.scales[positionAxisID1].getPixelForValue(value1)
              );
            }
            (tx1 = borderValue - axisHalfWidth),
              (tx2 = tx1 - tl),
              (x1 = chartArea.left),
              (x2 = chartArea.right);
          }
          const limit = valueOrDefault(
              options.ticks.maxTicksLimit,
              ticksLength
            ),
            step = Math.max(1, Math.ceil(ticksLength / limit));
          for (i = 0; i < ticksLength; i += step) {
            const context = this.getContext(i),
              optsAtIndex = grid.setContext(context),
              optsAtIndexBorder = border.setContext(context),
              lineWidth = optsAtIndex.lineWidth,
              lineColor = optsAtIndex.color,
              borderDash = optsAtIndexBorder.dash || [],
              borderDashOffset = optsAtIndexBorder.dashOffset,
              tickWidth = optsAtIndex.tickWidth,
              tickColor = optsAtIndex.tickColor,
              tickBorderDash = optsAtIndex.tickBorderDash || [],
              tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
            (lineValue = getPixelForGridLine(this, i, offset)),
              void 0 !== lineValue &&
                ((alignedLineValue = _alignPixel(chart, lineValue, lineWidth)),
                isHorizontal
                  ? (tx1 = tx2 = x1 = x2 = alignedLineValue)
                  : (ty1 = ty2 = y1 = y2 = alignedLineValue),
                items.push({
                  tx1,
                  ty1,
                  tx2,
                  ty2,
                  x1,
                  y1,
                  x2,
                  y2,
                  width: lineWidth,
                  color: lineColor,
                  borderDash,
                  borderDashOffset,
                  tickWidth,
                  tickColor,
                  tickBorderDash,
                  tickBorderDashOffset,
                }));
          }
          return (
            (this._ticksLength = ticksLength),
            (this._borderValue = borderValue),
            items
          );
        }
        _computeLabelItems(chartArea) {
          const axis = this.axis,
            options = this.options,
            { position, ticks: optionTicks } = options,
            isHorizontal = this.isHorizontal(),
            ticks = this.ticks,
            { align, crossAlign, padding, mirror } = optionTicks,
            tl = getTickMarkLength(options.grid),
            tickAndPadding = tl + padding,
            hTickAndPadding = mirror ? -padding : tickAndPadding,
            rotation = -toRadians(this.labelRotation),
            items = [];
          let i,
            ilen,
            tick,
            label,
            x,
            y,
            textAlign,
            pixel,
            font,
            lineHeight,
            lineCount,
            textOffset,
            textBaseline = 'middle';
          if ('top' === position)
            (y = this.bottom - hTickAndPadding),
              (textAlign = this._getXAxisLabelAlignment());
          else if ('bottom' === position)
            (y = this.top + hTickAndPadding),
              (textAlign = this._getXAxisLabelAlignment());
          else if ('left' === position) {
            const ret = this._getYAxisLabelAlignment(tl);
            (textAlign = ret.textAlign), (x = ret.x);
          } else if ('right' === position) {
            const ret1 = this._getYAxisLabelAlignment(tl);
            (textAlign = ret1.textAlign), (x = ret1.x);
          } else if ('x' === axis) {
            if ('center' === position)
              y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
            else if (isObject(position)) {
              const positionAxisID = Object.keys(position)[0],
                value = position[positionAxisID];
              y =
                this.chart.scales[positionAxisID].getPixelForValue(value) +
                tickAndPadding;
            }
            textAlign = this._getXAxisLabelAlignment();
          } else if ('y' === axis) {
            if ('center' === position)
              x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
            else if (isObject(position)) {
              const positionAxisID1 = Object.keys(position)[0],
                value1 = position[positionAxisID1];
              x = this.chart.scales[positionAxisID1].getPixelForValue(value1);
            }
            textAlign = this._getYAxisLabelAlignment(tl).textAlign;
          }
          'y' === axis &&
            ('start' === align
              ? (textBaseline = 'top')
              : 'end' === align && (textBaseline = 'bottom'));
          const labelSizes = this._getLabelSizes();
          for (i = 0, ilen = ticks.length; i < ilen; ++i) {
            (tick = ticks[i]), (label = tick.label);
            const optsAtIndex = optionTicks.setContext(this.getContext(i));
            (pixel = this.getPixelForTick(i) + optionTicks.labelOffset),
              (font = this._resolveTickFontOptions(i)),
              (lineHeight = font.lineHeight),
              (lineCount = isArray(label) ? label.length : 1);
            const halfCount = lineCount / 2,
              color = optsAtIndex.color,
              strokeColor = optsAtIndex.textStrokeColor,
              strokeWidth = optsAtIndex.textStrokeWidth;
            let backdrop,
              tickTextAlign = textAlign;
            if (
              (isHorizontal
                ? ((x = pixel),
                  'inner' === textAlign &&
                    (tickTextAlign =
                      i === ilen - 1
                        ? this.options.reverse
                          ? 'left'
                          : 'right'
                        : 0 === i
                        ? this.options.reverse
                          ? 'right'
                          : 'left'
                        : 'center'),
                  (textOffset =
                    'top' === position
                      ? 'near' === crossAlign || 0 !== rotation
                        ? -lineCount * lineHeight + lineHeight / 2
                        : 'center' === crossAlign
                        ? -labelSizes.highest.height / 2 -
                          halfCount * lineHeight +
                          lineHeight
                        : -labelSizes.highest.height + lineHeight / 2
                      : 'near' === crossAlign || 0 !== rotation
                      ? lineHeight / 2
                      : 'center' === crossAlign
                      ? labelSizes.highest.height / 2 - halfCount * lineHeight
                      : labelSizes.highest.height - lineCount * lineHeight),
                  mirror && (textOffset *= -1),
                  0 === rotation ||
                    optsAtIndex.showLabelBackdrop ||
                    (x += (lineHeight / 2) * Math.sin(rotation)))
                : ((y = pixel),
                  (textOffset = ((1 - lineCount) * lineHeight) / 2)),
              optsAtIndex.showLabelBackdrop)
            ) {
              const labelPadding = toPadding(optsAtIndex.backdropPadding),
                height = labelSizes.heights[i],
                width = labelSizes.widths[i];
              let top = textOffset - labelPadding.top,
                left = 0 - labelPadding.left;
              switch (textBaseline) {
                case 'middle':
                  top -= height / 2;
                  break;
                case 'bottom':
                  top -= height;
              }
              switch (textAlign) {
                case 'center':
                  left -= width / 2;
                  break;
                case 'right':
                  left -= width;
              }
              backdrop = {
                left,
                top,
                width: width + labelPadding.width,
                height: height + labelPadding.height,
                color: optsAtIndex.backdropColor,
              };
            }
            items.push({
              label,
              font,
              textOffset,
              options: {
                rotation,
                color,
                strokeColor,
                strokeWidth,
                textAlign: tickTextAlign,
                textBaseline,
                translation: [x, y],
                backdrop,
              },
            });
          }
          return items;
        }
        _getXAxisLabelAlignment() {
          const { position, ticks } = this.options;
          if (-toRadians(this.labelRotation))
            return 'top' === position ? 'left' : 'right';
          let align = 'center';
          return (
            'start' === ticks.align
              ? (align = 'left')
              : 'end' === ticks.align
              ? (align = 'right')
              : 'inner' === ticks.align && (align = 'inner'),
            align
          );
        }
        _getYAxisLabelAlignment(tl) {
          const {
              position,
              ticks: { crossAlign, mirror, padding },
            } = this.options,
            tickAndPadding = tl + padding,
            widest = this._getLabelSizes().widest.width;
          let textAlign, x;
          return (
            'left' === position
              ? mirror
                ? ((x = this.right + padding),
                  'near' === crossAlign
                    ? (textAlign = 'left')
                    : 'center' === crossAlign
                    ? ((textAlign = 'center'), (x += widest / 2))
                    : ((textAlign = 'right'), (x += widest)))
                : ((x = this.right - tickAndPadding),
                  'near' === crossAlign
                    ? (textAlign = 'right')
                    : 'center' === crossAlign
                    ? ((textAlign = 'center'), (x -= widest / 2))
                    : ((textAlign = 'left'), (x = this.left)))
              : 'right' === position
              ? mirror
                ? ((x = this.left + padding),
                  'near' === crossAlign
                    ? (textAlign = 'right')
                    : 'center' === crossAlign
                    ? ((textAlign = 'center'), (x -= widest / 2))
                    : ((textAlign = 'left'), (x -= widest)))
                : ((x = this.left + tickAndPadding),
                  'near' === crossAlign
                    ? (textAlign = 'left')
                    : 'center' === crossAlign
                    ? ((textAlign = 'center'), (x += widest / 2))
                    : ((textAlign = 'right'), (x = this.right)))
              : (textAlign = 'right'),
            { textAlign, x }
          );
        }
        _computeLabelArea() {
          if (this.options.ticks.mirror) return;
          const chart = this.chart,
            position = this.options.position;
          return 'left' === position || 'right' === position
            ? {
                top: 0,
                left: this.left,
                bottom: chart.height,
                right: this.right,
              }
            : 'top' === position || 'bottom' === position
            ? {
                top: this.top,
                left: 0,
                bottom: this.bottom,
                right: chart.width,
              }
            : void 0;
        }
        drawBackground() {
          const {
            ctx,
            options: { backgroundColor },
            left,
            top,
            width,
            height,
          } = this;
          backgroundColor &&
            (ctx.save(),
            (ctx.fillStyle = backgroundColor),
            ctx.fillRect(left, top, width, height),
            ctx.restore());
        }
        getLineWidthForValue(value) {
          const grid = this.options.grid;
          if (!this._isVisible() || !grid.display) return 0;
          const index = this.ticks.findIndex((t) => t.value === value);
          if (index >= 0) {
            return grid.setContext(this.getContext(index)).lineWidth;
          }
          return 0;
        }
        drawGrid(chartArea) {
          const grid = this.options.grid,
            ctx = this.ctx,
            items =
              this._gridLineItems ||
              (this._gridLineItems = this._computeGridLineItems(chartArea));
          let i, ilen;
          const drawLine = (p1, p2, style) => {
            style.width &&
              style.color &&
              (ctx.save(),
              (ctx.lineWidth = style.width),
              (ctx.strokeStyle = style.color),
              ctx.setLineDash(style.borderDash || []),
              (ctx.lineDashOffset = style.borderDashOffset),
              ctx.beginPath(),
              ctx.moveTo(p1.x, p1.y),
              ctx.lineTo(p2.x, p2.y),
              ctx.stroke(),
              ctx.restore());
          };
          if (grid.display)
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              const item = items[i];
              grid.drawOnChartArea &&
                drawLine(
                  { x: item.x1, y: item.y1 },
                  { x: item.x2, y: item.y2 },
                  item
                ),
                grid.drawTicks &&
                  drawLine(
                    { x: item.tx1, y: item.ty1 },
                    { x: item.tx2, y: item.ty2 },
                    {
                      color: item.tickColor,
                      width: item.tickWidth,
                      borderDash: item.tickBorderDash,
                      borderDashOffset: item.tickBorderDashOffset,
                    }
                  );
            }
        }
        drawBorder() {
          const {
              chart,
              ctx,
              options: { border, grid },
            } = this,
            borderOpts = border.setContext(this.getContext()),
            axisWidth = border.display ? borderOpts.width : 0;
          if (!axisWidth) return;
          const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth,
            borderValue = this._borderValue;
          let x1, x2, y1, y2;
          this.isHorizontal()
            ? ((x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2),
              (x2 =
                _alignPixel(chart, this.right, lastLineWidth) +
                lastLineWidth / 2),
              (y1 = y2 = borderValue))
            : ((y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2),
              (y2 =
                _alignPixel(chart, this.bottom, lastLineWidth) +
                lastLineWidth / 2),
              (x1 = x2 = borderValue)),
            ctx.save(),
            (ctx.lineWidth = borderOpts.width),
            (ctx.strokeStyle = borderOpts.color),
            ctx.beginPath(),
            ctx.moveTo(x1, y1),
            ctx.lineTo(x2, y2),
            ctx.stroke(),
            ctx.restore();
        }
        drawLabels(chartArea) {
          if (!this.options.ticks.display) return;
          const ctx = this.ctx,
            area = this._computeLabelArea();
          area && clipArea(ctx, area);
          const items = this.getLabelItems(chartArea);
          for (const item of items) {
            const renderTextOptions = item.options,
              tickFont = item.font;
            renderText(
              ctx,
              item.label,
              0,
              item.textOffset,
              tickFont,
              renderTextOptions
            );
          }
          area && unclipArea(ctx);
        }
        drawTitle() {
          const {
            ctx,
            options: { position, title, reverse },
          } = this;
          if (!title.display) return;
          const font = toFont(title.font),
            padding = toPadding(title.padding),
            align = title.align;
          let offset = font.lineHeight / 2;
          'bottom' === position || 'center' === position || isObject(position)
            ? ((offset += padding.bottom),
              isArray(title.text) &&
                (offset += font.lineHeight * (title.text.length - 1)))
            : (offset += padding.top);
          const { titleX, titleY, maxWidth, rotation } = (function titleArgs(
            scale,
            offset,
            position,
            align
          ) {
            const { top, left, bottom, right, chart } = scale,
              { chartArea, scales } = chart;
            let maxWidth,
              titleX,
              titleY,
              rotation = 0;
            const height = bottom - top,
              width = right - left;
            if (scale.isHorizontal()) {
              if (
                ((titleX = _alignStartEnd(align, left, right)),
                isObject(position))
              ) {
                const positionAxisID = Object.keys(position)[0],
                  value = position[positionAxisID];
                titleY =
                  scales[positionAxisID].getPixelForValue(value) +
                  height -
                  offset;
              } else
                titleY =
                  'center' === position
                    ? (chartArea.bottom + chartArea.top) / 2 + height - offset
                    : offsetFromEdge(scale, position, offset);
              maxWidth = right - left;
            } else {
              if (isObject(position)) {
                const positionAxisID1 = Object.keys(position)[0],
                  value1 = position[positionAxisID1];
                titleX =
                  scales[positionAxisID1].getPixelForValue(value1) -
                  width +
                  offset;
              } else
                titleX =
                  'center' === position
                    ? (chartArea.left + chartArea.right) / 2 - width + offset
                    : offsetFromEdge(scale, position, offset);
              (titleY = _alignStartEnd(align, bottom, top)),
                (rotation = 'left' === position ? -HALF_PI : HALF_PI);
            }
            return { titleX, titleY, maxWidth, rotation };
          })(this, offset, position, align);
          renderText(ctx, title.text, 0, 0, font, {
            color: title.color,
            maxWidth,
            rotation,
            textAlign: titleAlign(align, position, reverse),
            textBaseline: 'middle',
            translation: [titleX, titleY],
          });
        }
        draw(chartArea) {
          this._isVisible() &&
            (this.drawBackground(),
            this.drawGrid(chartArea),
            this.drawBorder(),
            this.drawTitle(),
            this.drawLabels(chartArea));
        }
        _layers() {
          const opts = this.options,
            tz = (opts.ticks && opts.ticks.z) || 0,
            gz = valueOrDefault(opts.grid && opts.grid.z, -1),
            bz = valueOrDefault(opts.border && opts.border.z, 0);
          return this._isVisible() && this.draw === Scale.prototype.draw
            ? [
                {
                  z: gz,
                  draw: (chartArea) => {
                    this.drawBackground(),
                      this.drawGrid(chartArea),
                      this.drawTitle();
                  },
                },
                {
                  z: bz,
                  draw: () => {
                    this.drawBorder();
                  },
                },
                {
                  z: tz,
                  draw: (chartArea) => {
                    this.drawLabels(chartArea);
                  },
                },
              ]
            : [
                {
                  z: tz,
                  draw: (chartArea) => {
                    this.draw(chartArea);
                  },
                },
              ];
        }
        getMatchingVisibleMetas(type) {
          const metas = this.chart.getSortedVisibleDatasetMetas(),
            axisID = this.axis + 'AxisID',
            result = [];
          let i, ilen;
          for (i = 0, ilen = metas.length; i < ilen; ++i) {
            const meta = metas[i];
            meta[axisID] !== this.id ||
              (type && meta.type !== type) ||
              result.push(meta);
          }
          return result;
        }
        _resolveTickFontOptions(index) {
          return toFont(
            this.options.ticks.setContext(this.getContext(index)).font
          );
        }
        _maxDigits() {
          const fontSize = this._resolveTickFontOptions(0).lineHeight;
          return (this.isHorizontal() ? this.width : this.height) / fontSize;
        }
      }
      class TypedRegistry {
        constructor(type, scope, override) {
          (this.type = type),
            (this.scope = scope),
            (this.override = override),
            (this.items = Object.create(null));
        }
        isForType(type) {
          return Object.prototype.isPrototypeOf.call(
            this.type.prototype,
            type.prototype
          );
        }
        register(item) {
          const proto = Object.getPrototypeOf(item);
          let parentScope;
          (function isIChartComponent(proto) {
            return 'id' in proto && 'defaults' in proto;
          })(proto) && (parentScope = this.register(proto));
          const items = this.items,
            id = item.id,
            scope = this.scope + '.' + id;
          if (!id) throw new Error('class does not have id: ' + item);
          return (
            id in items ||
              ((items[id] = item),
              (function registerDefaults(item, scope, parentScope) {
                const itemDefaults = merge(Object.create(null), [
                  parentScope ? defaults.get(parentScope) : {},
                  defaults.get(scope),
                  item.defaults,
                ]);
                defaults.set(scope, itemDefaults),
                  item.defaultRoutes &&
                    (function routeDefaults(scope, routes) {
                      Object.keys(routes).forEach((property) => {
                        const propertyParts = property.split('.'),
                          sourceName = propertyParts.pop(),
                          sourceScope = [scope].concat(propertyParts).join('.'),
                          parts = routes[property].split('.'),
                          targetName = parts.pop(),
                          targetScope = parts.join('.');
                        defaults.route(
                          sourceScope,
                          sourceName,
                          targetScope,
                          targetName
                        );
                      });
                    })(scope, item.defaultRoutes);
                item.descriptors && defaults.describe(scope, item.descriptors);
              })(item, scope, parentScope),
              this.override && defaults.override(item.id, item.overrides)),
            scope
          );
        }
        get(id) {
          return this.items[id];
        }
        unregister(item) {
          const items = this.items,
            id = item.id,
            scope = this.scope;
          id in items && delete items[id],
            scope &&
              id in defaults[scope] &&
              (delete defaults[scope][id],
              this.override && delete overrides[id]);
        }
      }
      class Registry {
        constructor() {
          (this.controllers = new TypedRegistry(
            DatasetController,
            'datasets',
            !0
          )),
            (this.elements = new TypedRegistry(Element, 'elements')),
            (this.plugins = new TypedRegistry(Object, 'plugins')),
            (this.scales = new TypedRegistry(Scale, 'scales')),
            (this._typedRegistries = [
              this.controllers,
              this.scales,
              this.elements,
            ]);
        }
        add(...args) {
          this._each('register', args);
        }
        remove(...args) {
          this._each('unregister', args);
        }
        addControllers(...args) {
          this._each('register', args, this.controllers);
        }
        addElements(...args) {
          this._each('register', args, this.elements);
        }
        addPlugins(...args) {
          this._each('register', args, this.plugins);
        }
        addScales(...args) {
          this._each('register', args, this.scales);
        }
        getController(id) {
          return this._get(id, this.controllers, 'controller');
        }
        getElement(id) {
          return this._get(id, this.elements, 'element');
        }
        getPlugin(id) {
          return this._get(id, this.plugins, 'plugin');
        }
        getScale(id) {
          return this._get(id, this.scales, 'scale');
        }
        removeControllers(...args) {
          this._each('unregister', args, this.controllers);
        }
        removeElements(...args) {
          this._each('unregister', args, this.elements);
        }
        removePlugins(...args) {
          this._each('unregister', args, this.plugins);
        }
        removeScales(...args) {
          this._each('unregister', args, this.scales);
        }
        _each(method, args, typedRegistry) {
          [...args].forEach((arg) => {
            const reg = typedRegistry || this._getRegistryForType(arg);
            typedRegistry ||
            reg.isForType(arg) ||
            (reg === this.plugins && arg.id)
              ? this._exec(method, reg, arg)
              : each(arg, (item) => {
                  const itemReg =
                    typedRegistry || this._getRegistryForType(item);
                  this._exec(method, itemReg, item);
                });
          });
        }
        _exec(method, registry, component) {
          const camelMethod = _capitalize(method);
          callback(component['before' + camelMethod], [], component),
            registry[method](component),
            callback(component['after' + camelMethod], [], component);
        }
        _getRegistryForType(type) {
          for (let i = 0; i < this._typedRegistries.length; i++) {
            const reg = this._typedRegistries[i];
            if (reg.isForType(type)) return reg;
          }
          return this.plugins;
        }
        _get(id, typedRegistry, type) {
          const item = typedRegistry.get(id);
          if (void 0 === item)
            throw new Error('"' + id + '" is not a registered ' + type + '.');
          return item;
        }
      }
      var registry = new Registry();
      class PluginService {
        constructor() {
          this._init = [];
        }
        notify(chart, hook, args, filter) {
          'beforeInit' === hook &&
            ((this._init = this._createDescriptors(chart, !0)),
            this._notify(this._init, chart, 'install'));
          const descriptors = filter
              ? this._descriptors(chart).filter(filter)
              : this._descriptors(chart),
            result = this._notify(descriptors, chart, hook, args);
          return (
            'afterDestroy' === hook &&
              (this._notify(descriptors, chart, 'stop'),
              this._notify(this._init, chart, 'uninstall')),
            result
          );
        }
        _notify(descriptors, chart, hook, args) {
          args = args || {};
          for (const descriptor of descriptors) {
            const plugin = descriptor.plugin;
            if (
              !1 ===
                callback(
                  plugin[hook],
                  [chart, args, descriptor.options],
                  plugin
                ) &&
              args.cancelable
            )
              return !1;
          }
          return !0;
        }
        invalidate() {
          isNullOrUndef(this._cache) ||
            ((this._oldCache = this._cache), (this._cache = void 0));
        }
        _descriptors(chart) {
          if (this._cache) return this._cache;
          const descriptors = (this._cache = this._createDescriptors(chart));
          return this._notifyStateChanges(chart), descriptors;
        }
        _createDescriptors(chart, all) {
          const config = chart && chart.config,
            options = valueOrDefault(
              config.options && config.options.plugins,
              {}
            ),
            plugins = (function allPlugins(config) {
              const localIds = {},
                plugins = [],
                keys = Object.keys(registry.plugins.items);
              for (let i = 0; i < keys.length; i++)
                plugins.push(registry.getPlugin(keys[i]));
              const local = config.plugins || [];
              for (let i1 = 0; i1 < local.length; i1++) {
                const plugin = local[i1];
                -1 === plugins.indexOf(plugin) &&
                  (plugins.push(plugin), (localIds[plugin.id] = !0));
              }
              return { plugins, localIds };
            })(config);
          return !1 !== options || all
            ? (function createDescriptors(
                chart,
                { plugins, localIds },
                options,
                all
              ) {
                const result = [],
                  context = chart.getContext();
                for (const plugin of plugins) {
                  const id = plugin.id,
                    opts = getOpts(options[id], all);
                  null !== opts &&
                    result.push({
                      plugin,
                      options: pluginOpts(
                        chart.config,
                        { plugin, local: localIds[id] },
                        opts,
                        context
                      ),
                    });
                }
                return result;
              })(chart, plugins, options, all)
            : [];
        }
        _notifyStateChanges(chart) {
          const previousDescriptors = this._oldCache || [],
            descriptors = this._cache,
            diff = (a, b) =>
              a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
          this._notify(diff(previousDescriptors, descriptors), chart, 'stop'),
            this._notify(
              diff(descriptors, previousDescriptors),
              chart,
              'start'
            );
        }
      }
      function getOpts(options, all) {
        return all || !1 !== options ? (!0 === options ? {} : options) : null;
      }
      function pluginOpts(config, { plugin, local }, opts, context) {
        const keys = config.pluginScopeKeys(plugin),
          scopes = config.getOptionScopes(opts, keys);
        return (
          local && plugin.defaults && scopes.push(plugin.defaults),
          config.createResolver(scopes, context, [''], {
            scriptable: !1,
            indexable: !1,
            allKeys: !0,
          })
        );
      }
      function getIndexAxis(type, options) {
        const datasetDefaults = defaults.datasets[type] || {};
        return (
          ((options.datasets || {})[type] || {}).indexAxis ||
          options.indexAxis ||
          datasetDefaults.indexAxis ||
          'x'
        );
      }
      function determineAxis(id, scaleOptions) {
        if ('x' === id || 'y' === id || 'r' === id) return id;
        if (
          (id =
            scaleOptions.axis ||
            (function axisFromPosition(position) {
              return 'top' === position || 'bottom' === position
                ? 'x'
                : 'left' === position || 'right' === position
                ? 'y'
                : void 0;
            })(scaleOptions.position) ||
            (id.length > 1 && determineAxis(id[0].toLowerCase(), scaleOptions)))
        )
          return id;
        throw new Error(
          `Cannot determine type of '${name}' axis. Please provide 'axis' or 'position' option.`
        );
      }
      function initOptions(config) {
        const options = config.options || (config.options = {});
        (options.plugins = valueOrDefault(options.plugins, {})),
          (options.scales = (function mergeScaleConfig(config, options) {
            const chartDefaults = overrides[config.type] || { scales: {} },
              configScales = options.scales || {},
              chartIndexAxis = getIndexAxis(config.type, options),
              scales = Object.create(null);
            return (
              Object.keys(configScales).forEach((id) => {
                const scaleConf = configScales[id];
                if (!isObject(scaleConf))
                  return console.error(
                    `Invalid scale configuration for scale: ${id}`
                  );
                if (scaleConf._proxy)
                  return console.warn(
                    `Ignoring resolver passed as options for scale: ${id}`
                  );
                const axis = determineAxis(id, scaleConf),
                  defaultId = (function getDefaultScaleIDFromAxis(
                    axis,
                    indexAxis
                  ) {
                    return axis === indexAxis ? '_index_' : '_value_';
                  })(axis, chartIndexAxis),
                  defaultScaleOptions = chartDefaults.scales || {};
                scales[id] = mergeIf(Object.create(null), [
                  { axis },
                  scaleConf,
                  defaultScaleOptions[axis],
                  defaultScaleOptions[defaultId],
                ]);
              }),
              config.data.datasets.forEach((dataset) => {
                const type = dataset.type || config.type,
                  indexAxis = dataset.indexAxis || getIndexAxis(type, options),
                  defaultScaleOptions = (overrides[type] || {}).scales || {};
                Object.keys(defaultScaleOptions).forEach((defaultID) => {
                  const axis = (function getAxisFromDefaultScaleID(
                      id,
                      indexAxis
                    ) {
                      let axis = id;
                      return (
                        '_index_' === id
                          ? (axis = indexAxis)
                          : '_value_' === id &&
                            (axis = 'x' === indexAxis ? 'y' : 'x'),
                        axis
                      );
                    })(defaultID, indexAxis),
                    id = dataset[axis + 'AxisID'] || axis;
                  (scales[id] = scales[id] || Object.create(null)),
                    mergeIf(scales[id], [
                      { axis },
                      configScales[id],
                      defaultScaleOptions[defaultID],
                    ]);
                });
              }),
              Object.keys(scales).forEach((key) => {
                const scale = scales[key];
                mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);
              }),
              scales
            );
          })(config, options));
      }
      function initData(data) {
        return (
          ((data = data || {}).datasets = data.datasets || []),
          (data.labels = data.labels || []),
          data
        );
      }
      const keyCache = new Map(),
        keysCached = new Set();
      function cachedKeys(cacheKey, generate) {
        let keys = keyCache.get(cacheKey);
        return (
          keys ||
            ((keys = generate()),
            keyCache.set(cacheKey, keys),
            keysCached.add(keys)),
          keys
        );
      }
      const addIfFound = (set, obj, key) => {
        const opts = resolveObjectKey(obj, key);
        void 0 !== opts && set.add(opts);
      };
      class Config {
        constructor(config) {
          (this._config = (function initConfig(config) {
            return (
              ((config = config || {}).data = initData(config.data)),
              initOptions(config),
              config
            );
          })(config)),
            (this._scopeCache = new Map()),
            (this._resolverCache = new Map());
        }
        get platform() {
          return this._config.platform;
        }
        get type() {
          return this._config.type;
        }
        set type(type) {
          this._config.type = type;
        }
        get data() {
          return this._config.data;
        }
        set data(data) {
          this._config.data = initData(data);
        }
        get options() {
          return this._config.options;
        }
        set options(options) {
          this._config.options = options;
        }
        get plugins() {
          return this._config.plugins;
        }
        update() {
          const config = this._config;
          this.clearCache(), initOptions(config);
        }
        clearCache() {
          this._scopeCache.clear(), this._resolverCache.clear();
        }
        datasetScopeKeys(datasetType) {
          return cachedKeys(datasetType, () => [
            [`datasets.${datasetType}`, ''],
          ]);
        }
        datasetAnimationScopeKeys(datasetType, transition) {
          return cachedKeys(`${datasetType}.transition.${transition}`, () => [
            [
              `datasets.${datasetType}.transitions.${transition}`,
              `transitions.${transition}`,
            ],
            [`datasets.${datasetType}`, ''],
          ]);
        }
        datasetElementScopeKeys(datasetType, elementType) {
          return cachedKeys(`${datasetType}-${elementType}`, () => [
            [
              `datasets.${datasetType}.elements.${elementType}`,
              `datasets.${datasetType}`,
              `elements.${elementType}`,
              '',
            ],
          ]);
        }
        pluginScopeKeys(plugin) {
          const id = plugin.id;
          return cachedKeys(`${this.type}-plugin-${id}`, () => [
            [`plugins.${id}`, ...(plugin.additionalOptionScopes || [])],
          ]);
        }
        _cachedScopes(mainScope, resetCache) {
          const _scopeCache = this._scopeCache;
          let cache = _scopeCache.get(mainScope);
          return (
            (cache && !resetCache) ||
              ((cache = new Map()), _scopeCache.set(mainScope, cache)),
            cache
          );
        }
        getOptionScopes(mainScope, keyLists, resetCache) {
          const { options, type } = this,
            cache = this._cachedScopes(mainScope, resetCache),
            cached = cache.get(keyLists);
          if (cached) return cached;
          const scopes = new Set();
          keyLists.forEach((keys) => {
            mainScope &&
              (scopes.add(mainScope),
              keys.forEach((key) => addIfFound(scopes, mainScope, key))),
              keys.forEach((key) => addIfFound(scopes, options, key)),
              keys.forEach((key) =>
                addIfFound(scopes, overrides[type] || {}, key)
              ),
              keys.forEach((key) => addIfFound(scopes, defaults, key)),
              keys.forEach((key) => addIfFound(scopes, descriptors, key));
          });
          const array = Array.from(scopes);
          return (
            0 === array.length && array.push(Object.create(null)),
            keysCached.has(keyLists) && cache.set(keyLists, array),
            array
          );
        }
        chartOptionScopes() {
          const { options, type } = this;
          return [
            options,
            overrides[type] || {},
            defaults.datasets[type] || {},
            { type },
            defaults,
            descriptors,
          ];
        }
        resolveNamedOptions(scopes, names, context, prefixes = ['']) {
          const result = { $shared: !0 },
            { resolver, subPrefixes } = getResolver(
              this._resolverCache,
              scopes,
              prefixes
            );
          let options = resolver;
          if (
            (function needContext(proxy, names) {
              const { isScriptable, isIndexable } = _descriptors(proxy);
              for (const prop of names) {
                const scriptable = isScriptable(prop),
                  indexable = isIndexable(prop),
                  value = (indexable || scriptable) && proxy[prop];
                if (
                  (scriptable && (isFunction(value) || hasFunction(value))) ||
                  (indexable && isArray(value))
                )
                  return !0;
              }
              return !1;
            })(resolver, names)
          ) {
            result.$shared = !1;
            options = _attachContext(
              resolver,
              (context = isFunction(context) ? context() : context),
              this.createResolver(scopes, context, subPrefixes)
            );
          }
          for (const prop of names) result[prop] = options[prop];
          return result;
        }
        createResolver(scopes, context, prefixes = [''], descriptorDefaults) {
          const { resolver } = getResolver(
            this._resolverCache,
            scopes,
            prefixes
          );
          return isObject(context)
            ? _attachContext(resolver, context, void 0, descriptorDefaults)
            : resolver;
        }
      }
      function getResolver(resolverCache, scopes, prefixes) {
        let cache = resolverCache.get(scopes);
        cache || ((cache = new Map()), resolverCache.set(scopes, cache));
        const cacheKey = prefixes.join();
        let cached = cache.get(cacheKey);
        if (!cached) {
          (cached = {
            resolver: _createResolver(scopes, prefixes),
            subPrefixes: prefixes.filter(
              (p) => !p.toLowerCase().includes('hover')
            ),
          }),
            cache.set(cacheKey, cached);
        }
        return cached;
      }
      const hasFunction = (value) =>
        isObject(value) &&
        Object.getOwnPropertyNames(value).reduce(
          (acc, key) => acc || isFunction(value[key]),
          !1
        );
      const KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];
      function positionIsHorizontal(position, axis) {
        return (
          'top' === position ||
          'bottom' === position ||
          (-1 === KNOWN_POSITIONS.indexOf(position) && 'x' === axis)
        );
      }
      function compare2Level(l1, l2) {
        return function (a, b) {
          return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
        };
      }
      function onAnimationsComplete(context) {
        const chart = context.chart,
          animationOptions = chart.options.animation;
        chart.notifyPlugins('afterRender'),
          callback(
            animationOptions && animationOptions.onComplete,
            [context],
            chart
          );
      }
      function onAnimationProgress(context) {
        const chart = context.chart,
          animationOptions = chart.options.animation;
        callback(
          animationOptions && animationOptions.onProgress,
          [context],
          chart
        );
      }
      function getCanvas(item) {
        return (
          _isDomSupported() && 'string' == typeof item
            ? (item = document.getElementById(item))
            : item && item.length && (item = item[0]),
          item && item.canvas && (item = item.canvas),
          item
        );
      }
      const instances = {},
        getChart = (key) => {
          const canvas = getCanvas(key);
          return Object.values(instances)
            .filter((c) => c.canvas === canvas)
            .pop();
        };
      function moveNumericKeys(obj, start, move) {
        const keys = Object.keys(obj);
        for (const key of keys) {
          const intKey = +key;
          if (intKey >= start) {
            const value = obj[key];
            delete obj[key],
              (move > 0 || intKey > start) && (obj[intKey + move] = value);
          }
        }
      }
      class Chart {
        static defaults = defaults;
        static instances = instances;
        static overrides = overrides;
        static registry = registry;
        static version = '4.1.1';
        static getChart = getChart;
        static register(...items) {
          registry.add(...items), invalidatePlugins();
        }
        static unregister(...items) {
          registry.remove(...items), invalidatePlugins();
        }
        constructor(item, userConfig) {
          const config = (this.config = new Config(userConfig)),
            initialCanvas = getCanvas(item),
            existingChart = getChart(initialCanvas);
          if (existingChart)
            throw new Error(
              "Canvas is already in use. Chart with ID '" +
                existingChart.id +
                "' must be destroyed before the canvas with ID '" +
                existingChart.canvas.id +
                "' can be reused."
            );
          const options = config.createResolver(
            config.chartOptionScopes(),
            this.getContext()
          );
          (this.platform = new (config.platform ||
            (function _detectPlatform(canvas) {
              return !_isDomSupported() ||
                ('undefined' != typeof OffscreenCanvas &&
                  canvas instanceof OffscreenCanvas)
                ? BasicPlatform
                : DomPlatform;
            })(initialCanvas))()),
            this.platform.updateConfig(config);
          const context = this.platform.acquireContext(
              initialCanvas,
              options.aspectRatio
            ),
            canvas = context && context.canvas,
            height = canvas && canvas.height,
            width = canvas && canvas.width;
          (this.id = uid()),
            (this.ctx = context),
            (this.canvas = canvas),
            (this.width = width),
            (this.height = height),
            (this._options = options),
            (this._aspectRatio = this.aspectRatio),
            (this._layers = []),
            (this._metasets = []),
            (this._stacks = void 0),
            (this.boxes = []),
            (this.currentDevicePixelRatio = void 0),
            (this.chartArea = void 0),
            (this._active = []),
            (this._lastEvent = void 0),
            (this._listeners = {}),
            (this._responsiveListeners = void 0),
            (this._sortedMetasets = []),
            (this.scales = {}),
            (this._plugins = new PluginService()),
            (this.$proxies = {}),
            (this._hiddenIndices = {}),
            (this.attached = !1),
            (this._animationsDisabled = void 0),
            (this.$context = void 0),
            (this._doResize = (function debounce(fn, delay) {
              let timeout;
              return function (...args) {
                return (
                  delay
                    ? (clearTimeout(timeout),
                      (timeout = setTimeout(fn, delay, args)))
                    : fn.apply(this, args),
                  delay
                );
              };
            })((mode) => this.update(mode), options.resizeDelay || 0)),
            (this._dataChanges = []),
            (instances[this.id] = this),
            context && canvas
              ? (animator.listen(this, 'complete', onAnimationsComplete),
                animator.listen(this, 'progress', onAnimationProgress),
                this._initialize(),
                this.attached && this.update())
              : console.error(
                  "Failed to create chart: can't acquire context from the given item"
                );
        }
        get aspectRatio() {
          const {
            options: { aspectRatio, maintainAspectRatio },
            width,
            height,
            _aspectRatio,
          } = this;
          return isNullOrUndef(aspectRatio)
            ? maintainAspectRatio && _aspectRatio
              ? _aspectRatio
              : height
              ? width / height
              : null
            : aspectRatio;
        }
        get data() {
          return this.config.data;
        }
        set data(data) {
          this.config.data = data;
        }
        get options() {
          return this._options;
        }
        set options(options) {
          this.config.options = options;
        }
        get registry() {
          return registry;
        }
        _initialize() {
          return (
            this.notifyPlugins('beforeInit'),
            this.options.responsive
              ? this.resize()
              : retinaScale(this, this.options.devicePixelRatio),
            this.bindEvents(),
            this.notifyPlugins('afterInit'),
            this
          );
        }
        clear() {
          return clearCanvas(this.canvas, this.ctx), this;
        }
        stop() {
          return animator.stop(this), this;
        }
        resize(width, height) {
          animator.running(this)
            ? (this._resizeBeforeDraw = { width, height })
            : this._resize(width, height);
        }
        _resize(width, height) {
          const options = this.options,
            canvas = this.canvas,
            aspectRatio = options.maintainAspectRatio && this.aspectRatio,
            newSize = this.platform.getMaximumSize(
              canvas,
              width,
              height,
              aspectRatio
            ),
            newRatio =
              options.devicePixelRatio || this.platform.getDevicePixelRatio(),
            mode = this.width ? 'resize' : 'attach';
          (this.width = newSize.width),
            (this.height = newSize.height),
            (this._aspectRatio = this.aspectRatio),
            retinaScale(this, newRatio, !0) &&
              (this.notifyPlugins('resize', { size: newSize }),
              callback(options.onResize, [this, newSize], this),
              this.attached && this._doResize(mode) && this.render());
        }
        ensureScalesHaveIDs() {
          each(this.options.scales || {}, (axisOptions, axisID) => {
            axisOptions.id = axisID;
          });
        }
        buildOrUpdateScales() {
          const options = this.options,
            scaleOpts = options.scales,
            scales = this.scales,
            updated = Object.keys(scales).reduce(
              (obj, id) => ((obj[id] = !1), obj),
              {}
            );
          let items = [];
          scaleOpts &&
            (items = items.concat(
              Object.keys(scaleOpts).map((id) => {
                const scaleOptions = scaleOpts[id],
                  axis = determineAxis(id, scaleOptions),
                  isRadial = 'r' === axis,
                  isHorizontal = 'x' === axis;
                return {
                  options: scaleOptions,
                  dposition: isRadial
                    ? 'chartArea'
                    : isHorizontal
                    ? 'bottom'
                    : 'left',
                  dtype: isRadial
                    ? 'radialLinear'
                    : isHorizontal
                    ? 'category'
                    : 'linear',
                };
              })
            )),
            each(items, (item) => {
              const scaleOptions = item.options,
                id = scaleOptions.id,
                axis = determineAxis(id, scaleOptions),
                scaleType = valueOrDefault(scaleOptions.type, item.dtype);
              (void 0 !== scaleOptions.position &&
                positionIsHorizontal(scaleOptions.position, axis) ===
                  positionIsHorizontal(item.dposition)) ||
                (scaleOptions.position = item.dposition),
                (updated[id] = !0);
              let scale = null;
              if (id in scales && scales[id].type === scaleType)
                scale = scales[id];
              else {
                (scale = new (registry.getScale(scaleType))({
                  id,
                  type: scaleType,
                  ctx: this.ctx,
                  chart: this,
                })),
                  (scales[scale.id] = scale);
              }
              scale.init(scaleOptions, options);
            }),
            each(updated, (hasUpdated, id) => {
              hasUpdated || delete scales[id];
            }),
            each(scales, (scale) => {
              layouts.configure(this, scale, scale.options),
                layouts.addBox(this, scale);
            });
        }
        _updateMetasets() {
          const metasets = this._metasets,
            numData = this.data.datasets.length,
            numMeta = metasets.length;
          if ((metasets.sort((a, b) => a.index - b.index), numMeta > numData)) {
            for (let i = numData; i < numMeta; ++i) this._destroyDatasetMeta(i);
            metasets.splice(numData, numMeta - numData);
          }
          this._sortedMetasets = metasets
            .slice(0)
            .sort(compare2Level('order', 'index'));
        }
        _removeUnreferencedMetasets() {
          const {
            _metasets: metasets,
            data: { datasets },
          } = this;
          metasets.length > datasets.length && delete this._stacks,
            metasets.forEach((meta, index) => {
              0 === datasets.filter((x) => x === meta._dataset).length &&
                this._destroyDatasetMeta(index);
            });
        }
        buildOrUpdateControllers() {
          const newControllers = [],
            datasets = this.data.datasets;
          let i, ilen;
          for (
            this._removeUnreferencedMetasets(), i = 0, ilen = datasets.length;
            i < ilen;
            i++
          ) {
            const dataset = datasets[i];
            let meta = this.getDatasetMeta(i);
            const type = dataset.type || this.config.type;
            if (
              (meta.type &&
                meta.type !== type &&
                (this._destroyDatasetMeta(i), (meta = this.getDatasetMeta(i))),
              (meta.type = type),
              (meta.indexAxis =
                dataset.indexAxis || getIndexAxis(type, this.options)),
              (meta.order = dataset.order || 0),
              (meta.index = i),
              (meta.label = '' + dataset.label),
              (meta.visible = this.isDatasetVisible(i)),
              meta.controller)
            )
              meta.controller.updateIndex(i), meta.controller.linkScales();
            else {
              const ControllerClass = registry.getController(type),
                { datasetElementType, dataElementType } =
                  defaults.datasets[type];
              Object.assign(ControllerClass, {
                dataElementType: registry.getElement(dataElementType),
                datasetElementType:
                  datasetElementType && registry.getElement(datasetElementType),
              }),
                (meta.controller = new ControllerClass(this, i)),
                newControllers.push(meta.controller);
            }
          }
          return this._updateMetasets(), newControllers;
        }
        _resetElements() {
          each(
            this.data.datasets,
            (dataset, datasetIndex) => {
              this.getDatasetMeta(datasetIndex).controller.reset();
            },
            this
          );
        }
        reset() {
          this._resetElements(), this.notifyPlugins('reset');
        }
        update(mode) {
          const config = this.config;
          config.update();
          const options = (this._options = config.createResolver(
              config.chartOptionScopes(),
              this.getContext()
            )),
            animsDisabled = (this._animationsDisabled = !options.animation);
          if (
            (this._updateScales(),
            this._checkEventBindings(),
            this._updateHiddenIndices(),
            this._plugins.invalidate(),
            !1 === this.notifyPlugins('beforeUpdate', { mode, cancelable: !0 }))
          )
            return;
          const newControllers = this.buildOrUpdateControllers();
          this.notifyPlugins('beforeElementsUpdate');
          let minPadding = 0;
          for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
            const { controller } = this.getDatasetMeta(i),
              reset =
                !animsDisabled && -1 === newControllers.indexOf(controller);
            controller.buildOrUpdateElements(reset),
              (minPadding = Math.max(+controller.getMaxOverflow(), minPadding));
          }
          (minPadding = this._minPadding =
            options.layout.autoPadding ? minPadding : 0),
            this._updateLayout(minPadding),
            animsDisabled ||
              each(newControllers, (controller) => {
                controller.reset();
              }),
            this._updateDatasets(mode),
            this.notifyPlugins('afterUpdate', { mode }),
            this._layers.sort(compare2Level('z', '_idx'));
          const { _active, _lastEvent } = this;
          _lastEvent
            ? this._eventHandler(_lastEvent, !0)
            : _active.length && this._updateHoverStyles(_active, _active, !0),
            this.render();
        }
        _updateScales() {
          each(this.scales, (scale) => {
            layouts.removeBox(this, scale);
          }),
            this.ensureScalesHaveIDs(),
            this.buildOrUpdateScales();
        }
        _checkEventBindings() {
          const options = this.options,
            existingEvents = new Set(Object.keys(this._listeners)),
            newEvents = new Set(options.events);
          (setsEqual(existingEvents, newEvents) &&
            !!this._responsiveListeners === options.responsive) ||
            (this.unbindEvents(), this.bindEvents());
        }
        _updateHiddenIndices() {
          const { _hiddenIndices } = this,
            changes = this._getUniformDataChanges() || [];
          for (const { method, start, count } of changes) {
            moveNumericKeys(
              _hiddenIndices,
              start,
              '_removeElements' === method ? -count : count
            );
          }
        }
        _getUniformDataChanges() {
          const _dataChanges = this._dataChanges;
          if (!_dataChanges || !_dataChanges.length) return;
          this._dataChanges = [];
          const datasetCount = this.data.datasets.length,
            makeSet = (idx) =>
              new Set(
                _dataChanges
                  .filter((c) => c[0] === idx)
                  .map((c, i) => i + ',' + c.splice(1).join(','))
              ),
            changeSet = makeSet(0);
          for (let i = 1; i < datasetCount; i++)
            if (!setsEqual(changeSet, makeSet(i))) return;
          return Array.from(changeSet)
            .map((c) => c.split(','))
            .map((a) => ({ method: a[1], start: +a[2], count: +a[3] }));
        }
        _updateLayout(minPadding) {
          if (!1 === this.notifyPlugins('beforeLayout', { cancelable: !0 }))
            return;
          layouts.update(this, this.width, this.height, minPadding);
          const area = this.chartArea,
            noArea = area.width <= 0 || area.height <= 0;
          (this._layers = []),
            each(
              this.boxes,
              (box) => {
                (noArea && 'chartArea' === box.position) ||
                  (box.configure && box.configure(),
                  this._layers.push(...box._layers()));
              },
              this
            ),
            this._layers.forEach((item, index) => {
              item._idx = index;
            }),
            this.notifyPlugins('afterLayout');
        }
        _updateDatasets(mode) {
          if (
            !1 !==
            this.notifyPlugins('beforeDatasetsUpdate', { mode, cancelable: !0 })
          ) {
            for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i)
              this.getDatasetMeta(i).controller.configure();
            for (
              let i1 = 0, ilen1 = this.data.datasets.length;
              i1 < ilen1;
              ++i1
            )
              this._updateDataset(
                i1,
                isFunction(mode) ? mode({ datasetIndex: i1 }) : mode
              );
            this.notifyPlugins('afterDatasetsUpdate', { mode });
          }
        }
        _updateDataset(index, mode) {
          const meta = this.getDatasetMeta(index),
            args = { meta, index, mode, cancelable: !0 };
          !1 !== this.notifyPlugins('beforeDatasetUpdate', args) &&
            (meta.controller._update(mode),
            (args.cancelable = !1),
            this.notifyPlugins('afterDatasetUpdate', args));
        }
        render() {
          !1 !== this.notifyPlugins('beforeRender', { cancelable: !0 }) &&
            (animator.has(this)
              ? this.attached && !animator.running(this) && animator.start(this)
              : (this.draw(), onAnimationsComplete({ chart: this })));
        }
        draw() {
          let i;
          if (this._resizeBeforeDraw) {
            const { width, height } = this._resizeBeforeDraw;
            this._resize(width, height), (this._resizeBeforeDraw = null);
          }
          if ((this.clear(), this.width <= 0 || this.height <= 0)) return;
          if (!1 === this.notifyPlugins('beforeDraw', { cancelable: !0 }))
            return;
          const layers = this._layers;
          for (i = 0; i < layers.length && layers[i].z <= 0; ++i)
            layers[i].draw(this.chartArea);
          for (this._drawDatasets(); i < layers.length; ++i)
            layers[i].draw(this.chartArea);
          this.notifyPlugins('afterDraw');
        }
        _getSortedDatasetMetas(filterVisible) {
          const metasets = this._sortedMetasets,
            result = [];
          let i, ilen;
          for (i = 0, ilen = metasets.length; i < ilen; ++i) {
            const meta = metasets[i];
            (filterVisible && !meta.visible) || result.push(meta);
          }
          return result;
        }
        getSortedVisibleDatasetMetas() {
          return this._getSortedDatasetMetas(!0);
        }
        _drawDatasets() {
          if (
            !1 === this.notifyPlugins('beforeDatasetsDraw', { cancelable: !0 })
          )
            return;
          const metasets = this.getSortedVisibleDatasetMetas();
          for (let i = metasets.length - 1; i >= 0; --i)
            this._drawDataset(metasets[i]);
          this.notifyPlugins('afterDatasetsDraw');
        }
        _drawDataset(meta) {
          const ctx = this.ctx,
            clip = meta._clip,
            useClip = !clip.disabled,
            area =
              (function getDatasetArea(meta) {
                const { xScale, yScale } = meta;
                if (xScale && yScale)
                  return {
                    left: xScale.left,
                    right: xScale.right,
                    top: yScale.top,
                    bottom: yScale.bottom,
                  };
              })(meta) || this.chartArea,
            args = { meta, index: meta.index, cancelable: !0 };
          !1 !== this.notifyPlugins('beforeDatasetDraw', args) &&
            (useClip &&
              clipArea(ctx, {
                left: !1 === clip.left ? 0 : area.left - clip.left,
                right: !1 === clip.right ? this.width : area.right + clip.right,
                top: !1 === clip.top ? 0 : area.top - clip.top,
                bottom:
                  !1 === clip.bottom ? this.height : area.bottom + clip.bottom,
              }),
            meta.controller.draw(),
            useClip && unclipArea(ctx),
            (args.cancelable = !1),
            this.notifyPlugins('afterDatasetDraw', args));
        }
        isPointInArea(point) {
          return _isPointInArea(point, this.chartArea, this._minPadding);
        }
        getElementsAtEventForMode(e, mode, options, useFinalPosition) {
          const method = Interaction.modes[mode];
          return 'function' == typeof method
            ? method(this, e, options, useFinalPosition)
            : [];
        }
        getDatasetMeta(datasetIndex) {
          const dataset = this.data.datasets[datasetIndex],
            metasets = this._metasets;
          let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
          return (
            meta ||
              ((meta = {
                type: null,
                data: [],
                dataset: null,
                controller: null,
                hidden: null,
                xAxisID: null,
                yAxisID: null,
                order: (dataset && dataset.order) || 0,
                index: datasetIndex,
                _dataset: dataset,
                _parsed: [],
                _sorted: !1,
              }),
              metasets.push(meta)),
            meta
          );
        }
        getContext() {
          return (
            this.$context ||
            (this.$context = createContext(null, {
              chart: this,
              type: 'chart',
            }))
          );
        }
        getVisibleDatasetCount() {
          return this.getSortedVisibleDatasetMetas().length;
        }
        isDatasetVisible(datasetIndex) {
          const dataset = this.data.datasets[datasetIndex];
          if (!dataset) return !1;
          const meta = this.getDatasetMeta(datasetIndex);
          return 'boolean' == typeof meta.hidden
            ? !meta.hidden
            : !dataset.hidden;
        }
        setDatasetVisibility(datasetIndex, visible) {
          this.getDatasetMeta(datasetIndex).hidden = !visible;
        }
        toggleDataVisibility(index) {
          this._hiddenIndices[index] = !this._hiddenIndices[index];
        }
        getDataVisibility(index) {
          return !this._hiddenIndices[index];
        }
        _updateVisibility(datasetIndex, dataIndex, visible) {
          const mode = visible ? 'show' : 'hide',
            meta = this.getDatasetMeta(datasetIndex),
            anims = meta.controller._resolveAnimations(void 0, mode);
          defined(dataIndex)
            ? ((meta.data[dataIndex].hidden = !visible), this.update())
            : (this.setDatasetVisibility(datasetIndex, visible),
              anims.update(meta, { visible }),
              this.update((ctx) =>
                ctx.datasetIndex === datasetIndex ? mode : void 0
              ));
        }
        hide(datasetIndex, dataIndex) {
          this._updateVisibility(datasetIndex, dataIndex, !1);
        }
        show(datasetIndex, dataIndex) {
          this._updateVisibility(datasetIndex, dataIndex, !0);
        }
        _destroyDatasetMeta(datasetIndex) {
          const meta = this._metasets[datasetIndex];
          meta && meta.controller && meta.controller._destroy(),
            delete this._metasets[datasetIndex];
        }
        _stop() {
          let i, ilen;
          for (
            this.stop(),
              animator.remove(this),
              i = 0,
              ilen = this.data.datasets.length;
            i < ilen;
            ++i
          )
            this._destroyDatasetMeta(i);
        }
        destroy() {
          this.notifyPlugins('beforeDestroy');
          const { canvas, ctx } = this;
          this._stop(),
            this.config.clearCache(),
            canvas &&
              (this.unbindEvents(),
              clearCanvas(canvas, ctx),
              this.platform.releaseContext(ctx),
              (this.canvas = null),
              (this.ctx = null)),
            delete instances[this.id],
            this.notifyPlugins('afterDestroy');
        }
        toBase64Image(...args) {
          return this.canvas.toDataURL(...args);
        }
        bindEvents() {
          this.bindUserEvents(),
            this.options.responsive
              ? this.bindResponsiveEvents()
              : (this.attached = !0);
        }
        bindUserEvents() {
          const listeners = this._listeners,
            platform = this.platform,
            _add = (type, listener) => {
              platform.addEventListener(this, type, listener),
                (listeners[type] = listener);
            },
            listener = (e, x, y) => {
              (e.offsetX = x), (e.offsetY = y), this._eventHandler(e);
            };
          each(this.options.events, (type) => _add(type, listener));
        }
        bindResponsiveEvents() {
          this._responsiveListeners || (this._responsiveListeners = {});
          const listeners = this._responsiveListeners,
            platform = this.platform,
            _add = (type, listener) => {
              platform.addEventListener(this, type, listener),
                (listeners[type] = listener);
            },
            _remove = (type, listener) => {
              listeners[type] &&
                (platform.removeEventListener(this, type, listener),
                delete listeners[type]);
            },
            listener = (width, height) => {
              this.canvas && this.resize(width, height);
            };
          let detached;
          const attached = () => {
            _remove('attach', attached),
              (this.attached = !0),
              this.resize(),
              _add('resize', listener),
              _add('detach', detached);
          };
          (detached = () => {
            (this.attached = !1),
              _remove('resize', listener),
              this._stop(),
              this._resize(0, 0),
              _add('attach', attached);
          }),
            platform.isAttached(this.canvas) ? attached() : detached();
        }
        unbindEvents() {
          each(this._listeners, (listener, type) => {
            this.platform.removeEventListener(this, type, listener);
          }),
            (this._listeners = {}),
            each(this._responsiveListeners, (listener, type) => {
              this.platform.removeEventListener(this, type, listener);
            }),
            (this._responsiveListeners = void 0);
        }
        updateHoverStyle(items, mode, enabled) {
          const prefix = enabled ? 'set' : 'remove';
          let meta, item, i, ilen;
          for (
            'dataset' === mode &&
              ((meta = this.getDatasetMeta(items[0].datasetIndex)),
              meta.controller['_' + prefix + 'DatasetHoverStyle']()),
              i = 0,
              ilen = items.length;
            i < ilen;
            ++i
          ) {
            item = items[i];
            const controller =
              item && this.getDatasetMeta(item.datasetIndex).controller;
            controller &&
              controller[prefix + 'HoverStyle'](
                item.element,
                item.datasetIndex,
                item.index
              );
          }
        }
        getActiveElements() {
          return this._active || [];
        }
        setActiveElements(activeElements) {
          const lastActive = this._active || [],
            active = activeElements.map(({ datasetIndex, index }) => {
              const meta = this.getDatasetMeta(datasetIndex);
              if (!meta)
                throw new Error('No dataset found at index ' + datasetIndex);
              return { datasetIndex, element: meta.data[index], index };
            });
          !_elementsEqual(active, lastActive) &&
            ((this._active = active),
            (this._lastEvent = null),
            this._updateHoverStyles(active, lastActive));
        }
        notifyPlugins(hook, args, filter) {
          return this._plugins.notify(this, hook, args, filter);
        }
        isPluginEnabled(pluginId) {
          return (
            1 ===
            this._plugins._cache.filter((p) => p.plugin.id === pluginId).length
          );
        }
        _updateHoverStyles(active, lastActive, replay) {
          const hoverOptions = this.options.hover,
            diff = (a, b) =>
              a.filter(
                (x) =>
                  !b.some(
                    (y) =>
                      x.datasetIndex === y.datasetIndex && x.index === y.index
                  )
              ),
            deactivated = diff(lastActive, active),
            activated = replay ? active : diff(active, lastActive);
          deactivated.length &&
            this.updateHoverStyle(deactivated, hoverOptions.mode, !1),
            activated.length &&
              hoverOptions.mode &&
              this.updateHoverStyle(activated, hoverOptions.mode, !0);
        }
        _eventHandler(e, replay) {
          const args = {
              event: e,
              replay,
              cancelable: !0,
              inChartArea: this.isPointInArea(e),
            },
            eventFilter = (plugin) =>
              (plugin.options.events || this.options.events).includes(
                e.native.type
              );
          if (!1 === this.notifyPlugins('beforeEvent', args, eventFilter))
            return;
          const changed = this._handleEvent(e, replay, args.inChartArea);
          return (
            (args.cancelable = !1),
            this.notifyPlugins('afterEvent', args, eventFilter),
            (changed || args.changed) && this.render(),
            this
          );
        }
        _handleEvent(e, replay, inChartArea) {
          const { _active: lastActive = [], options } = this,
            useFinalPosition = replay,
            active = this._getActiveElements(
              e,
              lastActive,
              inChartArea,
              useFinalPosition
            ),
            isClick = (function _isClickEvent(e) {
              return (
                'mouseup' === e.type ||
                'click' === e.type ||
                'contextmenu' === e.type
              );
            })(e),
            lastEvent = (function determineLastEvent(
              e,
              lastEvent,
              inChartArea,
              isClick
            ) {
              return inChartArea && 'mouseout' !== e.type
                ? isClick
                  ? lastEvent
                  : e
                : null;
            })(e, this._lastEvent, inChartArea, isClick);
          inChartArea &&
            ((this._lastEvent = null),
            callback(options.onHover, [e, active, this], this),
            isClick && callback(options.onClick, [e, active, this], this));
          const changed = !_elementsEqual(active, lastActive);
          return (
            (changed || replay) &&
              ((this._active = active),
              this._updateHoverStyles(active, lastActive, replay)),
            (this._lastEvent = lastEvent),
            changed
          );
        }
        _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
          if ('mouseout' === e.type) return [];
          if (!inChartArea) return lastActive;
          const hoverOptions = this.options.hover;
          return this.getElementsAtEventForMode(
            e,
            hoverOptions.mode,
            hoverOptions,
            useFinalPosition
          );
        }
      }
      function invalidatePlugins() {
        return each(Chart.instances, (chart) => chart._plugins.invalidate());
      }
      function setStyle(ctx, options, style = options) {
        (ctx.lineCap = valueOrDefault(
          style.borderCapStyle,
          options.borderCapStyle
        )),
          ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash)),
          (ctx.lineDashOffset = valueOrDefault(
            style.borderDashOffset,
            options.borderDashOffset
          )),
          (ctx.lineJoin = valueOrDefault(
            style.borderJoinStyle,
            options.borderJoinStyle
          )),
          (ctx.lineWidth = valueOrDefault(
            style.borderWidth,
            options.borderWidth
          )),
          (ctx.strokeStyle = valueOrDefault(
            style.borderColor,
            options.borderColor
          ));
      }
      function lineTo(ctx, previous, target) {
        ctx.lineTo(target.x, target.y);
      }
      function pathVars(points, segment, params = {}) {
        const count = points.length,
          { start: paramsStart = 0, end: paramsEnd = count - 1 } = params,
          { start: segmentStart, end: segmentEnd } = segment,
          start = Math.max(paramsStart, segmentStart),
          end = Math.min(paramsEnd, segmentEnd),
          outside =
            (paramsStart < segmentStart && paramsEnd < segmentStart) ||
            (paramsStart > segmentEnd && paramsEnd > segmentEnd);
        return {
          count,
          start,
          loop: segment.loop,
          ilen: end < start && !outside ? count + end - start : end - start,
        };
      }
      function pathSegment(ctx, line, segment, params) {
        const { points, options } = line,
          { count, start, loop, ilen } = pathVars(points, segment, params),
          lineMethod = (function getLineMethod(options) {
            return options.stepped
              ? _steppedLineTo
              : options.tension || 'monotone' === options.cubicInterpolationMode
              ? _bezierCurveTo
              : lineTo;
          })(options);
        let i,
          point,
          prev,
          { move = !0, reverse } = params || {};
        for (i = 0; i <= ilen; ++i)
          (point = points[(start + (reverse ? ilen - i : i)) % count]),
            point.skip ||
              (move
                ? (ctx.moveTo(point.x, point.y), (move = !1))
                : lineMethod(ctx, prev, point, reverse, options.stepped),
              (prev = point));
        return (
          loop &&
            ((point = points[(start + (reverse ? ilen : 0)) % count]),
            lineMethod(ctx, prev, point, reverse, options.stepped)),
          !!loop
        );
      }
      function fastPathSegment(ctx, line, segment, params) {
        const points = line.points,
          { count, start, ilen } = pathVars(points, segment, params),
          { move = !0, reverse } = params || {};
        let i,
          point,
          prevX,
          minY,
          maxY,
          lastY,
          avgX = 0,
          countX = 0;
        const pointIndex = (index) =>
            (start + (reverse ? ilen - index : index)) % count,
          drawX = () => {
            minY !== maxY &&
              (ctx.lineTo(avgX, maxY),
              ctx.lineTo(avgX, minY),
              ctx.lineTo(avgX, lastY));
          };
        for (
          move &&
            ((point = points[pointIndex(0)]), ctx.moveTo(point.x, point.y)),
            i = 0;
          i <= ilen;
          ++i
        ) {
          if (((point = points[pointIndex(i)]), point.skip)) continue;
          const x = point.x,
            y = point.y,
            truncX = 0 | x;
          truncX === prevX
            ? (y < minY ? (minY = y) : y > maxY && (maxY = y),
              (avgX = (countX * avgX + x) / ++countX))
            : (drawX(),
              ctx.lineTo(x, y),
              (prevX = truncX),
              (countX = 0),
              (minY = maxY = y)),
            (lastY = y);
        }
        drawX();
      }
      function _getSegmentMethod(line) {
        const opts = line.options,
          borderDash = opts.borderDash && opts.borderDash.length;
        return !(
          line._decimated ||
          line._loop ||
          opts.tension ||
          'monotone' === opts.cubicInterpolationMode ||
          opts.stepped ||
          borderDash
        )
          ? fastPathSegment
          : pathSegment;
      }
      const usePath2D = 'function' == typeof Path2D;
      function draw(ctx, line, start, count) {
        usePath2D && !line.options.segment
          ? (function strokePathWithCache(ctx, line, start, count) {
              let path = line._path;
              path ||
                ((path = line._path = new Path2D()),
                line.path(path, start, count) && path.closePath()),
                setStyle(ctx, line.options),
                ctx.stroke(path);
            })(ctx, line, start, count)
          : (function strokePathDirect(ctx, line, start, count) {
              const { segments, options } = line,
                segmentMethod = _getSegmentMethod(line);
              for (const segment of segments)
                setStyle(ctx, options, segment.style),
                  ctx.beginPath(),
                  segmentMethod(ctx, line, segment, {
                    start,
                    end: start + count - 1,
                  }) && ctx.closePath(),
                  ctx.stroke();
            })(ctx, line, start, count);
      }
      class LineElement extends Element {
        static id = 'line';
        static defaults = {
          borderCapStyle: 'butt',
          borderDash: [],
          borderDashOffset: 0,
          borderJoinStyle: 'miter',
          borderWidth: 3,
          capBezierPoints: !0,
          cubicInterpolationMode: 'default',
          fill: !1,
          spanGaps: !1,
          stepped: !1,
          tension: 0,
        };
        static defaultRoutes = {
          backgroundColor: 'backgroundColor',
          borderColor: 'borderColor',
        };
        static descriptors = {
          _scriptable: !0,
          _indexable: (name) => 'borderDash' !== name && 'fill' !== name,
        };
        constructor(cfg) {
          super(),
            (this.animated = !0),
            (this.options = void 0),
            (this._chart = void 0),
            (this._loop = void 0),
            (this._fullLoop = void 0),
            (this._path = void 0),
            (this._points = void 0),
            (this._segments = void 0),
            (this._decimated = !1),
            (this._pointsUpdated = !1),
            (this._datasetIndex = void 0),
            cfg && Object.assign(this, cfg);
        }
        updateControlPoints(chartArea, indexAxis) {
          const options = this.options;
          if (
            (options.tension ||
              'monotone' === options.cubicInterpolationMode) &&
            !options.stepped &&
            !this._pointsUpdated
          ) {
            const loop = options.spanGaps ? this._loop : this._fullLoop;
            _updateBezierControlPoints(
              this._points,
              options,
              chartArea,
              loop,
              indexAxis
            ),
              (this._pointsUpdated = !0);
          }
        }
        set points(points) {
          (this._points = points),
            delete this._segments,
            delete this._path,
            (this._pointsUpdated = !1);
        }
        get points() {
          return this._points;
        }
        get segments() {
          return (
            this._segments ||
            (this._segments = (function _computeSegments(line, segmentOptions) {
              const points = line.points,
                spanGaps = line.options.spanGaps,
                count = points.length;
              if (!count) return [];
              const loop = !!line._loop,
                { start, end } = (function findStartAndEnd(
                  points,
                  count,
                  loop,
                  spanGaps
                ) {
                  let start = 0,
                    end = count - 1;
                  if (loop && !spanGaps)
                    for (; start < count && !points[start].skip; ) start++;
                  for (; start < count && points[start].skip; ) start++;
                  for (
                    start %= count, loop && (end += start);
                    end > start && points[end % count].skip;

                  )
                    end--;
                  return (end %= count), { start, end };
                })(points, count, loop, spanGaps);
              return splitByStyles(
                line,
                !0 === spanGaps
                  ? [{ start, end, loop }]
                  : (function solidSegments(points, start, max, loop) {
                      const count = points.length,
                        result = [];
                      let end,
                        last = start,
                        prev = points[start];
                      for (end = start + 1; end <= max; ++end) {
                        const cur = points[end % count];
                        cur.skip || cur.stop
                          ? prev.skip ||
                            ((loop = !1),
                            result.push({
                              start: start % count,
                              end: (end - 1) % count,
                              loop,
                            }),
                            (start = last = cur.stop ? end : null))
                          : ((last = end), prev.skip && (start = end)),
                          (prev = cur);
                      }
                      return (
                        null !== last &&
                          result.push({
                            start: start % count,
                            end: last % count,
                            loop,
                          }),
                        result
                      );
                    })(
                      points,
                      start,
                      end < start ? end + count : end,
                      !!line._fullLoop && 0 === start && end === count - 1
                    ),
                points,
                segmentOptions
              );
            })(this, this.options.segment))
          );
        }
        first() {
          const segments = this.segments,
            points = this.points;
          return segments.length && points[segments[0].start];
        }
        last() {
          const segments = this.segments,
            points = this.points,
            count = segments.length;
          return count && points[segments[count - 1].end];
        }
        interpolate(point, property) {
          const options = this.options,
            value = point[property],
            points = this.points,
            segments = _boundSegments(this, {
              property,
              start: value,
              end: value,
            });
          if (!segments.length) return;
          const result = [],
            _interpolate = (function _getInterpolationMethod(options) {
              return options.stepped
                ? _steppedInterpolation
                : options.tension ||
                  'monotone' === options.cubicInterpolationMode
                ? _bezierInterpolation
                : _pointInLine;
            })(options);
          let i, ilen;
          for (i = 0, ilen = segments.length; i < ilen; ++i) {
            const { start, end } = segments[i],
              p1 = points[start],
              p2 = points[end];
            if (p1 === p2) {
              result.push(p1);
              continue;
            }
            const interpolated = _interpolate(
              p1,
              p2,
              Math.abs((value - p1[property]) / (p2[property] - p1[property])),
              options.stepped
            );
            (interpolated[property] = point[property]),
              result.push(interpolated);
          }
          return 1 === result.length ? result[0] : result;
        }
        pathSegment(ctx, segment, params) {
          return _getSegmentMethod(this)(ctx, this, segment, params);
        }
        path(ctx, start, count) {
          const segments = this.segments,
            segmentMethod = _getSegmentMethod(this);
          let loop = this._loop;
          (start = start || 0), (count = count || this.points.length - start);
          for (const segment of segments)
            loop &= segmentMethod(ctx, this, segment, {
              start,
              end: start + count - 1,
            });
          return !!loop;
        }
        draw(ctx, chartArea, start, count) {
          const options = this.options || {};
          (this.points || []).length &&
            options.borderWidth &&
            (ctx.save(), draw(ctx, this, start, count), ctx.restore()),
            this.animated &&
              ((this._pointsUpdated = !1), (this._path = void 0));
        }
      }
      function inRange$1(el, pos, axis, useFinalPosition) {
        const options = el.options,
          { [axis]: value } = el.getProps([axis], useFinalPosition);
        return Math.abs(pos - value) < options.radius + options.hitRadius;
      }
      class PointElement extends Element {
        static id = 'point';
        static defaults = {
          borderWidth: 1,
          hitRadius: 1,
          hoverBorderWidth: 1,
          hoverRadius: 4,
          pointStyle: 'circle',
          radius: 3,
          rotation: 0,
        };
        static defaultRoutes = {
          backgroundColor: 'backgroundColor',
          borderColor: 'borderColor',
        };
        constructor(cfg) {
          super(),
            (this.options = void 0),
            (this.parsed = void 0),
            (this.skip = void 0),
            (this.stop = void 0),
            cfg && Object.assign(this, cfg);
        }
        inRange(mouseX, mouseY, useFinalPosition) {
          const options = this.options,
            { x, y } = this.getProps(['x', 'y'], useFinalPosition);
          return (
            Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) <
            Math.pow(options.hitRadius + options.radius, 2)
          );
        }
        inXRange(mouseX, useFinalPosition) {
          return inRange$1(this, mouseX, 'x', useFinalPosition);
        }
        inYRange(mouseY, useFinalPosition) {
          return inRange$1(this, mouseY, 'y', useFinalPosition);
        }
        getCenterPoint(useFinalPosition) {
          const { x, y } = this.getProps(['x', 'y'], useFinalPosition);
          return { x, y };
        }
        size(options) {
          let radius = (options = options || this.options || {}).radius || 0;
          radius = Math.max(radius, (radius && options.hoverRadius) || 0);
          return 2 * (radius + ((radius && options.borderWidth) || 0));
        }
        draw(ctx, area) {
          const options = this.options;
          this.skip ||
            options.radius < 0.1 ||
            !_isPointInArea(this, area, this.size(options) / 2) ||
            ((ctx.strokeStyle = options.borderColor),
            (ctx.lineWidth = options.borderWidth),
            (ctx.fillStyle = options.backgroundColor),
            drawPoint(ctx, options, this.x, this.y));
        }
        getRange() {
          const options = this.options || {};
          return options.radius + options.hitRadius;
        }
      }
      const getBoxSize = (labelOpts, fontSize) => {
        let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
        return (
          labelOpts.usePointStyle &&
            ((boxHeight = Math.min(boxHeight, fontSize)),
            (boxWidth =
              labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize))),
          { boxWidth, boxHeight, itemHeight: Math.max(fontSize, boxHeight) }
        );
      };
      class Legend extends Element {
        constructor(config) {
          super(),
            (this._added = !1),
            (this.legendHitBoxes = []),
            (this._hoveredItem = null),
            (this.doughnutMode = !1),
            (this.chart = config.chart),
            (this.options = config.options),
            (this.ctx = config.ctx),
            (this.legendItems = void 0),
            (this.columnSizes = void 0),
            (this.lineWidths = void 0),
            (this.maxHeight = void 0),
            (this.maxWidth = void 0),
            (this.top = void 0),
            (this.bottom = void 0),
            (this.left = void 0),
            (this.right = void 0),
            (this.height = void 0),
            (this.width = void 0),
            (this._margins = void 0),
            (this.position = void 0),
            (this.weight = void 0),
            (this.fullSize = void 0);
        }
        update(maxWidth, maxHeight, margins) {
          (this.maxWidth = maxWidth),
            (this.maxHeight = maxHeight),
            (this._margins = margins),
            this.setDimensions(),
            this.buildLabels(),
            this.fit();
        }
        setDimensions() {
          this.isHorizontal()
            ? ((this.width = this.maxWidth),
              (this.left = this._margins.left),
              (this.right = this.width))
            : ((this.height = this.maxHeight),
              (this.top = this._margins.top),
              (this.bottom = this.height));
        }
        buildLabels() {
          const labelOpts = this.options.labels || {};
          let legendItems =
            callback(labelOpts.generateLabels, [this.chart], this) || [];
          labelOpts.filter &&
            (legendItems = legendItems.filter((item) =>
              labelOpts.filter(item, this.chart.data)
            )),
            labelOpts.sort &&
              (legendItems = legendItems.sort((a, b) =>
                labelOpts.sort(a, b, this.chart.data)
              )),
            this.options.reverse && legendItems.reverse(),
            (this.legendItems = legendItems);
        }
        fit() {
          const { options, ctx } = this;
          if (!options.display) return void (this.width = this.height = 0);
          const labelOpts = options.labels,
            labelFont = toFont(labelOpts.font),
            fontSize = labelFont.size,
            titleHeight = this._computeTitleHeight(),
            { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
          let width, height;
          (ctx.font = labelFont.string),
            this.isHorizontal()
              ? ((width = this.maxWidth),
                (height =
                  this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) +
                  10))
              : ((height = this.maxHeight),
                (width =
                  this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) +
                  10)),
            (this.width = Math.min(width, options.maxWidth || this.maxWidth)),
            (this.height = Math.min(
              height,
              options.maxHeight || this.maxHeight
            ));
        }
        _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
          const {
              ctx,
              maxWidth,
              options: {
                labels: { padding },
              },
            } = this,
            hitboxes = (this.legendHitBoxes = []),
            lineWidths = (this.lineWidths = [0]),
            lineHeight = itemHeight + padding;
          let totalHeight = titleHeight;
          (ctx.textAlign = 'left'), (ctx.textBaseline = 'middle');
          let row = -1,
            top = -lineHeight;
          return (
            this.legendItems.forEach((legendItem, i) => {
              const itemWidth =
                boxWidth +
                fontSize / 2 +
                ctx.measureText(legendItem.text).width;
              (0 === i ||
                lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding >
                  maxWidth) &&
                ((totalHeight += lineHeight),
                (lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0),
                (top += lineHeight),
                row++),
                (hitboxes[i] = {
                  left: 0,
                  top,
                  row,
                  width: itemWidth,
                  height: itemHeight,
                }),
                (lineWidths[lineWidths.length - 1] += itemWidth + padding);
            }),
            totalHeight
          );
        }
        _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
          const {
              ctx,
              maxHeight,
              options: {
                labels: { padding },
              },
            } = this,
            hitboxes = (this.legendHitBoxes = []),
            columnSizes = (this.columnSizes = []),
            heightLimit = maxHeight - titleHeight;
          let totalWidth = padding,
            currentColWidth = 0,
            currentColHeight = 0,
            left = 0,
            col = 0;
          return (
            this.legendItems.forEach((legendItem, i) => {
              const { itemWidth, itemHeight } = (function calculateItemSize(
                boxWidth,
                labelFont,
                ctx,
                legendItem,
                _itemHeight
              ) {
                const itemWidth = (function calculateItemWidth(
                    legendItem,
                    boxWidth,
                    labelFont,
                    ctx
                  ) {
                    let legendItemText = legendItem.text;
                    legendItemText &&
                      'string' != typeof legendItemText &&
                      (legendItemText = legendItemText.reduce((a, b) =>
                        a.length > b.length ? a : b
                      ));
                    return (
                      boxWidth +
                      labelFont.size / 2 +
                      ctx.measureText(legendItemText).width
                    );
                  })(legendItem, boxWidth, labelFont, ctx),
                  itemHeight = (function calculateItemHeight(
                    _itemHeight,
                    legendItem,
                    fontLineHeight
                  ) {
                    let itemHeight = _itemHeight;
                    'string' != typeof legendItem.text &&
                      (itemHeight = calculateLegendItemHeight(
                        legendItem,
                        fontLineHeight
                      ));
                    return itemHeight;
                  })(_itemHeight, legendItem, labelFont.lineHeight);
                return { itemWidth, itemHeight };
              })(boxWidth, labelFont, ctx, legendItem, _itemHeight);
              i > 0 &&
                currentColHeight + itemHeight + 2 * padding > heightLimit &&
                ((totalWidth += currentColWidth + padding),
                columnSizes.push({
                  width: currentColWidth,
                  height: currentColHeight,
                }),
                (left += currentColWidth + padding),
                col++,
                (currentColWidth = currentColHeight = 0)),
                (hitboxes[i] = {
                  left,
                  top: currentColHeight,
                  col,
                  width: itemWidth,
                  height: itemHeight,
                }),
                (currentColWidth = Math.max(currentColWidth, itemWidth)),
                (currentColHeight += itemHeight + padding);
            }),
            (totalWidth += currentColWidth),
            columnSizes.push({
              width: currentColWidth,
              height: currentColHeight,
            }),
            totalWidth
          );
        }
        adjustHitBoxes() {
          if (!this.options.display) return;
          const titleHeight = this._computeTitleHeight(),
            {
              legendHitBoxes: hitboxes,
              options: {
                align,
                labels: { padding },
                rtl,
              },
            } = this,
            rtlHelper = getRtlAdapter(rtl, this.left, this.width);
          if (this.isHorizontal()) {
            let row = 0,
              left = _alignStartEnd(
                align,
                this.left + padding,
                this.right - this.lineWidths[row]
              );
            for (const hitbox of hitboxes)
              row !== hitbox.row &&
                ((row = hitbox.row),
                (left = _alignStartEnd(
                  align,
                  this.left + padding,
                  this.right - this.lineWidths[row]
                ))),
                (hitbox.top += this.top + titleHeight + padding),
                (hitbox.left = rtlHelper.leftForLtr(
                  rtlHelper.x(left),
                  hitbox.width
                )),
                (left += hitbox.width + padding);
          } else {
            let col = 0,
              top = _alignStartEnd(
                align,
                this.top + titleHeight + padding,
                this.bottom - this.columnSizes[col].height
              );
            for (const hitbox1 of hitboxes)
              hitbox1.col !== col &&
                ((col = hitbox1.col),
                (top = _alignStartEnd(
                  align,
                  this.top + titleHeight + padding,
                  this.bottom - this.columnSizes[col].height
                ))),
                (hitbox1.top = top),
                (hitbox1.left += this.left + padding),
                (hitbox1.left = rtlHelper.leftForLtr(
                  rtlHelper.x(hitbox1.left),
                  hitbox1.width
                )),
                (top += hitbox1.height + padding);
          }
        }
        isHorizontal() {
          return (
            'top' === this.options.position ||
            'bottom' === this.options.position
          );
        }
        draw() {
          if (this.options.display) {
            const ctx = this.ctx;
            clipArea(ctx, this), this._draw(), unclipArea(ctx);
          }
        }
        _draw() {
          const { options: opts, columnSizes, lineWidths, ctx } = this,
            { align, labels: labelOpts } = opts,
            defaultColor = defaults.color,
            rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width),
            labelFont = toFont(labelOpts.font),
            { padding } = labelOpts,
            fontSize = labelFont.size,
            halfFontSize = fontSize / 2;
          let cursor;
          this.drawTitle(),
            (ctx.textAlign = rtlHelper.textAlign('left')),
            (ctx.textBaseline = 'middle'),
            (ctx.lineWidth = 0.5),
            (ctx.font = labelFont.string);
          const { boxWidth, boxHeight, itemHeight } = getBoxSize(
              labelOpts,
              fontSize
            ),
            isHorizontal = this.isHorizontal(),
            titleHeight = this._computeTitleHeight();
          (cursor = isHorizontal
            ? {
                x: _alignStartEnd(
                  align,
                  this.left + padding,
                  this.right - lineWidths[0]
                ),
                y: this.top + padding + titleHeight,
                line: 0,
              }
            : {
                x: this.left + padding,
                y: _alignStartEnd(
                  align,
                  this.top + titleHeight + padding,
                  this.bottom - columnSizes[0].height
                ),
                line: 0,
              }),
            overrideTextDirection(this.ctx, opts.textDirection);
          const lineHeight = itemHeight + padding;
          this.legendItems.forEach((legendItem, i) => {
            (ctx.strokeStyle = legendItem.fontColor),
              (ctx.fillStyle = legendItem.fontColor);
            const textWidth = ctx.measureText(legendItem.text).width,
              textAlign = rtlHelper.textAlign(
                legendItem.textAlign ||
                  (legendItem.textAlign = labelOpts.textAlign)
              ),
              width = boxWidth + halfFontSize + textWidth;
            let x = cursor.x,
              y = cursor.y;
            rtlHelper.setWidth(this.width),
              isHorizontal
                ? i > 0 &&
                  x + width + padding > this.right &&
                  ((y = cursor.y += lineHeight),
                  cursor.line++,
                  (x = cursor.x =
                    _alignStartEnd(
                      align,
                      this.left + padding,
                      this.right - lineWidths[cursor.line]
                    )))
                : i > 0 &&
                  y + lineHeight > this.bottom &&
                  ((x = cursor.x =
                    x + columnSizes[cursor.line].width + padding),
                  cursor.line++,
                  (y = cursor.y =
                    _alignStartEnd(
                      align,
                      this.top + titleHeight + padding,
                      this.bottom - columnSizes[cursor.line].height
                    )));
            if (
              ((function (x, y, legendItem) {
                if (
                  isNaN(boxWidth) ||
                  boxWidth <= 0 ||
                  isNaN(boxHeight) ||
                  boxHeight < 0
                )
                  return;
                ctx.save();
                const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
                if (
                  ((ctx.fillStyle = valueOrDefault(
                    legendItem.fillStyle,
                    defaultColor
                  )),
                  (ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt')),
                  (ctx.lineDashOffset = valueOrDefault(
                    legendItem.lineDashOffset,
                    0
                  )),
                  (ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter')),
                  (ctx.lineWidth = lineWidth),
                  (ctx.strokeStyle = valueOrDefault(
                    legendItem.strokeStyle,
                    defaultColor
                  )),
                  ctx.setLineDash(valueOrDefault(legendItem.lineDash, [])),
                  labelOpts.usePointStyle)
                ) {
                  const drawOptions = {
                      radius: (boxHeight * Math.SQRT2) / 2,
                      pointStyle: legendItem.pointStyle,
                      rotation: legendItem.rotation,
                      borderWidth: lineWidth,
                    },
                    centerX = rtlHelper.xPlus(x, boxWidth / 2);
                  drawPointLegend(
                    ctx,
                    drawOptions,
                    centerX,
                    y + halfFontSize,
                    labelOpts.pointStyleWidth && boxWidth
                  );
                } else {
                  const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0),
                    xBoxLeft = rtlHelper.leftForLtr(x, boxWidth),
                    borderRadius = toTRBLCorners(legendItem.borderRadius);
                  ctx.beginPath(),
                    Object.values(borderRadius).some((v) => 0 !== v)
                      ? addRoundedRectPath(ctx, {
                          x: xBoxLeft,
                          y: yBoxTop,
                          w: boxWidth,
                          h: boxHeight,
                          radius: borderRadius,
                        })
                      : ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight),
                    ctx.fill(),
                    0 !== lineWidth && ctx.stroke();
                }
                ctx.restore();
              })(rtlHelper.x(x), y, legendItem),
              (x = ((align, left, right, rtl) =>
                align === (rtl ? 'left' : 'right')
                  ? right
                  : 'center' === align
                  ? (left + right) / 2
                  : left)(
                textAlign,
                x + boxWidth + halfFontSize,
                isHorizontal ? x + width : this.right,
                opts.rtl
              )),
              (function (x, y, legendItem) {
                renderText(
                  ctx,
                  legendItem.text,
                  x,
                  y + itemHeight / 2,
                  labelFont,
                  {
                    strikethrough: legendItem.hidden,
                    textAlign: rtlHelper.textAlign(legendItem.textAlign),
                  }
                );
              })(rtlHelper.x(x), y, legendItem),
              isHorizontal)
            )
              cursor.x += width + padding;
            else if ('string' != typeof legendItem.text) {
              const fontLineHeight = labelFont.lineHeight;
              cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight);
            } else cursor.y += lineHeight;
          }),
            restoreTextDirection(this.ctx, opts.textDirection);
        }
        drawTitle() {
          const opts = this.options,
            titleOpts = opts.title,
            titleFont = toFont(titleOpts.font),
            titlePadding = toPadding(titleOpts.padding);
          if (!titleOpts.display) return;
          const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width),
            ctx = this.ctx,
            position = titleOpts.position,
            halfFontSize = titleFont.size / 2,
            topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
          let y,
            left = this.left,
            maxWidth = this.width;
          if (this.isHorizontal())
            (maxWidth = Math.max(...this.lineWidths)),
              (y = this.top + topPaddingPlusHalfFontSize),
              (left = _alignStartEnd(opts.align, left, this.right - maxWidth));
          else {
            const maxHeight = this.columnSizes.reduce(
              (acc, size) => Math.max(acc, size.height),
              0
            );
            y =
              topPaddingPlusHalfFontSize +
              _alignStartEnd(
                opts.align,
                this.top,
                this.bottom -
                  maxHeight -
                  opts.labels.padding -
                  this._computeTitleHeight()
              );
          }
          const x = _alignStartEnd(position, left, left + maxWidth);
          (ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position))),
            (ctx.textBaseline = 'middle'),
            (ctx.strokeStyle = titleOpts.color),
            (ctx.fillStyle = titleOpts.color),
            (ctx.font = titleFont.string),
            renderText(ctx, titleOpts.text, x, y, titleFont);
        }
        _computeTitleHeight() {
          const titleOpts = this.options.title,
            titleFont = toFont(titleOpts.font),
            titlePadding = toPadding(titleOpts.padding);
          return titleOpts.display
            ? titleFont.lineHeight + titlePadding.height
            : 0;
        }
        _getLegendItemAt(x, y) {
          let i, hitBox, lh;
          if (
            _isBetween(x, this.left, this.right) &&
            _isBetween(y, this.top, this.bottom)
          )
            for (lh = this.legendHitBoxes, i = 0; i < lh.length; ++i)
              if (
                ((hitBox = lh[i]),
                _isBetween(x, hitBox.left, hitBox.left + hitBox.width) &&
                  _isBetween(y, hitBox.top, hitBox.top + hitBox.height))
              )
                return this.legendItems[i];
          return null;
        }
        handleEvent(e) {
          const opts = this.options;
          if (
            !(function isListened(type, opts) {
              if (
                ('mousemove' === type || 'mouseout' === type) &&
                (opts.onHover || opts.onLeave)
              )
                return !0;
              if (opts.onClick && ('click' === type || 'mouseup' === type))
                return !0;
              return !1;
            })(e.type, opts)
          )
            return;
          const hoveredItem = this._getLegendItemAt(e.x, e.y);
          if ('mousemove' === e.type || 'mouseout' === e.type) {
            const previous = this._hoveredItem,
              sameItem =
                ((b = hoveredItem),
                null !== (a = previous) &&
                  null !== b &&
                  a.datasetIndex === b.datasetIndex &&
                  a.index === b.index);
            previous &&
              !sameItem &&
              callback(opts.onLeave, [e, previous, this], this),
              (this._hoveredItem = hoveredItem),
              hoveredItem &&
                !sameItem &&
                callback(opts.onHover, [e, hoveredItem, this], this);
          } else
            hoveredItem && callback(opts.onClick, [e, hoveredItem, this], this);
          var a, b;
        }
      }
      function calculateLegendItemHeight(legendItem, fontLineHeight) {
        return (
          fontLineHeight * (legendItem.text ? legendItem.text.length + 0.5 : 0)
        );
      }
      var plugin_legend = {
        id: 'legend',
        _element: Legend,
        start(chart, _args, options) {
          const legend = (chart.legend = new Legend({
            ctx: chart.ctx,
            options,
            chart,
          }));
          layouts.configure(chart, legend, options),
            layouts.addBox(chart, legend);
        },
        stop(chart) {
          layouts.removeBox(chart, chart.legend), delete chart.legend;
        },
        beforeUpdate(chart, _args, options) {
          const legend = chart.legend;
          layouts.configure(chart, legend, options), (legend.options = options);
        },
        afterUpdate(chart) {
          const legend = chart.legend;
          legend.buildLabels(), legend.adjustHitBoxes();
        },
        afterEvent(chart, args) {
          args.replay || chart.legend.handleEvent(args.event);
        },
        defaults: {
          display: !0,
          position: 'top',
          align: 'center',
          fullSize: !0,
          reverse: !1,
          weight: 1e3,
          onClick(e, legendItem, legend) {
            const index = legendItem.datasetIndex,
              ci = legend.chart;
            ci.isDatasetVisible(index)
              ? (ci.hide(index), (legendItem.hidden = !0))
              : (ci.show(index), (legendItem.hidden = !1));
          },
          onHover: null,
          onLeave: null,
          labels: {
            color: (ctx) => ctx.chart.options.color,
            boxWidth: 40,
            padding: 10,
            generateLabels(chart) {
              const datasets = chart.data.datasets,
                {
                  labels: {
                    usePointStyle,
                    pointStyle,
                    textAlign,
                    color,
                    useBorderRadius,
                    borderRadius,
                  },
                } = chart.legend.options;
              return chart._getSortedDatasetMetas().map((meta) => {
                const style = meta.controller.getStyle(
                    usePointStyle ? 0 : void 0
                  ),
                  borderWidth = toPadding(style.borderWidth);
                return {
                  text: datasets[meta.index].label,
                  fillStyle: style.backgroundColor,
                  fontColor: color,
                  hidden: !meta.visible,
                  lineCap: style.borderCapStyle,
                  lineDash: style.borderDash,
                  lineDashOffset: style.borderDashOffset,
                  lineJoin: style.borderJoinStyle,
                  lineWidth: (borderWidth.width + borderWidth.height) / 4,
                  strokeStyle: style.borderColor,
                  pointStyle: pointStyle || style.pointStyle,
                  rotation: style.rotation,
                  textAlign: textAlign || style.textAlign,
                  borderRadius:
                    useBorderRadius && (borderRadius || style.borderRadius),
                  datasetIndex: meta.index,
                };
              }, this);
            },
          },
          title: {
            color: (ctx) => ctx.chart.options.color,
            display: !1,
            position: 'center',
            text: '',
          },
        },
        descriptors: {
          _scriptable: (name) => !name.startsWith('on'),
          labels: {
            _scriptable: (name) =>
              !['generateLabels', 'filter', 'sort'].includes(name),
          },
        },
      };
      new WeakMap();
      const positioners = {
        average(items) {
          if (!items.length) return !1;
          let i,
            len,
            x = 0,
            y = 0,
            count = 0;
          for (i = 0, len = items.length; i < len; ++i) {
            const el = items[i].element;
            if (el && el.hasValue()) {
              const pos = el.tooltipPosition();
              (x += pos.x), (y += pos.y), ++count;
            }
          }
          return { x: x / count, y: y / count };
        },
        nearest(items, eventPosition) {
          if (!items.length) return !1;
          let i,
            len,
            nearestElement,
            x = eventPosition.x,
            y = eventPosition.y,
            minDistance = Number.POSITIVE_INFINITY;
          for (i = 0, len = items.length; i < len; ++i) {
            const el = items[i].element;
            if (el && el.hasValue()) {
              const d = distanceBetweenPoints(
                eventPosition,
                el.getCenterPoint()
              );
              d < minDistance && ((minDistance = d), (nearestElement = el));
            }
          }
          if (nearestElement) {
            const tp = nearestElement.tooltipPosition();
            (x = tp.x), (y = tp.y);
          }
          return { x, y };
        },
      };
      function pushOrConcat(base, toPush) {
        return (
          toPush &&
            (isArray(toPush)
              ? Array.prototype.push.apply(base, toPush)
              : base.push(toPush)),
          base
        );
      }
      function splitNewlines(str) {
        return ('string' == typeof str || str instanceof String) &&
          str.indexOf('\n') > -1
          ? str.split('\n')
          : str;
      }
      function createTooltipItem(chart, item) {
        const { element, datasetIndex, index } = item,
          controller = chart.getDatasetMeta(datasetIndex).controller,
          { label, value } = controller.getLabelAndValue(index);
        return {
          chart,
          label,
          parsed: controller.getParsed(index),
          raw: chart.data.datasets[datasetIndex].data[index],
          formattedValue: value,
          dataset: controller.getDataset(),
          dataIndex: index,
          datasetIndex,
          element,
        };
      }
      function getTooltipSize(tooltip, options) {
        const ctx = tooltip.chart.ctx,
          { body, footer, title } = tooltip,
          { boxWidth, boxHeight } = options,
          bodyFont = toFont(options.bodyFont),
          titleFont = toFont(options.titleFont),
          footerFont = toFont(options.footerFont),
          titleLineCount = title.length,
          footerLineCount = footer.length,
          bodyLineItemCount = body.length,
          padding = toPadding(options.padding);
        let height = padding.height,
          width = 0,
          combinedBodyLength = body.reduce(
            (count, bodyItem) =>
              count +
              bodyItem.before.length +
              bodyItem.lines.length +
              bodyItem.after.length,
            0
          );
        if (
          ((combinedBodyLength +=
            tooltip.beforeBody.length + tooltip.afterBody.length),
          titleLineCount &&
            (height +=
              titleLineCount * titleFont.lineHeight +
              (titleLineCount - 1) * options.titleSpacing +
              options.titleMarginBottom),
          combinedBodyLength)
        ) {
          height +=
            bodyLineItemCount *
              (options.displayColors
                ? Math.max(boxHeight, bodyFont.lineHeight)
                : bodyFont.lineHeight) +
            (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight +
            (combinedBodyLength - 1) * options.bodySpacing;
        }
        footerLineCount &&
          (height +=
            options.footerMarginTop +
            footerLineCount * footerFont.lineHeight +
            (footerLineCount - 1) * options.footerSpacing);
        let widthPadding = 0;
        const maxLineWidth = function (line) {
          width = Math.max(width, ctx.measureText(line).width + widthPadding);
        };
        return (
          ctx.save(),
          (ctx.font = titleFont.string),
          each(tooltip.title, maxLineWidth),
          (ctx.font = bodyFont.string),
          each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth),
          (widthPadding = options.displayColors
            ? boxWidth + 2 + options.boxPadding
            : 0),
          each(body, (bodyItem) => {
            each(bodyItem.before, maxLineWidth),
              each(bodyItem.lines, maxLineWidth),
              each(bodyItem.after, maxLineWidth);
          }),
          (widthPadding = 0),
          (ctx.font = footerFont.string),
          each(tooltip.footer, maxLineWidth),
          ctx.restore(),
          (width += padding.width),
          { width, height }
        );
      }
      function determineXAlign(chart, options, size, yAlign) {
        const { x, width } = size,
          {
            width: chartWidth,
            chartArea: { left, right },
          } = chart;
        let xAlign = 'center';
        return (
          'center' === yAlign
            ? (xAlign = x <= (left + right) / 2 ? 'left' : 'right')
            : x <= width / 2
            ? (xAlign = 'left')
            : x >= chartWidth - width / 2 && (xAlign = 'right'),
          (function doesNotFitWithAlign(xAlign, chart, options, size) {
            const { x, width } = size,
              caret = options.caretSize + options.caretPadding;
            return (
              ('left' === xAlign && x + width + caret > chart.width) ||
              ('right' === xAlign && x - width - caret < 0) ||
              void 0
            );
          })(xAlign, chart, options, size) && (xAlign = 'center'),
          xAlign
        );
      }
      function determineAlignment(chart, options, size) {
        const yAlign =
          size.yAlign ||
          options.yAlign ||
          (function determineYAlign(chart, size) {
            const { y, height } = size;
            return y < height / 2
              ? 'top'
              : y > chart.height - height / 2
              ? 'bottom'
              : 'center';
          })(chart, size);
        return {
          xAlign:
            size.xAlign ||
            options.xAlign ||
            determineXAlign(chart, options, size, yAlign),
          yAlign,
        };
      }
      function getBackgroundPoint(options, size, alignment, chart) {
        const { caretSize, caretPadding, cornerRadius } = options,
          { xAlign, yAlign } = alignment,
          paddingAndSize = caretSize + caretPadding,
          { topLeft, topRight, bottomLeft, bottomRight } =
            toTRBLCorners(cornerRadius);
        let x = (function alignX(size, xAlign) {
          let { x, width } = size;
          return (
            'right' === xAlign
              ? (x -= width)
              : 'center' === xAlign && (x -= width / 2),
            x
          );
        })(size, xAlign);
        const y = (function alignY(size, yAlign, paddingAndSize) {
          let { y, height } = size;
          return (
            'top' === yAlign
              ? (y += paddingAndSize)
              : (y -=
                  'bottom' === yAlign ? height + paddingAndSize : height / 2),
            y
          );
        })(size, yAlign, paddingAndSize);
        return (
          'center' === yAlign
            ? 'left' === xAlign
              ? (x += paddingAndSize)
              : 'right' === xAlign && (x -= paddingAndSize)
            : 'left' === xAlign
            ? (x -= Math.max(topLeft, bottomLeft) + caretSize)
            : 'right' === xAlign &&
              (x += Math.max(topRight, bottomRight) + caretSize),
          {
            x: _limitValue(x, 0, chart.width - size.width),
            y: _limitValue(y, 0, chart.height - size.height),
          }
        );
      }
      function getAlignedX(tooltip, align, options) {
        const padding = toPadding(options.padding);
        return 'center' === align
          ? tooltip.x + tooltip.width / 2
          : 'right' === align
          ? tooltip.x + tooltip.width - padding.right
          : tooltip.x + padding.left;
      }
      function getBeforeAfterBodyLines(callback) {
        return pushOrConcat([], splitNewlines(callback));
      }
      function overrideCallbacks(callbacks, context) {
        const override =
          context &&
          context.dataset &&
          context.dataset.tooltip &&
          context.dataset.tooltip.callbacks;
        return override ? callbacks.override(override) : callbacks;
      }
      const defaultCallbacks = {
        beforeTitle: noop,
        title(tooltipItems) {
          if (tooltipItems.length > 0) {
            const item = tooltipItems[0],
              labels = item.chart.data.labels,
              labelCount = labels ? labels.length : 0;
            if (this && this.options && 'dataset' === this.options.mode)
              return item.dataset.label || '';
            if (item.label) return item.label;
            if (labelCount > 0 && item.dataIndex < labelCount)
              return labels[item.dataIndex];
          }
          return '';
        },
        afterTitle: noop,
        beforeBody: noop,
        beforeLabel: noop,
        label(tooltipItem) {
          if (this && this.options && 'dataset' === this.options.mode)
            return (
              tooltipItem.label + ': ' + tooltipItem.formattedValue ||
              tooltipItem.formattedValue
            );
          let label = tooltipItem.dataset.label || '';
          label && (label += ': ');
          const value = tooltipItem.formattedValue;
          return isNullOrUndef(value) || (label += value), label;
        },
        labelColor(tooltipItem) {
          const options = tooltipItem.chart
            .getDatasetMeta(tooltipItem.datasetIndex)
            .controller.getStyle(tooltipItem.dataIndex);
          return {
            borderColor: options.borderColor,
            backgroundColor: options.backgroundColor,
            borderWidth: options.borderWidth,
            borderDash: options.borderDash,
            borderDashOffset: options.borderDashOffset,
            borderRadius: 0,
          };
        },
        labelTextColor() {
          return this.options.bodyColor;
        },
        labelPointStyle(tooltipItem) {
          const options = tooltipItem.chart
            .getDatasetMeta(tooltipItem.datasetIndex)
            .controller.getStyle(tooltipItem.dataIndex);
          return { pointStyle: options.pointStyle, rotation: options.rotation };
        },
        afterLabel: noop,
        afterBody: noop,
        beforeFooter: noop,
        footer: noop,
        afterFooter: noop,
      };
      function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
        const result = callbacks[name].call(ctx, arg);
        return void 0 === result
          ? defaultCallbacks[name].call(ctx, arg)
          : result;
      }
      class Tooltip extends Element {
        static positioners = positioners;
        constructor(config) {
          super(),
            (this.opacity = 0),
            (this._active = []),
            (this._eventPosition = void 0),
            (this._size = void 0),
            (this._cachedAnimations = void 0),
            (this._tooltipItems = []),
            (this.$animations = void 0),
            (this.$context = void 0),
            (this.chart = config.chart),
            (this.options = config.options),
            (this.dataPoints = void 0),
            (this.title = void 0),
            (this.beforeBody = void 0),
            (this.body = void 0),
            (this.afterBody = void 0),
            (this.footer = void 0),
            (this.xAlign = void 0),
            (this.yAlign = void 0),
            (this.x = void 0),
            (this.y = void 0),
            (this.height = void 0),
            (this.width = void 0),
            (this.caretX = void 0),
            (this.caretY = void 0),
            (this.labelColors = void 0),
            (this.labelPointStyles = void 0),
            (this.labelTextColors = void 0);
        }
        initialize(options) {
          (this.options = options),
            (this._cachedAnimations = void 0),
            (this.$context = void 0);
        }
        _resolveAnimations() {
          const cached = this._cachedAnimations;
          if (cached) return cached;
          const chart = this.chart,
            options = this.options.setContext(this.getContext()),
            opts =
              options.enabled && chart.options.animation && options.animations,
            animations = new Animations(this.chart, opts);
          return (
            opts._cacheable &&
              (this._cachedAnimations = Object.freeze(animations)),
            animations
          );
        }
        getContext() {
          return (
            this.$context ||
            (this.$context = (function createTooltipContext(
              parent,
              tooltip,
              tooltipItems
            ) {
              return createContext(parent, {
                tooltip,
                tooltipItems,
                type: 'tooltip',
              });
            })(this.chart.getContext(), this, this._tooltipItems))
          );
        }
        getTitle(context, options) {
          const { callbacks } = options,
            beforeTitle = invokeCallbackWithFallback(
              callbacks,
              'beforeTitle',
              this,
              context
            ),
            title = invokeCallbackWithFallback(
              callbacks,
              'title',
              this,
              context
            ),
            afterTitle = invokeCallbackWithFallback(
              callbacks,
              'afterTitle',
              this,
              context
            );
          let lines = [];
          return (
            (lines = pushOrConcat(lines, splitNewlines(beforeTitle))),
            (lines = pushOrConcat(lines, splitNewlines(title))),
            (lines = pushOrConcat(lines, splitNewlines(afterTitle))),
            lines
          );
        }
        getBeforeBody(tooltipItems, options) {
          return getBeforeAfterBodyLines(
            invokeCallbackWithFallback(
              options.callbacks,
              'beforeBody',
              this,
              tooltipItems
            )
          );
        }
        getBody(tooltipItems, options) {
          const { callbacks } = options,
            bodyItems = [];
          return (
            each(tooltipItems, (context) => {
              const bodyItem = { before: [], lines: [], after: [] },
                scoped = overrideCallbacks(callbacks, context);
              pushOrConcat(
                bodyItem.before,
                splitNewlines(
                  invokeCallbackWithFallback(
                    scoped,
                    'beforeLabel',
                    this,
                    context
                  )
                )
              ),
                pushOrConcat(
                  bodyItem.lines,
                  invokeCallbackWithFallback(scoped, 'label', this, context)
                ),
                pushOrConcat(
                  bodyItem.after,
                  splitNewlines(
                    invokeCallbackWithFallback(
                      scoped,
                      'afterLabel',
                      this,
                      context
                    )
                  )
                ),
                bodyItems.push(bodyItem);
            }),
            bodyItems
          );
        }
        getAfterBody(tooltipItems, options) {
          return getBeforeAfterBodyLines(
            invokeCallbackWithFallback(
              options.callbacks,
              'afterBody',
              this,
              tooltipItems
            )
          );
        }
        getFooter(tooltipItems, options) {
          const { callbacks } = options,
            beforeFooter = invokeCallbackWithFallback(
              callbacks,
              'beforeFooter',
              this,
              tooltipItems
            ),
            footer = invokeCallbackWithFallback(
              callbacks,
              'footer',
              this,
              tooltipItems
            ),
            afterFooter = invokeCallbackWithFallback(
              callbacks,
              'afterFooter',
              this,
              tooltipItems
            );
          let lines = [];
          return (
            (lines = pushOrConcat(lines, splitNewlines(beforeFooter))),
            (lines = pushOrConcat(lines, splitNewlines(footer))),
            (lines = pushOrConcat(lines, splitNewlines(afterFooter))),
            lines
          );
        }
        _createItems(options) {
          const active = this._active,
            data = this.chart.data,
            labelColors = [],
            labelPointStyles = [],
            labelTextColors = [];
          let i,
            len,
            tooltipItems = [];
          for (i = 0, len = active.length; i < len; ++i)
            tooltipItems.push(createTooltipItem(this.chart, active[i]));
          return (
            options.filter &&
              (tooltipItems = tooltipItems.filter((element, index, array) =>
                options.filter(element, index, array, data)
              )),
            options.itemSort &&
              (tooltipItems = tooltipItems.sort((a, b) =>
                options.itemSort(a, b, data)
              )),
            each(tooltipItems, (context) => {
              const scoped = overrideCallbacks(options.callbacks, context);
              labelColors.push(
                invokeCallbackWithFallback(scoped, 'labelColor', this, context)
              ),
                labelPointStyles.push(
                  invokeCallbackWithFallback(
                    scoped,
                    'labelPointStyle',
                    this,
                    context
                  )
                ),
                labelTextColors.push(
                  invokeCallbackWithFallback(
                    scoped,
                    'labelTextColor',
                    this,
                    context
                  )
                );
            }),
            (this.labelColors = labelColors),
            (this.labelPointStyles = labelPointStyles),
            (this.labelTextColors = labelTextColors),
            (this.dataPoints = tooltipItems),
            tooltipItems
          );
        }
        update(changed, replay) {
          const options = this.options.setContext(this.getContext()),
            active = this._active;
          let properties,
            tooltipItems = [];
          if (active.length) {
            const position = positioners[options.position].call(
              this,
              active,
              this._eventPosition
            );
            (tooltipItems = this._createItems(options)),
              (this.title = this.getTitle(tooltipItems, options)),
              (this.beforeBody = this.getBeforeBody(tooltipItems, options)),
              (this.body = this.getBody(tooltipItems, options)),
              (this.afterBody = this.getAfterBody(tooltipItems, options)),
              (this.footer = this.getFooter(tooltipItems, options));
            const size = (this._size = getTooltipSize(this, options)),
              positionAndSize = Object.assign({}, position, size),
              alignment = determineAlignment(
                this.chart,
                options,
                positionAndSize
              ),
              backgroundPoint = getBackgroundPoint(
                options,
                positionAndSize,
                alignment,
                this.chart
              );
            (this.xAlign = alignment.xAlign),
              (this.yAlign = alignment.yAlign),
              (properties = {
                opacity: 1,
                x: backgroundPoint.x,
                y: backgroundPoint.y,
                width: size.width,
                height: size.height,
                caretX: position.x,
                caretY: position.y,
              });
          } else 0 !== this.opacity && (properties = { opacity: 0 });
          (this._tooltipItems = tooltipItems),
            (this.$context = void 0),
            properties && this._resolveAnimations().update(this, properties),
            changed &&
              options.external &&
              options.external.call(this, {
                chart: this.chart,
                tooltip: this,
                replay,
              });
        }
        drawCaret(tooltipPoint, ctx, size, options) {
          const caretPosition = this.getCaretPosition(
            tooltipPoint,
            size,
            options
          );
          ctx.lineTo(caretPosition.x1, caretPosition.y1),
            ctx.lineTo(caretPosition.x2, caretPosition.y2),
            ctx.lineTo(caretPosition.x3, caretPosition.y3);
        }
        getCaretPosition(tooltipPoint, size, options) {
          const { xAlign, yAlign } = this,
            { caretSize, cornerRadius } = options,
            { topLeft, topRight, bottomLeft, bottomRight } =
              toTRBLCorners(cornerRadius),
            { x: ptX, y: ptY } = tooltipPoint,
            { width, height } = size;
          let x1, x2, x3, y1, y2, y3;
          return (
            'center' === yAlign
              ? ((y2 = ptY + height / 2),
                'left' === xAlign
                  ? ((x1 = ptX),
                    (x2 = x1 - caretSize),
                    (y1 = y2 + caretSize),
                    (y3 = y2 - caretSize))
                  : ((x1 = ptX + width),
                    (x2 = x1 + caretSize),
                    (y1 = y2 - caretSize),
                    (y3 = y2 + caretSize)),
                (x3 = x1))
              : ((x2 =
                  'left' === xAlign
                    ? ptX + Math.max(topLeft, bottomLeft) + caretSize
                    : 'right' === xAlign
                    ? ptX + width - Math.max(topRight, bottomRight) - caretSize
                    : this.caretX),
                'top' === yAlign
                  ? ((y1 = ptY),
                    (y2 = y1 - caretSize),
                    (x1 = x2 - caretSize),
                    (x3 = x2 + caretSize))
                  : ((y1 = ptY + height),
                    (y2 = y1 + caretSize),
                    (x1 = x2 + caretSize),
                    (x3 = x2 - caretSize)),
                (y3 = y1)),
            { x1, x2, x3, y1, y2, y3 }
          );
        }
        drawTitle(pt, ctx, options) {
          const title = this.title,
            length = title.length;
          let titleFont, titleSpacing, i;
          if (length) {
            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
            for (
              pt.x = getAlignedX(this, options.titleAlign, options),
                ctx.textAlign = rtlHelper.textAlign(options.titleAlign),
                ctx.textBaseline = 'middle',
                titleFont = toFont(options.titleFont),
                titleSpacing = options.titleSpacing,
                ctx.fillStyle = options.titleColor,
                ctx.font = titleFont.string,
                i = 0;
              i < length;
              ++i
            )
              ctx.fillText(
                title[i],
                rtlHelper.x(pt.x),
                pt.y + titleFont.lineHeight / 2
              ),
                (pt.y += titleFont.lineHeight + titleSpacing),
                i + 1 === length &&
                  (pt.y += options.titleMarginBottom - titleSpacing);
          }
        }
        _drawColorBox(ctx, pt, i, rtlHelper, options) {
          const labelColors = this.labelColors[i],
            labelPointStyle = this.labelPointStyles[i],
            { boxHeight, boxWidth, boxPadding } = options,
            bodyFont = toFont(options.bodyFont),
            colorX = getAlignedX(this, 'left', options),
            rtlColorX = rtlHelper.x(colorX),
            yOffSet =
              boxHeight < bodyFont.lineHeight
                ? (bodyFont.lineHeight - boxHeight) / 2
                : 0,
            colorY = pt.y + yOffSet;
          if (options.usePointStyle) {
            const drawOptions = {
                radius: Math.min(boxWidth, boxHeight) / 2,
                pointStyle: labelPointStyle.pointStyle,
                rotation: labelPointStyle.rotation,
                borderWidth: 1,
              },
              centerX =
                rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2,
              centerY = colorY + boxHeight / 2;
            (ctx.strokeStyle = options.multiKeyBackground),
              (ctx.fillStyle = options.multiKeyBackground),
              drawPoint(ctx, drawOptions, centerX, centerY),
              (ctx.strokeStyle = labelColors.borderColor),
              (ctx.fillStyle = labelColors.backgroundColor),
              drawPoint(ctx, drawOptions, centerX, centerY);
          } else {
            (ctx.lineWidth = isObject(labelColors.borderWidth)
              ? Math.max(...Object.values(labelColors.borderWidth))
              : labelColors.borderWidth || 1),
              (ctx.strokeStyle = labelColors.borderColor),
              ctx.setLineDash(labelColors.borderDash || []),
              (ctx.lineDashOffset = labelColors.borderDashOffset || 0);
            const outerX = rtlHelper.leftForLtr(
                rtlColorX,
                boxWidth - boxPadding
              ),
              innerX = rtlHelper.leftForLtr(
                rtlHelper.xPlus(rtlColorX, 1),
                boxWidth - boxPadding - 2
              ),
              borderRadius = toTRBLCorners(labelColors.borderRadius);
            Object.values(borderRadius).some((v) => 0 !== v)
              ? (ctx.beginPath(),
                (ctx.fillStyle = options.multiKeyBackground),
                addRoundedRectPath(ctx, {
                  x: outerX,
                  y: colorY,
                  w: boxWidth,
                  h: boxHeight,
                  radius: borderRadius,
                }),
                ctx.fill(),
                ctx.stroke(),
                (ctx.fillStyle = labelColors.backgroundColor),
                ctx.beginPath(),
                addRoundedRectPath(ctx, {
                  x: innerX,
                  y: colorY + 1,
                  w: boxWidth - 2,
                  h: boxHeight - 2,
                  radius: borderRadius,
                }),
                ctx.fill())
              : ((ctx.fillStyle = options.multiKeyBackground),
                ctx.fillRect(outerX, colorY, boxWidth, boxHeight),
                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight),
                (ctx.fillStyle = labelColors.backgroundColor),
                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2));
          }
          ctx.fillStyle = this.labelTextColors[i];
        }
        drawBody(pt, ctx, options) {
          const { body } = this,
            {
              bodySpacing,
              bodyAlign,
              displayColors,
              boxHeight,
              boxWidth,
              boxPadding,
            } = options,
            bodyFont = toFont(options.bodyFont);
          let bodyLineHeight = bodyFont.lineHeight,
            xLinePadding = 0;
          const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width),
            fillLineOfText = function (line) {
              ctx.fillText(
                line,
                rtlHelper.x(pt.x + xLinePadding),
                pt.y + bodyLineHeight / 2
              ),
                (pt.y += bodyLineHeight + bodySpacing);
            },
            bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
          let bodyItem, textColor, lines, i, j, ilen, jlen;
          for (
            ctx.textAlign = bodyAlign,
              ctx.textBaseline = 'middle',
              ctx.font = bodyFont.string,
              pt.x = getAlignedX(this, bodyAlignForCalculation, options),
              ctx.fillStyle = options.bodyColor,
              each(this.beforeBody, fillLineOfText),
              xLinePadding =
                displayColors && 'right' !== bodyAlignForCalculation
                  ? 'center' === bodyAlign
                    ? boxWidth / 2 + boxPadding
                    : boxWidth + 2 + boxPadding
                  : 0,
              i = 0,
              ilen = body.length;
            i < ilen;
            ++i
          ) {
            for (
              bodyItem = body[i],
                textColor = this.labelTextColors[i],
                ctx.fillStyle = textColor,
                each(bodyItem.before, fillLineOfText),
                lines = bodyItem.lines,
                displayColors &&
                  lines.length &&
                  (this._drawColorBox(ctx, pt, i, rtlHelper, options),
                  (bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight))),
                j = 0,
                jlen = lines.length;
              j < jlen;
              ++j
            )
              fillLineOfText(lines[j]), (bodyLineHeight = bodyFont.lineHeight);
            each(bodyItem.after, fillLineOfText);
          }
          (xLinePadding = 0),
            (bodyLineHeight = bodyFont.lineHeight),
            each(this.afterBody, fillLineOfText),
            (pt.y -= bodySpacing);
        }
        drawFooter(pt, ctx, options) {
          const footer = this.footer,
            length = footer.length;
          let footerFont, i;
          if (length) {
            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
            for (
              pt.x = getAlignedX(this, options.footerAlign, options),
                pt.y += options.footerMarginTop,
                ctx.textAlign = rtlHelper.textAlign(options.footerAlign),
                ctx.textBaseline = 'middle',
                footerFont = toFont(options.footerFont),
                ctx.fillStyle = options.footerColor,
                ctx.font = footerFont.string,
                i = 0;
              i < length;
              ++i
            )
              ctx.fillText(
                footer[i],
                rtlHelper.x(pt.x),
                pt.y + footerFont.lineHeight / 2
              ),
                (pt.y += footerFont.lineHeight + options.footerSpacing);
          }
        }
        drawBackground(pt, ctx, tooltipSize, options) {
          const { xAlign, yAlign } = this,
            { x, y } = pt,
            { width, height } = tooltipSize,
            { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(
              options.cornerRadius
            );
          (ctx.fillStyle = options.backgroundColor),
            (ctx.strokeStyle = options.borderColor),
            (ctx.lineWidth = options.borderWidth),
            ctx.beginPath(),
            ctx.moveTo(x + topLeft, y),
            'top' === yAlign && this.drawCaret(pt, ctx, tooltipSize, options),
            ctx.lineTo(x + width - topRight, y),
            ctx.quadraticCurveTo(x + width, y, x + width, y + topRight),
            'center' === yAlign &&
              'right' === xAlign &&
              this.drawCaret(pt, ctx, tooltipSize, options),
            ctx.lineTo(x + width, y + height - bottomRight),
            ctx.quadraticCurveTo(
              x + width,
              y + height,
              x + width - bottomRight,
              y + height
            ),
            'bottom' === yAlign &&
              this.drawCaret(pt, ctx, tooltipSize, options),
            ctx.lineTo(x + bottomLeft, y + height),
            ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft),
            'center' === yAlign &&
              'left' === xAlign &&
              this.drawCaret(pt, ctx, tooltipSize, options),
            ctx.lineTo(x, y + topLeft),
            ctx.quadraticCurveTo(x, y, x + topLeft, y),
            ctx.closePath(),
            ctx.fill(),
            options.borderWidth > 0 && ctx.stroke();
        }
        _updateAnimationTarget(options) {
          const chart = this.chart,
            anims = this.$animations,
            animX = anims && anims.x,
            animY = anims && anims.y;
          if (animX || animY) {
            const position = positioners[options.position].call(
              this,
              this._active,
              this._eventPosition
            );
            if (!position) return;
            const size = (this._size = getTooltipSize(this, options)),
              positionAndSize = Object.assign({}, position, this._size),
              alignment = determineAlignment(chart, options, positionAndSize),
              point = getBackgroundPoint(
                options,
                positionAndSize,
                alignment,
                chart
              );
            (animX._to === point.x && animY._to === point.y) ||
              ((this.xAlign = alignment.xAlign),
              (this.yAlign = alignment.yAlign),
              (this.width = size.width),
              (this.height = size.height),
              (this.caretX = position.x),
              (this.caretY = position.y),
              this._resolveAnimations().update(this, point));
          }
        }
        _willRender() {
          return !!this.opacity;
        }
        draw(ctx) {
          const options = this.options.setContext(this.getContext());
          let opacity = this.opacity;
          if (!opacity) return;
          this._updateAnimationTarget(options);
          const tooltipSize = { width: this.width, height: this.height },
            pt = { x: this.x, y: this.y };
          opacity = Math.abs(opacity) < 0.001 ? 0 : opacity;
          const padding = toPadding(options.padding),
            hasTooltipContent =
              this.title.length ||
              this.beforeBody.length ||
              this.body.length ||
              this.afterBody.length ||
              this.footer.length;
          options.enabled &&
            hasTooltipContent &&
            (ctx.save(),
            (ctx.globalAlpha = opacity),
            this.drawBackground(pt, ctx, tooltipSize, options),
            overrideTextDirection(ctx, options.textDirection),
            (pt.y += padding.top),
            this.drawTitle(pt, ctx, options),
            this.drawBody(pt, ctx, options),
            this.drawFooter(pt, ctx, options),
            restoreTextDirection(ctx, options.textDirection),
            ctx.restore());
        }
        getActiveElements() {
          return this._active || [];
        }
        setActiveElements(activeElements, eventPosition) {
          const lastActive = this._active,
            active = activeElements.map(({ datasetIndex, index }) => {
              const meta = this.chart.getDatasetMeta(datasetIndex);
              if (!meta)
                throw new Error(
                  'Cannot find a dataset at index ' + datasetIndex
                );
              return { datasetIndex, element: meta.data[index], index };
            }),
            changed = !_elementsEqual(lastActive, active),
            positionChanged = this._positionChanged(active, eventPosition);
          (changed || positionChanged) &&
            ((this._active = active),
            (this._eventPosition = eventPosition),
            (this._ignoreReplayEvents = !0),
            this.update(!0));
        }
        handleEvent(e, replay, inChartArea = !0) {
          if (replay && this._ignoreReplayEvents) return !1;
          this._ignoreReplayEvents = !1;
          const options = this.options,
            lastActive = this._active || [],
            active = this._getActiveElements(
              e,
              lastActive,
              replay,
              inChartArea
            ),
            positionChanged = this._positionChanged(active, e),
            changed =
              replay || !_elementsEqual(active, lastActive) || positionChanged;
          return (
            changed &&
              ((this._active = active),
              (options.enabled || options.external) &&
                ((this._eventPosition = { x: e.x, y: e.y }),
                this.update(!0, replay))),
            changed
          );
        }
        _getActiveElements(e, lastActive, replay, inChartArea) {
          const options = this.options;
          if ('mouseout' === e.type) return [];
          if (!inChartArea) return lastActive;
          const active = this.chart.getElementsAtEventForMode(
            e,
            options.mode,
            options,
            replay
          );
          return options.reverse && active.reverse(), active;
        }
        _positionChanged(active, e) {
          const { caretX, caretY, options } = this,
            position = positioners[options.position].call(this, active, e);
          return (
            !1 !== position && (caretX !== position.x || caretY !== position.y)
          );
        }
      }
      var plugin_tooltip = {
        id: 'tooltip',
        _element: Tooltip,
        positioners,
        afterInit(chart, _args, options) {
          options && (chart.tooltip = new Tooltip({ chart, options }));
        },
        beforeUpdate(chart, _args, options) {
          chart.tooltip && chart.tooltip.initialize(options);
        },
        reset(chart, _args, options) {
          chart.tooltip && chart.tooltip.initialize(options);
        },
        afterDraw(chart) {
          const tooltip = chart.tooltip;
          if (tooltip && tooltip._willRender()) {
            const args = { tooltip };
            if (
              !1 ===
              chart.notifyPlugins('beforeTooltipDraw', {
                ...args,
                cancelable: !0,
              })
            )
              return;
            tooltip.draw(chart.ctx),
              chart.notifyPlugins('afterTooltipDraw', args);
          }
        },
        afterEvent(chart, args) {
          if (chart.tooltip) {
            const useFinalPosition = args.replay;
            chart.tooltip.handleEvent(
              args.event,
              useFinalPosition,
              args.inChartArea
            ) && (args.changed = !0);
          }
        },
        defaults: {
          enabled: !0,
          external: null,
          position: 'average',
          backgroundColor: 'rgba(0,0,0,0.8)',
          titleColor: '#fff',
          titleFont: { weight: 'bold' },
          titleSpacing: 2,
          titleMarginBottom: 6,
          titleAlign: 'left',
          bodyColor: '#fff',
          bodySpacing: 2,
          bodyFont: {},
          bodyAlign: 'left',
          footerColor: '#fff',
          footerSpacing: 2,
          footerMarginTop: 6,
          footerFont: { weight: 'bold' },
          footerAlign: 'left',
          padding: 6,
          caretPadding: 2,
          caretSize: 5,
          cornerRadius: 6,
          boxHeight: (ctx, opts) => opts.bodyFont.size,
          boxWidth: (ctx, opts) => opts.bodyFont.size,
          multiKeyBackground: '#fff',
          displayColors: !0,
          boxPadding: 0,
          borderColor: 'rgba(0,0,0,0)',
          borderWidth: 0,
          animation: { duration: 400, easing: 'easeOutQuart' },
          animations: {
            numbers: {
              type: 'number',
              properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],
            },
            opacity: { easing: 'linear', duration: 200 },
          },
          callbacks: defaultCallbacks,
        },
        defaultRoutes: {
          bodyFont: 'font',
          footerFont: 'font',
          titleFont: 'font',
        },
        descriptors: {
          _scriptable: (name) =>
            'filter' !== name && 'itemSort' !== name && 'external' !== name,
          _indexable: !1,
          callbacks: { _scriptable: !1, _indexable: !1 },
          animation: { _fallback: !1 },
          animations: { _fallback: 'animation' },
        },
        additionalOptionScopes: ['interaction'],
      };
      const addIfString = (labels, raw, index, addedLabels) => (
        'string' == typeof raw
          ? ((index = labels.push(raw) - 1),
            addedLabels.unshift({ index, label: raw }))
          : isNaN(raw) && (index = null),
        index
      );
      function _getLabelForValue(value) {
        const labels = this.getLabels();
        return value >= 0 && value < labels.length ? labels[value] : value;
      }
      class CategoryScale extends Scale {
        static id = 'category';
        static defaults = { ticks: { callback: _getLabelForValue } };
        constructor(cfg) {
          super(cfg),
            (this._startValue = void 0),
            (this._valueRange = 0),
            (this._addedLabels = []);
        }
        init(scaleOptions) {
          const added = this._addedLabels;
          if (added.length) {
            const labels = this.getLabels();
            for (const { index, label } of added)
              labels[index] === label && labels.splice(index, 1);
            this._addedLabels = [];
          }
          super.init(scaleOptions);
        }
        parse(raw, index) {
          if (isNullOrUndef(raw)) return null;
          const labels = this.getLabels();
          return (
            (index =
              isFinite(index) && labels[index] === raw
                ? index
                : (function findOrAddLabel(labels, raw, index, addedLabels) {
                    const first = labels.indexOf(raw);
                    return -1 === first
                      ? addIfString(labels, raw, index, addedLabels)
                      : first !== labels.lastIndexOf(raw)
                      ? index
                      : first;
                  })(
                    labels,
                    raw,
                    valueOrDefault(index, raw),
                    this._addedLabels
                  )),
            ((index, max) =>
              null === index ? null : _limitValue(Math.round(index), 0, max))(
              index,
              labels.length - 1
            )
          );
        }
        determineDataLimits() {
          const { minDefined, maxDefined } = this.getUserBounds();
          let { min, max } = this.getMinMax(!0);
          'ticks' === this.options.bounds &&
            (minDefined || (min = 0),
            maxDefined || (max = this.getLabels().length - 1)),
            (this.min = min),
            (this.max = max);
        }
        buildTicks() {
          const min = this.min,
            max = this.max,
            offset = this.options.offset,
            ticks = [];
          let labels = this.getLabels();
          (labels =
            0 === min && max === labels.length - 1
              ? labels
              : labels.slice(min, max + 1)),
            (this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1)),
            (this._startValue = this.min - (offset ? 0.5 : 0));
          for (let value = min; value <= max; value++) ticks.push({ value });
          return ticks;
        }
        getLabelForValue(value) {
          return _getLabelForValue.call(this, value);
        }
        configure() {
          super.configure(),
            this.isHorizontal() || (this._reversePixels = !this._reversePixels);
        }
        getPixelForValue(value) {
          return (
            'number' != typeof value && (value = this.parse(value)),
            null === value
              ? NaN
              : this.getPixelForDecimal(
                  (value - this._startValue) / this._valueRange
                )
          );
        }
        getPixelForTick(index) {
          const ticks = this.ticks;
          return index < 0 || index > ticks.length - 1
            ? null
            : this.getPixelForValue(ticks[index].value);
        }
        getValueForPixel(pixel) {
          return Math.round(
            this._startValue + this.getDecimalForPixel(pixel) * this._valueRange
          );
        }
        getBasePixel() {
          return this.bottom;
        }
      }
      function generateTicks$1(generationOptions, dataRange) {
        const ticks = [],
          {
            bounds,
            step,
            min,
            max,
            precision,
            count,
            maxTicks,
            maxDigits,
            includeBounds,
          } = generationOptions,
          unit = step || 1,
          maxSpaces = maxTicks - 1,
          { min: rmin, max: rmax } = dataRange,
          minDefined = !isNullOrUndef(min),
          maxDefined = !isNullOrUndef(max),
          countDefined = !isNullOrUndef(count),
          minSpacing = (rmax - rmin) / (maxDigits + 1);
        let factor,
          niceMin,
          niceMax,
          numSpaces,
          spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
        if (spacing < 1e-14 && !minDefined && !maxDefined)
          return [{ value: rmin }, { value: rmax }];
        (numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing)),
          numSpaces > maxSpaces &&
            (spacing =
              niceNum((numSpaces * spacing) / maxSpaces / unit) * unit),
          isNullOrUndef(precision) ||
            ((factor = Math.pow(10, precision)),
            (spacing = Math.ceil(spacing * factor) / factor)),
          'ticks' === bounds
            ? ((niceMin = Math.floor(rmin / spacing) * spacing),
              (niceMax = Math.ceil(rmax / spacing) * spacing))
            : ((niceMin = rmin), (niceMax = rmax)),
          minDefined &&
          maxDefined &&
          step &&
          (function almostWhole(x, epsilon) {
            const rounded = Math.round(x);
            return rounded - epsilon <= x && rounded + epsilon >= x;
          })((max - min) / step, spacing / 1e3)
            ? ((numSpaces = Math.round(
                Math.min((max - min) / spacing, maxTicks)
              )),
              (spacing = (max - min) / numSpaces),
              (niceMin = min),
              (niceMax = max))
            : countDefined
            ? ((niceMin = minDefined ? min : niceMin),
              (niceMax = maxDefined ? max : niceMax),
              (numSpaces = count - 1),
              (spacing = (niceMax - niceMin) / numSpaces))
            : ((numSpaces = (niceMax - niceMin) / spacing),
              (numSpaces = almostEquals(
                numSpaces,
                Math.round(numSpaces),
                spacing / 1e3
              )
                ? Math.round(numSpaces)
                : Math.ceil(numSpaces)));
        const decimalPlaces = Math.max(
          _decimalPlaces(spacing),
          _decimalPlaces(niceMin)
        );
        (factor = Math.pow(
          10,
          isNullOrUndef(precision) ? decimalPlaces : precision
        )),
          (niceMin = Math.round(niceMin * factor) / factor),
          (niceMax = Math.round(niceMax * factor) / factor);
        let j = 0;
        for (
          minDefined &&
          (includeBounds && niceMin !== min
            ? (ticks.push({ value: min }),
              niceMin < min && j++,
              almostEquals(
                Math.round((niceMin + j * spacing) * factor) / factor,
                min,
                relativeLabelSize(min, minSpacing, generationOptions)
              ) && j++)
            : niceMin < min && j++);
          j < numSpaces;
          ++j
        )
          ticks.push({
            value: Math.round((niceMin + j * spacing) * factor) / factor,
          });
        return (
          maxDefined && includeBounds && niceMax !== max
            ? ticks.length &&
              almostEquals(
                ticks[ticks.length - 1].value,
                max,
                relativeLabelSize(max, minSpacing, generationOptions)
              )
              ? (ticks[ticks.length - 1].value = max)
              : ticks.push({ value: max })
            : (maxDefined && niceMax !== max) || ticks.push({ value: niceMax }),
          ticks
        );
      }
      function relativeLabelSize(
        value,
        minSpacing,
        { horizontal, minRotation }
      ) {
        const rad = toRadians(minRotation),
          ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001,
          length = 0.75 * minSpacing * ('' + value).length;
        return Math.min(minSpacing / ratio, length);
      }
      class LinearScaleBase extends Scale {
        constructor(cfg) {
          super(cfg),
            (this.start = void 0),
            (this.end = void 0),
            (this._startValue = void 0),
            (this._endValue = void 0),
            (this._valueRange = 0);
        }
        parse(raw, index) {
          return isNullOrUndef(raw) ||
            (('number' == typeof raw || raw instanceof Number) &&
              !isFinite(+raw))
            ? null
            : +raw;
        }
        handleTickRangeOptions() {
          const { beginAtZero } = this.options,
            { minDefined, maxDefined } = this.getUserBounds();
          let { min, max } = this;
          const setMin = (v) => (min = minDefined ? min : v),
            setMax = (v) => (max = maxDefined ? max : v);
          if (beginAtZero) {
            const minSign = sign(min),
              maxSign = sign(max);
            minSign < 0 && maxSign < 0
              ? setMax(0)
              : minSign > 0 && maxSign > 0 && setMin(0);
          }
          if (min === max) {
            let offset = 0 === max ? 1 : Math.abs(0.05 * max);
            setMax(max + offset), beginAtZero || setMin(min - offset);
          }
          (this.min = min), (this.max = max);
        }
        getTickLimit() {
          const tickOpts = this.options.ticks;
          let maxTicks,
            { maxTicksLimit, stepSize } = tickOpts;
          return (
            stepSize
              ? ((maxTicks =
                  Math.ceil(this.max / stepSize) -
                  Math.floor(this.min / stepSize) +
                  1),
                maxTicks > 1e3 &&
                  (console.warn(
                    `scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`
                  ),
                  (maxTicks = 1e3)))
              : ((maxTicks = this.computeTickLimit()),
                (maxTicksLimit = maxTicksLimit || 11)),
            maxTicksLimit && (maxTicks = Math.min(maxTicksLimit, maxTicks)),
            maxTicks
          );
        }
        computeTickLimit() {
          return Number.POSITIVE_INFINITY;
        }
        buildTicks() {
          const opts = this.options,
            tickOpts = opts.ticks;
          let maxTicks = this.getTickLimit();
          maxTicks = Math.max(2, maxTicks);
          const ticks = generateTicks$1(
            {
              maxTicks,
              bounds: opts.bounds,
              min: opts.min,
              max: opts.max,
              precision: tickOpts.precision,
              step: tickOpts.stepSize,
              count: tickOpts.count,
              maxDigits: this._maxDigits(),
              horizontal: this.isHorizontal(),
              minRotation: tickOpts.minRotation || 0,
              includeBounds: !1 !== tickOpts.includeBounds,
            },
            this._range || this
          );
          return (
            'ticks' === opts.bounds && _setMinAndMaxByKey(ticks, this, 'value'),
            opts.reverse
              ? (ticks.reverse(),
                (this.start = this.max),
                (this.end = this.min))
              : ((this.start = this.min), (this.end = this.max)),
            ticks
          );
        }
        configure() {
          const ticks = this.ticks;
          let start = this.min,
            end = this.max;
          if ((super.configure(), this.options.offset && ticks.length)) {
            const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
            (start -= offset), (end += offset);
          }
          (this._startValue = start),
            (this._endValue = end),
            (this._valueRange = end - start);
        }
        getLabelForValue(value) {
          return formatNumber(
            value,
            this.chart.options.locale,
            this.options.ticks.format
          );
        }
      }
      class LinearScale extends LinearScaleBase {
        static id = 'linear';
        static defaults = { ticks: { callback: Ticks.formatters.numeric } };
        determineDataLimits() {
          const { min, max } = this.getMinMax(!0);
          (this.min = isNumberFinite(min) ? min : 0),
            (this.max = isNumberFinite(max) ? max : 1),
            this.handleTickRangeOptions();
        }
        computeTickLimit() {
          const horizontal = this.isHorizontal(),
            length = horizontal ? this.width : this.height,
            minRotation = toRadians(this.options.ticks.minRotation),
            ratio =
              (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) ||
              0.001,
            tickFont = this._resolveTickFontOptions(0);
          return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
        }
        getPixelForValue(value) {
          return null === value
            ? NaN
            : this.getPixelForDecimal(
                (value - this._startValue) / this._valueRange
              );
        }
        getValueForPixel(pixel) {
          return (
            this._startValue + this.getDecimalForPixel(pixel) * this._valueRange
          );
        }
      }
      class LogarithmicScale extends Scale {
        static id = 'logarithmic';
        static defaults = {
          ticks: {
            callback: Ticks.formatters.logarithmic,
            major: { enabled: !0 },
          },
        };
        constructor(cfg) {
          super(cfg),
            (this.start = void 0),
            (this.end = void 0),
            (this._startValue = void 0),
            (this._valueRange = 0);
        }
        parse(raw, index) {
          const value = LinearScaleBase.prototype.parse.apply(this, [
            raw,
            index,
          ]);
          if (0 !== value)
            return isNumberFinite(value) && value > 0 ? value : null;
          this._zero = !0;
        }
        determineDataLimits() {
          const { min, max } = this.getMinMax(!0);
          (this.min = isNumberFinite(min) ? Math.max(0, min) : null),
            (this.max = isNumberFinite(max) ? Math.max(0, max) : null),
            this.options.beginAtZero && (this._zero = !0),
            this._zero &&
              this.min !== this._suggestedMin &&
              !isNumberFinite(this._userMin) &&
              (this.min =
                min === changeExponent(this.min, 0)
                  ? changeExponent(this.min, -1)
                  : changeExponent(this.min, 0)),
            this.handleTickRangeOptions();
        }
        handleTickRangeOptions() {
          const { minDefined, maxDefined } = this.getUserBounds();
          let min = this.min,
            max = this.max;
          const setMin = (v) => (minDefined ? min : v),
            setMax = (v) => (maxDefined ? max : v);
          min === max &&
            (min <= 0
              ? (setMin(1), setMax(10))
              : (setMin(changeExponent(min, -1)),
                setMax(changeExponent(max, 1)))),
            min <= 0 && setMin(changeExponent(max, -1)),
            max <= 0 && setMax(changeExponent(min, 1)),
            (this.min = min),
            (this.max = max);
        }
        buildTicks() {
          const opts = this.options,
            ticks = generateTicks(
              { min: this._userMin, max: this._userMax },
              this
            );
          return (
            'ticks' === opts.bounds && _setMinAndMaxByKey(ticks, this, 'value'),
            opts.reverse
              ? (ticks.reverse(),
                (this.start = this.max),
                (this.end = this.min))
              : ((this.start = this.min), (this.end = this.max)),
            ticks
          );
        }
        getLabelForValue(value) {
          return void 0 === value
            ? '0'
            : formatNumber(
                value,
                this.chart.options.locale,
                this.options.ticks.format
              );
        }
        configure() {
          const start = this.min;
          super.configure(),
            (this._startValue = log10(start)),
            (this._valueRange = log10(this.max) - log10(start));
        }
        getPixelForValue(value) {
          return (
            (void 0 !== value && 0 !== value) || this.min,
            null === value || isNaN(value)
              ? NaN
              : this.getPixelForDecimal(
                  value === this.min
                    ? 0
                    : (log10(value) - this._startValue) / this._valueRange
                )
          );
        }
        getValueForPixel(pixel) {
          const decimal = this.getDecimalForPixel(pixel);
          return Math.pow(10, this._startValue + decimal * this._valueRange);
        }
      }
      class RadialLinearScale extends LinearScaleBase {
        static id = 'radialLinear';
        static defaults = {
          display: !0,
          animate: !0,
          position: 'chartArea',
          angleLines: {
            display: !0,
            lineWidth: 1,
            borderDash: [],
            borderDashOffset: 0,
          },
          grid: { circular: !1 },
          startAngle: 0,
          ticks: { showLabelBackdrop: !0, callback: Ticks.formatters.numeric },
          pointLabels: {
            backdropColor: void 0,
            backdropPadding: 2,
            display: !0,
            font: { size: 10 },
            callback: (label) => label,
            padding: 5,
            centerPointLabels: !1,
          },
        };
        static defaultRoutes = {
          'angleLines.color': 'borderColor',
          'pointLabels.color': 'color',
          'ticks.color': 'color',
        };
        static descriptors = { angleLines: { _fallback: 'grid' } };
        constructor(cfg) {
          super(cfg),
            (this.xCenter = void 0),
            (this.yCenter = void 0),
            (this.drawingArea = void 0),
            (this._pointLabels = []),
            (this._pointLabelItems = []);
        }
        setDimensions() {
          const padding = (this._padding = toPadding(
              getTickBackdropHeight(this.options) / 2
            )),
            w = (this.width = this.maxWidth - padding.width),
            h = (this.height = this.maxHeight - padding.height);
          (this.xCenter = Math.floor(this.left + w / 2 + padding.left)),
            (this.yCenter = Math.floor(this.top + h / 2 + padding.top)),
            (this.drawingArea = Math.floor(Math.min(w, h) / 2));
        }
        determineDataLimits() {
          const { min, max } = this.getMinMax(!1);
          (this.min = isNumberFinite(min) && !isNaN(min) ? min : 0),
            (this.max = isNumberFinite(max) && !isNaN(max) ? max : 0),
            this.handleTickRangeOptions();
        }
        computeTickLimit() {
          return Math.ceil(
            this.drawingArea / getTickBackdropHeight(this.options)
          );
        }
        generateTickLabels(ticks) {
          LinearScaleBase.prototype.generateTickLabels.call(this, ticks),
            (this._pointLabels = this.getLabels()
              .map((value, index) => {
                const label = callback(
                  this.options.pointLabels.callback,
                  [value, index],
                  this
                );
                return label || 0 === label ? label : '';
              })
              .filter((v, i) => this.chart.getDataVisibility(i)));
        }
        fit() {
          const opts = this.options;
          opts.display && opts.pointLabels.display
            ? fitWithPointLabels(this)
            : this.setCenterPoint(0, 0, 0, 0);
        }
        setCenterPoint(
          leftMovement,
          rightMovement,
          topMovement,
          bottomMovement
        ) {
          (this.xCenter += Math.floor((leftMovement - rightMovement) / 2)),
            (this.yCenter += Math.floor((topMovement - bottomMovement) / 2)),
            (this.drawingArea -= Math.min(
              this.drawingArea / 2,
              Math.max(leftMovement, rightMovement, topMovement, bottomMovement)
            ));
        }
        getIndexAngle(index) {
          return _normalizeAngle(
            index * (TAU / (this._pointLabels.length || 1)) +
              toRadians(this.options.startAngle || 0)
          );
        }
        getDistanceFromCenterForValue(value) {
          if (isNullOrUndef(value)) return NaN;
          const scalingFactor = this.drawingArea / (this.max - this.min);
          return this.options.reverse
            ? (this.max - value) * scalingFactor
            : (value - this.min) * scalingFactor;
        }
        getValueForDistanceFromCenter(distance) {
          if (isNullOrUndef(distance)) return NaN;
          const scaledDistance =
            distance / (this.drawingArea / (this.max - this.min));
          return this.options.reverse
            ? this.max - scaledDistance
            : this.min + scaledDistance;
        }
        getPointLabelContext(index) {
          const pointLabels = this._pointLabels || [];
          if (index >= 0 && index < pointLabels.length) {
            const pointLabel = pointLabels[index];
            return (function createPointLabelContext(parent, index, label) {
              return createContext(parent, {
                label,
                index,
                type: 'pointLabel',
              });
            })(this.getContext(), index, pointLabel);
          }
        }
        getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
          const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;
          return {
            x: Math.cos(angle) * distanceFromCenter + this.xCenter,
            y: Math.sin(angle) * distanceFromCenter + this.yCenter,
            angle,
          };
        }
        getPointPositionForValue(index, value) {
          return this.getPointPosition(
            index,
            this.getDistanceFromCenterForValue(value)
          );
        }
        getBasePosition(index) {
          return this.getPointPositionForValue(index || 0, this.getBaseValue());
        }
        getPointLabelPosition(index) {
          const { left, top, right, bottom } = this._pointLabelItems[index];
          return { left, top, right, bottom };
        }
        drawBackground() {
          const {
            backgroundColor,
            grid: { circular },
          } = this.options;
          if (backgroundColor) {
            const ctx = this.ctx;
            ctx.save(),
              ctx.beginPath(),
              pathRadiusLine(
                this,
                this.getDistanceFromCenterForValue(this._endValue),
                circular,
                this._pointLabels.length
              ),
              ctx.closePath(),
              (ctx.fillStyle = backgroundColor),
              ctx.fill(),
              ctx.restore();
          }
        }
        drawGrid() {
          const ctx = this.ctx,
            opts = this.options,
            { angleLines, grid, border } = opts,
            labelCount = this._pointLabels.length;
          let i, offset, position;
          if (
            (opts.pointLabels.display &&
              (function drawPointLabels(scale, labelCount) {
                const {
                  ctx,
                  options: { pointLabels },
                } = scale;
                for (let i = labelCount - 1; i >= 0; i--) {
                  const optsAtIndex = pointLabels.setContext(
                      scale.getPointLabelContext(i)
                    ),
                    plFont = toFont(optsAtIndex.font),
                    { x, y, textAlign, left, top, right, bottom } =
                      scale._pointLabelItems[i],
                    { backdropColor } = optsAtIndex;
                  if (!isNullOrUndef(backdropColor)) {
                    const borderRadius = toTRBLCorners(
                        optsAtIndex.borderRadius
                      ),
                      padding = toPadding(optsAtIndex.backdropPadding);
                    ctx.fillStyle = backdropColor;
                    const backdropLeft = left - padding.left,
                      backdropTop = top - padding.top,
                      backdropWidth = right - left + padding.width,
                      backdropHeight = bottom - top + padding.height;
                    Object.values(borderRadius).some((v) => 0 !== v)
                      ? (ctx.beginPath(),
                        addRoundedRectPath(ctx, {
                          x: backdropLeft,
                          y: backdropTop,
                          w: backdropWidth,
                          h: backdropHeight,
                          radius: borderRadius,
                        }),
                        ctx.fill())
                      : ctx.fillRect(
                          backdropLeft,
                          backdropTop,
                          backdropWidth,
                          backdropHeight
                        );
                  }
                  renderText(
                    ctx,
                    scale._pointLabels[i],
                    x,
                    y + plFont.lineHeight / 2,
                    plFont,
                    {
                      color: optsAtIndex.color,
                      textAlign,
                      textBaseline: 'middle',
                    }
                  );
                }
              })(this, labelCount),
            grid.display &&
              this.ticks.forEach((tick, index) => {
                if (0 !== index) {
                  this.getDistanceFromCenterForValue(tick.value);
                  const context = this.getContext(index),
                    optsAtIndex = grid.setContext(context),
                    optsAtIndexBorder = border.setContext(context);
                  !(function drawRadiusLine(
                    scale,
                    gridLineOpts,
                    radius,
                    labelCount,
                    borderOpts
                  ) {
                    const ctx = scale.ctx,
                      circular = gridLineOpts.circular,
                      { color, lineWidth } = gridLineOpts;
                    (!circular && !labelCount) ||
                      !color ||
                      !lineWidth ||
                      radius < 0 ||
                      (ctx.save(),
                      (ctx.strokeStyle = color),
                      (ctx.lineWidth = lineWidth),
                      ctx.setLineDash(borderOpts.dash),
                      (ctx.lineDashOffset = borderOpts.dashOffset),
                      ctx.beginPath(),
                      pathRadiusLine(scale, radius, circular, labelCount),
                      ctx.closePath(),
                      ctx.stroke(),
                      ctx.restore());
                  })(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
                }
              }),
            angleLines.display)
          ) {
            for (ctx.save(), labelCount - 1; i >= 0; i--) {
              const optsAtIndex = angleLines.setContext(
                  this.getPointLabelContext(i)
                ),
                { color, lineWidth } = optsAtIndex;
              lineWidth &&
                color &&
                ((ctx.lineWidth = lineWidth),
                (ctx.strokeStyle = color),
                ctx.setLineDash(optsAtIndex.borderDash),
                (ctx.lineDashOffset = optsAtIndex.borderDashOffset),
                this.getDistanceFromCenterForValue(
                  opts.ticks.reverse ? this.min : this.max
                ),
                this.getPointPosition(i, offset),
                ctx.beginPath(),
                ctx.moveTo(this.xCenter, this.yCenter),
                ctx.lineTo(position.x, position.y),
                ctx.stroke());
            }
            ctx.restore();
          }
        }
        drawBorder() {}
        drawLabels() {
          const ctx = this.ctx,
            opts = this.options,
            tickOpts = opts.ticks;
          if (!tickOpts.display) return;
          const startAngle = this.getIndexAngle(0);
          let offset, width;
          ctx.save(),
            ctx.translate(this.xCenter, this.yCenter),
            ctx.rotate(startAngle),
            (ctx.textAlign = 'center'),
            (ctx.textBaseline = 'middle'),
            this.ticks.forEach((tick, index) => {
              if (0 === index && !opts.reverse) return;
              const optsAtIndex = tickOpts.setContext(this.getContext(index)),
                tickFont = toFont(optsAtIndex.font);
              if (
                (this.getDistanceFromCenterForValue(this.ticks[index].value),
                optsAtIndex.showLabelBackdrop)
              ) {
                (ctx.font = tickFont.string),
                  ctx.measureText(tick.label).width,
                  (ctx.fillStyle = optsAtIndex.backdropColor);
                const padding = toPadding(optsAtIndex.backdropPadding);
                ctx.fillRect(
                  -width / 2 - padding.left,
                  -offset - tickFont.size / 2 - padding.top,
                  width + padding.width,
                  tickFont.size + padding.height
                );
              }
              renderText(ctx, tick.label, 0, -offset, tickFont, {
                color: optsAtIndex.color,
              });
            }),
            ctx.restore();
        }
        drawTitle() {}
      }
      const INTERVALS = {
          millisecond: { common: !0, size: 1, steps: 1e3 },
          second: { common: !0, size: 1e3, steps: 60 },
          minute: { common: !0, size: 6e4, steps: 60 },
          hour: { common: !0, size: 36e5, steps: 24 },
          day: { common: !0, size: 864e5, steps: 30 },
          week: { common: !1, size: 6048e5, steps: 4 },
          month: { common: !0, size: 2628e6, steps: 12 },
          quarter: { common: !1, size: 7884e6, steps: 4 },
          year: { common: !0, size: 3154e7 },
        },
        UNITS = Object.keys(INTERVALS);
      function sorter(a, b) {
        return a - b;
      }
      function parse(scale, input) {
        if (isNullOrUndef(input)) return null;
        const adapter = scale._adapter,
          { parser, round, isoWeekday } = scale._parseOpts;
        let value = input;
        return (
          'function' == typeof parser && (value = parser(value)),
          isNumberFinite(value) ||
            (value =
              'string' == typeof parser
                ? adapter.parse(value, parser)
                : adapter.parse(value)),
          null === value
            ? null
            : (round &&
                (value =
                  'week' !== round ||
                  (!isNumber(isoWeekday) && !0 !== isoWeekday)
                    ? adapter.startOf(value, round)
                    : adapter.startOf(value, 'isoWeek', isoWeekday)),
              +value)
        );
      }
      function determineUnitForAutoTicks(minUnit, min, max, capacity) {
        const ilen = UNITS.length;
        for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
          const interval = INTERVALS[UNITS[i]],
            factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
          if (
            interval.common &&
            Math.ceil((max - min) / (factor * interval.size)) <= capacity
          )
            return UNITS[i];
        }
        return UNITS[ilen - 1];
      }
      function addTick(ticks, time, timestamps) {
        if (timestamps) {
          if (timestamps.length) {
            const { lo, hi } = _lookup(timestamps, time);
            ticks[timestamps[lo] >= time ? timestamps[lo] : timestamps[hi]] =
              !0;
          }
        } else ticks[time] = !0;
      }
      function ticksFromTimestamps(scale, values, majorUnit) {
        const ticks = [],
          map = {},
          ilen = values.length;
        let i, value;
        for (i = 0; i < ilen; ++i)
          (value = values[i]),
            (map[value] = i),
            ticks.push({ value, major: !1 });
        return 0 !== ilen && majorUnit
          ? (function setMajorTicks(scale, ticks, map, majorUnit) {
              const adapter = scale._adapter,
                first = +adapter.startOf(ticks[0].value, majorUnit),
                last = ticks[ticks.length - 1].value;
              let major, index;
              for (
                major = first;
                major <= last;
                major = +adapter.add(major, 1, majorUnit)
              )
                (index = map[major]), index >= 0 && (ticks[index].major = !0);
              return ticks;
            })(scale, ticks, map, majorUnit)
          : ticks;
      }
      class TimeScale extends Scale {
        static id = 'time';
        static defaults = {
          bounds: 'data',
          adapters: {},
          time: {
            parser: !1,
            unit: !1,
            round: !1,
            isoWeekday: !1,
            minUnit: 'millisecond',
            displayFormats: {},
          },
          ticks: { source: 'auto', callback: !1, major: { enabled: !1 } },
        };
        constructor(props) {
          super(props),
            (this._cache = { data: [], labels: [], all: [] }),
            (this._unit = 'day'),
            (this._majorUnit = void 0),
            (this._offsets = {}),
            (this._normalized = !1),
            (this._parseOpts = void 0);
        }
        init(scaleOpts, opts = {}) {
          const time = scaleOpts.time || (scaleOpts.time = {}),
            adapter = (this._adapter = new adapters._date(
              scaleOpts.adapters.date
            ));
          adapter.init(opts),
            mergeIf(time.displayFormats, adapter.formats()),
            (this._parseOpts = {
              parser: time.parser,
              round: time.round,
              isoWeekday: time.isoWeekday,
            }),
            super.init(scaleOpts),
            (this._normalized = opts.normalized);
        }
        parse(raw, index) {
          return void 0 === raw ? null : parse(this, raw);
        }
        beforeLayout() {
          super.beforeLayout(),
            (this._cache = { data: [], labels: [], all: [] });
        }
        determineDataLimits() {
          const options = this.options,
            adapter = this._adapter,
            unit = options.time.unit || 'day';
          let { min, max, minDefined, maxDefined } = this.getUserBounds();
          function _applyBounds(bounds) {
            minDefined ||
              isNaN(bounds.min) ||
              (min = Math.min(min, bounds.min)),
              maxDefined ||
                isNaN(bounds.max) ||
                (max = Math.max(max, bounds.max));
          }
          (minDefined && maxDefined) ||
            (_applyBounds(this._getLabelBounds()),
            ('ticks' === options.bounds && 'labels' === options.ticks.source) ||
              _applyBounds(this.getMinMax(!1))),
            (min =
              isNumberFinite(min) && !isNaN(min)
                ? min
                : +adapter.startOf(Date.now(), unit)),
            (max =
              isNumberFinite(max) && !isNaN(max)
                ? max
                : +adapter.endOf(Date.now(), unit) + 1),
            (this.min = Math.min(min, max - 1)),
            (this.max = Math.max(min + 1, max));
        }
        _getLabelBounds() {
          const arr = this.getLabelTimestamps();
          let min = Number.POSITIVE_INFINITY,
            max = Number.NEGATIVE_INFINITY;
          return (
            arr.length && ((min = arr[0]), (max = arr[arr.length - 1])),
            { min, max }
          );
        }
        buildTicks() {
          const options = this.options,
            timeOpts = options.time,
            tickOpts = options.ticks,
            timestamps =
              'labels' === tickOpts.source
                ? this.getLabelTimestamps()
                : this._generate();
          'ticks' === options.bounds &&
            timestamps.length &&
            ((this.min = this._userMin || timestamps[0]),
            (this.max = this._userMax || timestamps[timestamps.length - 1]));
          const min = this.min,
            ticks = (function _filterBetween(values, min, max) {
              let start = 0,
                end = values.length;
              for (; start < end && values[start] < min; ) start++;
              for (; end > start && values[end - 1] > max; ) end--;
              return start > 0 || end < values.length
                ? values.slice(start, end)
                : values;
            })(timestamps, min, this.max);
          return (
            (this._unit =
              timeOpts.unit ||
              (tickOpts.autoSkip
                ? determineUnitForAutoTicks(
                    timeOpts.minUnit,
                    this.min,
                    this.max,
                    this._getLabelCapacity(min)
                  )
                : (function determineUnitForFormatting(
                    scale,
                    numTicks,
                    minUnit,
                    min,
                    max
                  ) {
                    for (
                      let i = UNITS.length - 1;
                      i >= UNITS.indexOf(minUnit);
                      i--
                    ) {
                      const unit = UNITS[i];
                      if (
                        INTERVALS[unit].common &&
                        scale._adapter.diff(max, min, unit) >= numTicks - 1
                      )
                        return unit;
                    }
                    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
                  })(
                    this,
                    ticks.length,
                    timeOpts.minUnit,
                    this.min,
                    this.max
                  ))),
            (this._majorUnit =
              tickOpts.major.enabled && 'year' !== this._unit
                ? (function determineMajorUnit(unit) {
                    for (
                      let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length;
                      i < ilen;
                      ++i
                    )
                      if (INTERVALS[UNITS[i]].common) return UNITS[i];
                  })(this._unit)
                : void 0),
            this.initOffsets(timestamps),
            options.reverse && ticks.reverse(),
            ticksFromTimestamps(this, ticks, this._majorUnit)
          );
        }
        afterAutoSkip() {
          this.options.offsetAfterAutoskip &&
            this.initOffsets(this.ticks.map((tick) => +tick.value));
        }
        initOffsets(timestamps = []) {
          let first,
            last,
            start = 0,
            end = 0;
          this.options.offset &&
            timestamps.length &&
            ((first = this.getDecimalForValue(timestamps[0])),
            (start =
              1 === timestamps.length
                ? 1 - first
                : (this.getDecimalForValue(timestamps[1]) - first) / 2),
            (last = this.getDecimalForValue(timestamps[timestamps.length - 1])),
            (end =
              1 === timestamps.length
                ? last
                : (last -
                    this.getDecimalForValue(
                      timestamps[timestamps.length - 2]
                    )) /
                  2));
          const limit = timestamps.length < 3 ? 0.5 : 0.25;
          (start = _limitValue(start, 0, limit)),
            (end = _limitValue(end, 0, limit)),
            (this._offsets = { start, end, factor: 1 / (start + 1 + end) });
        }
        _generate() {
          const adapter = this._adapter,
            min = this.min,
            max = this.max,
            options = this.options,
            timeOpts = options.time,
            minor =
              timeOpts.unit ||
              determineUnitForAutoTicks(
                timeOpts.minUnit,
                min,
                max,
                this._getLabelCapacity(min)
              ),
            stepSize = valueOrDefault(options.ticks.stepSize, 1),
            weekday = 'week' === minor && timeOpts.isoWeekday,
            hasWeekday = isNumber(weekday) || !0 === weekday,
            ticks = {};
          let time,
            count,
            first = min;
          if (
            (hasWeekday &&
              (first = +adapter.startOf(first, 'isoWeek', weekday)),
            (first = +adapter.startOf(first, hasWeekday ? 'day' : minor)),
            adapter.diff(max, min, minor) > 1e5 * stepSize)
          )
            throw new Error(
              min +
                ' and ' +
                max +
                ' are too far apart with stepSize of ' +
                stepSize +
                ' ' +
                minor
            );
          const timestamps =
            'data' === options.ticks.source && this.getDataTimestamps();
          for (
            time = first, count = 0;
            time < max;
            time = +adapter.add(time, stepSize, minor), count++
          )
            addTick(ticks, time, timestamps);
          return (
            (time !== max && 'ticks' !== options.bounds && 1 !== count) ||
              addTick(ticks, time, timestamps),
            Object.keys(ticks)
              .sort((a, b) => a - b)
              .map((x) => +x)
          );
        }
        getLabelForValue(value) {
          const adapter = this._adapter,
            timeOpts = this.options.time;
          return timeOpts.tooltipFormat
            ? adapter.format(value, timeOpts.tooltipFormat)
            : adapter.format(value, timeOpts.displayFormats.datetime);
        }
        _tickFormatFunction(time, index, ticks, format) {
          const options = this.options,
            formatter = options.ticks.callback;
          if (formatter) return callback(formatter, [time, index, ticks], this);
          const formats = options.time.displayFormats,
            unit = this._unit,
            majorUnit = this._majorUnit,
            minorFormat = unit && formats[unit],
            majorFormat = majorUnit && formats[majorUnit],
            tick = ticks[index],
            major = majorUnit && majorFormat && tick && tick.major;
          return this._adapter.format(
            time,
            format || (major ? majorFormat : minorFormat)
          );
        }
        generateTickLabels(ticks) {
          let i, ilen, tick;
          for (i = 0, ilen = ticks.length; i < ilen; ++i)
            (tick = ticks[i]),
              (tick.label = this._tickFormatFunction(tick.value, i, ticks));
        }
        getDecimalForValue(value) {
          return null === value
            ? NaN
            : (value - this.min) / (this.max - this.min);
        }
        getPixelForValue(value) {
          const offsets = this._offsets,
            pos = this.getDecimalForValue(value);
          return this.getPixelForDecimal(
            (offsets.start + pos) * offsets.factor
          );
        }
        getValueForPixel(pixel) {
          const offsets = this._offsets,
            pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
          return this.min + pos * (this.max - this.min);
        }
        _getLabelSize(label) {
          const ticksOpts = this.options.ticks,
            tickLabelWidth = this.ctx.measureText(label).width,
            angle = toRadians(
              this.isHorizontal()
                ? ticksOpts.maxRotation
                : ticksOpts.minRotation
            ),
            cosRotation = Math.cos(angle),
            sinRotation = Math.sin(angle),
            tickFontSize = this._resolveTickFontOptions(0).size;
          return {
            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation,
          };
        }
        _getLabelCapacity(exampleTime) {
          const timeOpts = this.options.time,
            displayFormats = timeOpts.displayFormats,
            format =
              displayFormats[timeOpts.unit] || displayFormats.millisecond,
            exampleLabel = this._tickFormatFunction(
              exampleTime,
              0,
              ticksFromTimestamps(this, [exampleTime], this._majorUnit),
              format
            ),
            size = this._getLabelSize(exampleLabel),
            capacity =
              Math.floor(
                this.isHorizontal() ? this.width / size.w : this.height / size.h
              ) - 1;
          return capacity > 0 ? capacity : 1;
        }
        getDataTimestamps() {
          let i,
            ilen,
            timestamps = this._cache.data || [];
          if (timestamps.length) return timestamps;
          const metas = this.getMatchingVisibleMetas();
          if (this._normalized && metas.length)
            return (this._cache.data =
              metas[0].controller.getAllParsedValues(this));
          for (i = 0, ilen = metas.length; i < ilen; ++i)
            timestamps = timestamps.concat(
              metas[i].controller.getAllParsedValues(this)
            );
          return (this._cache.data = this.normalize(timestamps));
        }
        getLabelTimestamps() {
          const timestamps = this._cache.labels || [];
          let i, ilen;
          if (timestamps.length) return timestamps;
          const labels = this.getLabels();
          for (i = 0, ilen = labels.length; i < ilen; ++i)
            timestamps.push(parse(this, labels[i]));
          return (this._cache.labels = this._normalized
            ? timestamps
            : this.normalize(timestamps));
        }
        normalize(values) {
          return _arrayUnique(values.sort(sorter));
        }
      }
    },
    './node_modules/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.esm.js':
      (
        __unused_webpack_module,
        __unused_webpack___webpack_exports__,
        __webpack_require__
      ) => {
        'use strict';
        var chart = __webpack_require__(
          './node_modules/chart.js/dist/chart.js'
        );
        function requiredArgs(required, args) {
          if (args.length < required)
            throw new TypeError(
              required +
                ' argument' +
                (required > 1 ? 's' : '') +
                ' required, but only ' +
                args.length +
                ' present'
            );
        }
        function _typeof(obj) {
          return (
            (_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            _typeof(obj)
          );
        }
        function toDate(argument) {
          requiredArgs(1, arguments);
          var argStr = Object.prototype.toString.call(argument);
          return argument instanceof Date ||
            ('object' === _typeof(argument) && '[object Date]' === argStr)
            ? new Date(argument.getTime())
            : 'number' == typeof argument || '[object Number]' === argStr
            ? new Date(argument)
            : (('string' != typeof argument && '[object String]' !== argStr) ||
                'undefined' == typeof console ||
                (console.warn(
                  "Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"
                ),
                console.warn(new Error().stack)),
              new Date(NaN));
        }
        var formatDistanceLocale = {
          lessThanXSeconds: {
            one: 'less than a second',
            other: 'less than {{count}} seconds',
          },
          xSeconds: { one: '1 second', other: '{{count}} seconds' },
          halfAMinute: 'half a minute',
          lessThanXMinutes: {
            one: 'less than a minute',
            other: 'less than {{count}} minutes',
          },
          xMinutes: { one: '1 minute', other: '{{count}} minutes' },
          aboutXHours: { one: 'about 1 hour', other: 'about {{count}} hours' },
          xHours: { one: '1 hour', other: '{{count}} hours' },
          xDays: { one: '1 day', other: '{{count}} days' },
          aboutXWeeks: { one: 'about 1 week', other: 'about {{count}} weeks' },
          xWeeks: { one: '1 week', other: '{{count}} weeks' },
          aboutXMonths: {
            one: 'about 1 month',
            other: 'about {{count}} months',
          },
          xMonths: { one: '1 month', other: '{{count}} months' },
          aboutXYears: { one: 'about 1 year', other: 'about {{count}} years' },
          xYears: { one: '1 year', other: '{{count}} years' },
          overXYears: { one: 'over 1 year', other: 'over {{count}} years' },
          almostXYears: {
            one: 'almost 1 year',
            other: 'almost {{count}} years',
          },
        };
        const _lib_formatDistance = function formatDistance(
          token,
          count,
          options
        ) {
          var result,
            tokenValue = formatDistanceLocale[token];
          return (
            (result =
              'string' == typeof tokenValue
                ? tokenValue
                : 1 === count
                ? tokenValue.one
                : tokenValue.other.replace('{{count}}', count.toString())),
            null != options && options.addSuffix
              ? options.comparison && options.comparison > 0
                ? 'in ' + result
                : result + ' ago'
              : result
          );
        };
        var buildFormatLongFn = __webpack_require__(
          './node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js'
        );
        const _lib_formatLong = {
          date: (0, buildFormatLongFn.Z)({
            formats: {
              full: 'EEEE, MMMM do, y',
              long: 'MMMM do, y',
              medium: 'MMM d, y',
              short: 'MM/dd/yyyy',
            },
            defaultWidth: 'full',
          }),
          time: (0, buildFormatLongFn.Z)({
            formats: {
              full: 'h:mm:ss a zzzz',
              long: 'h:mm:ss a z',
              medium: 'h:mm:ss a',
              short: 'h:mm a',
            },
            defaultWidth: 'full',
          }),
          dateTime: (0, buildFormatLongFn.Z)({
            formats: {
              full: "{{date}} 'at' {{time}}",
              long: "{{date}} 'at' {{time}}",
              medium: '{{date}}, {{time}}',
              short: '{{date}}, {{time}}',
            },
            defaultWidth: 'full',
          }),
        };
        var formatRelativeLocale = {
          lastWeek: "'last' eeee 'at' p",
          yesterday: "'yesterday at' p",
          today: "'today at' p",
          tomorrow: "'tomorrow at' p",
          nextWeek: "eeee 'at' p",
          other: 'P',
        };
        const _lib_formatRelative = function formatRelative(
          token,
          _date,
          _baseDate,
          _options
        ) {
          return formatRelativeLocale[token];
        };
        var buildLocalizeFn = __webpack_require__(
          './node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js'
        );
        const _lib_localize = {
          ordinalNumber: function ordinalNumber(dirtyNumber, _options) {
            var number = Number(dirtyNumber),
              rem100 = number % 100;
            if (rem100 > 20 || rem100 < 10)
              switch (rem100 % 10) {
                case 1:
                  return number + 'st';
                case 2:
                  return number + 'nd';
                case 3:
                  return number + 'rd';
              }
            return number + 'th';
          },
          era: (0, buildLocalizeFn.Z)({
            values: {
              narrow: ['B', 'A'],
              abbreviated: ['BC', 'AD'],
              wide: ['Before Christ', 'Anno Domini'],
            },
            defaultWidth: 'wide',
          }),
          quarter: (0, buildLocalizeFn.Z)({
            values: {
              narrow: ['1', '2', '3', '4'],
              abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
              wide: [
                '1st quarter',
                '2nd quarter',
                '3rd quarter',
                '4th quarter',
              ],
            },
            defaultWidth: 'wide',
            argumentCallback: function argumentCallback(quarter) {
              return quarter - 1;
            },
          }),
          month: (0, buildLocalizeFn.Z)({
            values: {
              narrow: [
                'J',
                'F',
                'M',
                'A',
                'M',
                'J',
                'J',
                'A',
                'S',
                'O',
                'N',
                'D',
              ],
              abbreviated: [
                'Jan',
                'Feb',
                'Mar',
                'Apr',
                'May',
                'Jun',
                'Jul',
                'Aug',
                'Sep',
                'Oct',
                'Nov',
                'Dec',
              ],
              wide: [
                'January',
                'February',
                'March',
                'April',
                'May',
                'June',
                'July',
                'August',
                'September',
                'October',
                'November',
                'December',
              ],
            },
            defaultWidth: 'wide',
          }),
          day: (0, buildLocalizeFn.Z)({
            values: {
              narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
              short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
              abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
              wide: [
                'Sunday',
                'Monday',
                'Tuesday',
                'Wednesday',
                'Thursday',
                'Friday',
                'Saturday',
              ],
            },
            defaultWidth: 'wide',
          }),
          dayPeriod: (0, buildLocalizeFn.Z)({
            values: {
              narrow: {
                am: 'a',
                pm: 'p',
                midnight: 'mi',
                noon: 'n',
                morning: 'morning',
                afternoon: 'afternoon',
                evening: 'evening',
                night: 'night',
              },
              abbreviated: {
                am: 'AM',
                pm: 'PM',
                midnight: 'midnight',
                noon: 'noon',
                morning: 'morning',
                afternoon: 'afternoon',
                evening: 'evening',
                night: 'night',
              },
              wide: {
                am: 'a.m.',
                pm: 'p.m.',
                midnight: 'midnight',
                noon: 'noon',
                morning: 'morning',
                afternoon: 'afternoon',
                evening: 'evening',
                night: 'night',
              },
            },
            defaultWidth: 'wide',
            formattingValues: {
              narrow: {
                am: 'a',
                pm: 'p',
                midnight: 'mi',
                noon: 'n',
                morning: 'in the morning',
                afternoon: 'in the afternoon',
                evening: 'in the evening',
                night: 'at night',
              },
              abbreviated: {
                am: 'AM',
                pm: 'PM',
                midnight: 'midnight',
                noon: 'noon',
                morning: 'in the morning',
                afternoon: 'in the afternoon',
                evening: 'in the evening',
                night: 'at night',
              },
              wide: {
                am: 'a.m.',
                pm: 'p.m.',
                midnight: 'midnight',
                noon: 'noon',
                morning: 'in the morning',
                afternoon: 'in the afternoon',
                evening: 'in the evening',
                night: 'at night',
              },
            },
            defaultFormattingWidth: 'wide',
          }),
        };
        var buildMatchFn = __webpack_require__(
          './node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js'
        );
        const defaultLocale = {
          code: 'en-US',
          formatDistance: _lib_formatDistance,
          formatLong: _lib_formatLong,
          formatRelative: _lib_formatRelative,
          localize: _lib_localize,
          match: {
            ordinalNumber: (0,
            __webpack_require__(
              './node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js'
            ).Z)({
              matchPattern: /^(\d+)(th|st|nd|rd)?/i,
              parsePattern: /\d+/i,
              valueCallback: function valueCallback(value) {
                return parseInt(value, 10);
              },
            }),
            era: (0, buildMatchFn.Z)({
              matchPatterns: {
                narrow: /^(b|a)/i,
                abbreviated:
                  /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
                wide: /^(before christ|before common era|anno domini|common era)/i,
              },
              defaultMatchWidth: 'wide',
              parsePatterns: { any: [/^b/i, /^(a|c)/i] },
              defaultParseWidth: 'any',
            }),
            quarter: (0, buildMatchFn.Z)({
              matchPatterns: {
                narrow: /^[1234]/i,
                abbreviated: /^q[1234]/i,
                wide: /^[1234](th|st|nd|rd)? quarter/i,
              },
              defaultMatchWidth: 'wide',
              parsePatterns: { any: [/1/i, /2/i, /3/i, /4/i] },
              defaultParseWidth: 'any',
              valueCallback: function valueCallback(index) {
                return index + 1;
              },
            }),
            month: (0, buildMatchFn.Z)({
              matchPatterns: {
                narrow: /^[jfmasond]/i,
                abbreviated:
                  /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
                wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i,
              },
              defaultMatchWidth: 'wide',
              parsePatterns: {
                narrow: [
                  /^j/i,
                  /^f/i,
                  /^m/i,
                  /^a/i,
                  /^m/i,
                  /^j/i,
                  /^j/i,
                  /^a/i,
                  /^s/i,
                  /^o/i,
                  /^n/i,
                  /^d/i,
                ],
                any: [
                  /^ja/i,
                  /^f/i,
                  /^mar/i,
                  /^ap/i,
                  /^may/i,
                  /^jun/i,
                  /^jul/i,
                  /^au/i,
                  /^s/i,
                  /^o/i,
                  /^n/i,
                  /^d/i,
                ],
              },
              defaultParseWidth: 'any',
            }),
            day: (0, buildMatchFn.Z)({
              matchPatterns: {
                narrow: /^[smtwf]/i,
                short: /^(su|mo|tu|we|th|fr|sa)/i,
                abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
                wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i,
              },
              defaultMatchWidth: 'wide',
              parsePatterns: {
                narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
                any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i],
              },
              defaultParseWidth: 'any',
            }),
            dayPeriod: (0, buildMatchFn.Z)({
              matchPatterns: {
                narrow:
                  /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
                any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i,
              },
              defaultMatchWidth: 'any',
              parsePatterns: {
                any: {
                  am: /^a/i,
                  pm: /^p/i,
                  midnight: /^mi/i,
                  noon: /^no/i,
                  morning: /morning/i,
                  afternoon: /afternoon/i,
                  evening: /evening/i,
                  night: /night/i,
                },
              },
              defaultParseWidth: 'any',
            }),
          },
          options: { weekStartsOn: 0, firstWeekContainsDate: 1 },
        };
        function toInteger(dirtyNumber) {
          if (null === dirtyNumber || !0 === dirtyNumber || !1 === dirtyNumber)
            return NaN;
          var number = Number(dirtyNumber);
          return isNaN(number)
            ? number
            : number < 0
            ? Math.ceil(number)
            : Math.floor(number);
        }
        function addMilliseconds(dirtyDate, dirtyAmount) {
          requiredArgs(2, arguments);
          var timestamp = toDate(dirtyDate).getTime(),
            amount = toInteger(dirtyAmount);
          return new Date(timestamp + amount);
        }
        function subMilliseconds(dirtyDate, dirtyAmount) {
          return (
            requiredArgs(2, arguments),
            addMilliseconds(dirtyDate, -toInteger(dirtyAmount))
          );
        }
        function assign_assign(target, object) {
          if (null == target)
            throw new TypeError(
              'assign requires that input parameter not be null or undefined'
            );
          for (var property in object)
            Object.prototype.hasOwnProperty.call(object, property) &&
              (target[property] = object[property]);
          return target;
        }
        var dateLongFormatter = function dateLongFormatter(
            pattern,
            formatLong
          ) {
            switch (pattern) {
              case 'P':
                return formatLong.date({ width: 'short' });
              case 'PP':
                return formatLong.date({ width: 'medium' });
              case 'PPP':
                return formatLong.date({ width: 'long' });
              default:
                return formatLong.date({ width: 'full' });
            }
          },
          timeLongFormatter = function timeLongFormatter(pattern, formatLong) {
            switch (pattern) {
              case 'p':
                return formatLong.time({ width: 'short' });
              case 'pp':
                return formatLong.time({ width: 'medium' });
              case 'ppp':
                return formatLong.time({ width: 'long' });
              default:
                return formatLong.time({ width: 'full' });
            }
          },
          longFormatters = {
            p: timeLongFormatter,
            P: function dateTimeLongFormatter(pattern, formatLong) {
              var dateTimeFormat,
                matchResult = pattern.match(/(P+)(p+)?/) || [],
                datePattern = matchResult[1],
                timePattern = matchResult[2];
              if (!timePattern) return dateLongFormatter(pattern, formatLong);
              switch (datePattern) {
                case 'P':
                  dateTimeFormat = formatLong.dateTime({ width: 'short' });
                  break;
                case 'PP':
                  dateTimeFormat = formatLong.dateTime({ width: 'medium' });
                  break;
                case 'PPP':
                  dateTimeFormat = formatLong.dateTime({ width: 'long' });
                  break;
                default:
                  dateTimeFormat = formatLong.dateTime({ width: 'full' });
              }
              return dateTimeFormat
                .replace('{{date}}', dateLongFormatter(datePattern, formatLong))
                .replace(
                  '{{time}}',
                  timeLongFormatter(timePattern, formatLong)
                );
            },
          };
        const format_longFormatters = longFormatters;
        function getTimezoneOffsetInMilliseconds(date) {
          var utcDate = new Date(
            Date.UTC(
              date.getFullYear(),
              date.getMonth(),
              date.getDate(),
              date.getHours(),
              date.getMinutes(),
              date.getSeconds(),
              date.getMilliseconds()
            )
          );
          return (
            utcDate.setUTCFullYear(date.getFullYear()),
            date.getTime() - utcDate.getTime()
          );
        }
        var protectedDayOfYearTokens = ['D', 'DD'],
          protectedWeekYearTokens = ['YY', 'YYYY'];
        function isProtectedDayOfYearToken(token) {
          return -1 !== protectedDayOfYearTokens.indexOf(token);
        }
        function isProtectedWeekYearToken(token) {
          return -1 !== protectedWeekYearTokens.indexOf(token);
        }
        function throwProtectedError(token, format, input) {
          if ('YYYY' === token)
            throw new RangeError(
              'Use `yyyy` instead of `YYYY` (in `'
                .concat(format, '`) for formatting years to the input `')
                .concat(
                  input,
                  '`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md'
                )
            );
          if ('YY' === token)
            throw new RangeError(
              'Use `yy` instead of `YY` (in `'
                .concat(format, '`) for formatting years to the input `')
                .concat(
                  input,
                  '`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md'
                )
            );
          if ('D' === token)
            throw new RangeError(
              'Use `d` instead of `D` (in `'
                .concat(
                  format,
                  '`) for formatting days of the month to the input `'
                )
                .concat(
                  input,
                  '`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md'
                )
            );
          if ('DD' === token)
            throw new RangeError(
              'Use `dd` instead of `DD` (in `'
                .concat(
                  format,
                  '`) for formatting days of the month to the input `'
                )
                .concat(
                  input,
                  '`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md'
                )
            );
        }
        function Setter_typeof(obj) {
          return (
            (Setter_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            Setter_typeof(obj)
          );
        }
        function _inherits(subClass, superClass) {
          if ('function' != typeof superClass && null !== superClass)
            throw new TypeError(
              'Super expression must either be null or a function'
            );
          (subClass.prototype = Object.create(
            superClass && superClass.prototype,
            { constructor: { value: subClass, writable: !0, configurable: !0 } }
          )),
            superClass && _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o, p) {
          return (
            (_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            _setPrototypeOf(o, p)
          );
        }
        function _createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function _isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = _getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function _possibleConstructorReturn(self, call) {
              if (
                call &&
                ('object' === Setter_typeof(call) || 'function' == typeof call)
              )
                return call;
              return _assertThisInitialized(self);
            })(this, result);
          };
        }
        function _assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function _getPrototypeOf(o) {
          return (
            (_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            _getPrototypeOf(o)
          );
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor))
            throw new TypeError('Cannot call a class as a function');
        }
        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          return (
            protoProps && _defineProperties(Constructor.prototype, protoProps),
            staticProps && _defineProperties(Constructor, staticProps),
            Constructor
          );
        }
        function _defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var TIMEZONE_UNIT_PRIORITY = 10,
          Setter = (function () {
            function Setter() {
              _classCallCheck(this, Setter),
                _defineProperty(this, 'subPriority', 0);
            }
            return (
              _createClass(Setter, [
                {
                  key: 'validate',
                  value: function validate(_utcDate, _options) {
                    return !0;
                  },
                },
              ]),
              Setter
            );
          })(),
          ValueSetter = (function (_Setter) {
            _inherits(ValueSetter, _Setter);
            var _super = _createSuper(ValueSetter);
            function ValueSetter(
              value,
              validateValue,
              setValue,
              priority,
              subPriority
            ) {
              var _this;
              return (
                _classCallCheck(this, ValueSetter),
                ((_this = _super.call(this)).value = value),
                (_this.validateValue = validateValue),
                (_this.setValue = setValue),
                (_this.priority = priority),
                subPriority && (_this.subPriority = subPriority),
                _this
              );
            }
            return (
              _createClass(ValueSetter, [
                {
                  key: 'validate',
                  value: function validate(utcDate, options) {
                    return this.validateValue(utcDate, this.value, options);
                  },
                },
                {
                  key: 'set',
                  value: function set(utcDate, flags, options) {
                    return this.setValue(utcDate, flags, this.value, options);
                  },
                },
              ]),
              ValueSetter
            );
          })(Setter),
          DateToSystemTimezoneSetter = (function (_Setter2) {
            _inherits(DateToSystemTimezoneSetter, _Setter2);
            var _super2 = _createSuper(DateToSystemTimezoneSetter);
            function DateToSystemTimezoneSetter() {
              var _this2;
              _classCallCheck(this, DateToSystemTimezoneSetter);
              for (
                var _len = arguments.length, args = new Array(_len), _key = 0;
                _key < _len;
                _key++
              )
                args[_key] = arguments[_key];
              return (
                _defineProperty(
                  _assertThisInitialized(
                    (_this2 = _super2.call.apply(_super2, [this].concat(args)))
                  ),
                  'priority',
                  TIMEZONE_UNIT_PRIORITY
                ),
                _defineProperty(
                  _assertThisInitialized(_this2),
                  'subPriority',
                  -1
                ),
                _this2
              );
            }
            return (
              _createClass(DateToSystemTimezoneSetter, [
                {
                  key: 'set',
                  value: function set(date, flags) {
                    if (flags.timestampIsSet) return date;
                    var convertedDate = new Date(0);
                    return (
                      convertedDate.setFullYear(
                        date.getUTCFullYear(),
                        date.getUTCMonth(),
                        date.getUTCDate()
                      ),
                      convertedDate.setHours(
                        date.getUTCHours(),
                        date.getUTCMinutes(),
                        date.getUTCSeconds(),
                        date.getUTCMilliseconds()
                      ),
                      convertedDate
                    );
                  },
                },
              ]),
              DateToSystemTimezoneSetter
            );
          })(Setter);
        function Parser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        var Parser = (function () {
          function Parser() {
            !(function Parser_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, Parser);
          }
          return (
            (function Parser_createClass(Constructor, protoProps, staticProps) {
              return (
                protoProps &&
                  Parser_defineProperties(Constructor.prototype, protoProps),
                staticProps &&
                  Parser_defineProperties(Constructor, staticProps),
                Constructor
              );
            })(Parser, [
              {
                key: 'run',
                value: function run(dateString, token, match, options) {
                  var result = this.parse(dateString, token, match, options);
                  return result
                    ? {
                        setter: new ValueSetter(
                          result.value,
                          this.validate,
                          this.set,
                          this.priority,
                          this.subPriority
                        ),
                        rest: result.rest,
                      }
                    : null;
                },
              },
              {
                key: 'validate',
                value: function validate(_utcDate, _value, _options) {
                  return !0;
                },
              },
            ]),
            Parser
          );
        })();
        function EraParser_typeof(obj) {
          return (
            (EraParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            EraParser_typeof(obj)
          );
        }
        function EraParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function EraParser_setPrototypeOf(o, p) {
          return (
            (EraParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            EraParser_setPrototypeOf(o, p)
          );
        }
        function EraParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function EraParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = EraParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget = EraParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function EraParser_possibleConstructorReturn(self, call) {
              if (
                call &&
                ('object' === EraParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return EraParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function EraParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function EraParser_getPrototypeOf(o) {
          return (
            (EraParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            EraParser_getPrototypeOf(o)
          );
        }
        function EraParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var EraParser = (function (_Parser) {
            !(function EraParser_inherits(subClass, superClass) {
              if ('function' != typeof superClass && null !== superClass)
                throw new TypeError(
                  'Super expression must either be null or a function'
                );
              (subClass.prototype = Object.create(
                superClass && superClass.prototype,
                {
                  constructor: {
                    value: subClass,
                    writable: !0,
                    configurable: !0,
                  },
                }
              )),
                superClass && EraParser_setPrototypeOf(subClass, superClass);
            })(EraParser, _Parser);
            var _super = EraParser_createSuper(EraParser);
            function EraParser() {
              var _this;
              !(function EraParser_classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor))
                  throw new TypeError('Cannot call a class as a function');
              })(this, EraParser);
              for (
                var _len = arguments.length, args = new Array(_len), _key = 0;
                _key < _len;
                _key++
              )
                args[_key] = arguments[_key];
              return (
                EraParser_defineProperty(
                  EraParser_assertThisInitialized(
                    (_this = _super.call.apply(_super, [this].concat(args)))
                  ),
                  'priority',
                  140
                ),
                EraParser_defineProperty(
                  EraParser_assertThisInitialized(_this),
                  'incompatibleTokens',
                  ['R', 'u', 't', 'T']
                ),
                _this
              );
            }
            return (
              (function EraParser_createClass(
                Constructor,
                protoProps,
                staticProps
              ) {
                return (
                  protoProps &&
                    EraParser_defineProperties(
                      Constructor.prototype,
                      protoProps
                    ),
                  staticProps &&
                    EraParser_defineProperties(Constructor, staticProps),
                  Constructor
                );
              })(EraParser, [
                {
                  key: 'parse',
                  value: function parse(dateString, token, match) {
                    switch (token) {
                      case 'G':
                      case 'GG':
                      case 'GGG':
                        return (
                          match.era(dateString, { width: 'abbreviated' }) ||
                          match.era(dateString, { width: 'narrow' })
                        );
                      case 'GGGGG':
                        return match.era(dateString, { width: 'narrow' });
                      default:
                        return (
                          match.era(dateString, { width: 'wide' }) ||
                          match.era(dateString, { width: 'abbreviated' }) ||
                          match.era(dateString, { width: 'narrow' })
                        );
                    }
                  },
                },
                {
                  key: 'set',
                  value: function set(date, flags, value) {
                    return (
                      (flags.era = value),
                      date.setUTCFullYear(value, 0, 1),
                      date.setUTCHours(0, 0, 0, 0),
                      date
                    );
                  },
                },
              ]),
              EraParser
            );
          })(Parser),
          millisecondsInMinute = (Math.pow(10, 8), 6e4),
          millisecondsInHour = 36e5,
          millisecondsInSecond = 1e3,
          numericPatterns = {
            month: /^(1[0-2]|0?\d)/,
            date: /^(3[0-1]|[0-2]?\d)/,
            dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
            week: /^(5[0-3]|[0-4]?\d)/,
            hour23h: /^(2[0-3]|[0-1]?\d)/,
            hour24h: /^(2[0-4]|[0-1]?\d)/,
            hour11h: /^(1[0-1]|0?\d)/,
            hour12h: /^(1[0-2]|0?\d)/,
            minute: /^[0-5]?\d/,
            second: /^[0-5]?\d/,
            singleDigit: /^\d/,
            twoDigits: /^\d{1,2}/,
            threeDigits: /^\d{1,3}/,
            fourDigits: /^\d{1,4}/,
            anyDigitsSigned: /^-?\d+/,
            singleDigitSigned: /^-?\d/,
            twoDigitsSigned: /^-?\d{1,2}/,
            threeDigitsSigned: /^-?\d{1,3}/,
            fourDigitsSigned: /^-?\d{1,4}/,
          },
          timezonePatterns_basicOptionalMinutes = /^([+-])(\d{2})(\d{2})?|Z/,
          timezonePatterns_basic = /^([+-])(\d{2})(\d{2})|Z/,
          timezonePatterns_basicOptionalSeconds =
            /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
          timezonePatterns_extended = /^([+-])(\d{2}):(\d{2})|Z/,
          timezonePatterns_extendedOptionalSeconds =
            /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/;
        function mapValue(parseFnResult, mapFn) {
          return parseFnResult
            ? { value: mapFn(parseFnResult.value), rest: parseFnResult.rest }
            : parseFnResult;
        }
        function parseNumericPattern(pattern, dateString) {
          var matchResult = dateString.match(pattern);
          return matchResult
            ? {
                value: parseInt(matchResult[0], 10),
                rest: dateString.slice(matchResult[0].length),
              }
            : null;
        }
        function parseTimezonePattern(pattern, dateString) {
          var matchResult = dateString.match(pattern);
          if (!matchResult) return null;
          if ('Z' === matchResult[0])
            return { value: 0, rest: dateString.slice(1) };
          var sign = '+' === matchResult[1] ? 1 : -1,
            hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0,
            minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0,
            seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
          return {
            value:
              sign *
              (hours * millisecondsInHour +
                minutes * millisecondsInMinute +
                seconds * millisecondsInSecond),
            rest: dateString.slice(matchResult[0].length),
          };
        }
        function parseAnyDigitsSigned(dateString) {
          return parseNumericPattern(
            numericPatterns.anyDigitsSigned,
            dateString
          );
        }
        function parseNDigits(n, dateString) {
          switch (n) {
            case 1:
              return parseNumericPattern(
                numericPatterns.singleDigit,
                dateString
              );
            case 2:
              return parseNumericPattern(numericPatterns.twoDigits, dateString);
            case 3:
              return parseNumericPattern(
                numericPatterns.threeDigits,
                dateString
              );
            case 4:
              return parseNumericPattern(
                numericPatterns.fourDigits,
                dateString
              );
            default:
              return parseNumericPattern(
                new RegExp('^\\d{1,' + n + '}'),
                dateString
              );
          }
        }
        function parseNDigitsSigned(n, dateString) {
          switch (n) {
            case 1:
              return parseNumericPattern(
                numericPatterns.singleDigitSigned,
                dateString
              );
            case 2:
              return parseNumericPattern(
                numericPatterns.twoDigitsSigned,
                dateString
              );
            case 3:
              return parseNumericPattern(
                numericPatterns.threeDigitsSigned,
                dateString
              );
            case 4:
              return parseNumericPattern(
                numericPatterns.fourDigitsSigned,
                dateString
              );
            default:
              return parseNumericPattern(
                new RegExp('^-?\\d{1,' + n + '}'),
                dateString
              );
          }
        }
        function dayPeriodEnumToHours(dayPeriod) {
          switch (dayPeriod) {
            case 'morning':
              return 4;
            case 'evening':
              return 17;
            case 'pm':
            case 'noon':
            case 'afternoon':
              return 12;
            default:
              return 0;
          }
        }
        function normalizeTwoDigitYear(twoDigitYear, currentYear) {
          var result,
            isCommonEra = currentYear > 0,
            absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
          if (absCurrentYear <= 50) result = twoDigitYear || 100;
          else {
            var rangeEnd = absCurrentYear + 50;
            result =
              twoDigitYear +
              100 * Math.floor(rangeEnd / 100) -
              (twoDigitYear >= rangeEnd % 100 ? 100 : 0);
          }
          return isCommonEra ? result : 1 - result;
        }
        function isLeapYearIndex(year) {
          return year % 400 == 0 || (year % 4 == 0 && year % 100 != 0);
        }
        function YearParser_typeof(obj) {
          return (
            (YearParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            YearParser_typeof(obj)
          );
        }
        function YearParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function YearParser_setPrototypeOf(o, p) {
          return (
            (YearParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            YearParser_setPrototypeOf(o, p)
          );
        }
        function YearParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function YearParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = YearParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget = YearParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function YearParser_possibleConstructorReturn(self, call) {
              if (
                call &&
                ('object' === YearParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return YearParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function YearParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function YearParser_getPrototypeOf(o) {
          return (
            (YearParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            YearParser_getPrototypeOf(o)
          );
        }
        function YearParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var YearParser = (function (_Parser) {
            !(function YearParser_inherits(subClass, superClass) {
              if ('function' != typeof superClass && null !== superClass)
                throw new TypeError(
                  'Super expression must either be null or a function'
                );
              (subClass.prototype = Object.create(
                superClass && superClass.prototype,
                {
                  constructor: {
                    value: subClass,
                    writable: !0,
                    configurable: !0,
                  },
                }
              )),
                superClass && YearParser_setPrototypeOf(subClass, superClass);
            })(YearParser, _Parser);
            var _super = YearParser_createSuper(YearParser);
            function YearParser() {
              var _this;
              !(function YearParser_classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor))
                  throw new TypeError('Cannot call a class as a function');
              })(this, YearParser);
              for (
                var _len = arguments.length, args = new Array(_len), _key = 0;
                _key < _len;
                _key++
              )
                args[_key] = arguments[_key];
              return (
                YearParser_defineProperty(
                  YearParser_assertThisInitialized(
                    (_this = _super.call.apply(_super, [this].concat(args)))
                  ),
                  'priority',
                  130
                ),
                YearParser_defineProperty(
                  YearParser_assertThisInitialized(_this),
                  'incompatibleTokens',
                  ['Y', 'R', 'u', 'w', 'I', 'i', 'e', 'c', 't', 'T']
                ),
                _this
              );
            }
            return (
              (function YearParser_createClass(
                Constructor,
                protoProps,
                staticProps
              ) {
                return (
                  protoProps &&
                    YearParser_defineProperties(
                      Constructor.prototype,
                      protoProps
                    ),
                  staticProps &&
                    YearParser_defineProperties(Constructor, staticProps),
                  Constructor
                );
              })(YearParser, [
                {
                  key: 'parse',
                  value: function parse(dateString, token, match) {
                    var valueCallback = function valueCallback(year) {
                      return { year, isTwoDigitYear: 'yy' === token };
                    };
                    switch (token) {
                      case 'y':
                        return mapValue(
                          parseNDigits(4, dateString),
                          valueCallback
                        );
                      case 'yo':
                        return mapValue(
                          match.ordinalNumber(dateString, { unit: 'year' }),
                          valueCallback
                        );
                      default:
                        return mapValue(
                          parseNDigits(token.length, dateString),
                          valueCallback
                        );
                    }
                  },
                },
                {
                  key: 'validate',
                  value: function validate(_date, value) {
                    return value.isTwoDigitYear || value.year > 0;
                  },
                },
                {
                  key: 'set',
                  value: function set(date, flags, value) {
                    var currentYear = date.getUTCFullYear();
                    if (value.isTwoDigitYear) {
                      var normalizedTwoDigitYear = normalizeTwoDigitYear(
                        value.year,
                        currentYear
                      );
                      return (
                        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1),
                        date.setUTCHours(0, 0, 0, 0),
                        date
                      );
                    }
                    var year =
                      'era' in flags && 1 !== flags.era
                        ? 1 - value.year
                        : value.year;
                    return (
                      date.setUTCFullYear(year, 0, 1),
                      date.setUTCHours(0, 0, 0, 0),
                      date
                    );
                  },
                },
              ]),
              YearParser
            );
          })(Parser),
          defaultOptions = {};
        function getDefaultOptions() {
          return defaultOptions;
        }
        function startOfUTCWeek(dirtyDate, options) {
          var _ref,
            _ref2,
            _ref3,
            _options$weekStartsOn,
            _options$locale,
            _options$locale$optio,
            _defaultOptions$local,
            _defaultOptions$local2;
          requiredArgs(1, arguments);
          var defaultOptions = getDefaultOptions(),
            weekStartsOn = toInteger(
              null !==
                (_ref =
                  null !==
                    (_ref2 =
                      null !==
                        (_ref3 =
                          null !==
                            (_options$weekStartsOn =
                              null == options
                                ? void 0
                                : options.weekStartsOn) &&
                          void 0 !== _options$weekStartsOn
                            ? _options$weekStartsOn
                            : null == options ||
                              null === (_options$locale = options.locale) ||
                              void 0 === _options$locale ||
                              null ===
                                (_options$locale$optio =
                                  _options$locale.options) ||
                              void 0 === _options$locale$optio
                            ? void 0
                            : _options$locale$optio.weekStartsOn) &&
                      void 0 !== _ref3
                        ? _ref3
                        : defaultOptions.weekStartsOn) && void 0 !== _ref2
                    ? _ref2
                    : null ===
                        (_defaultOptions$local = defaultOptions.locale) ||
                      void 0 === _defaultOptions$local ||
                      null ===
                        (_defaultOptions$local2 =
                          _defaultOptions$local.options) ||
                      void 0 === _defaultOptions$local2
                    ? void 0
                    : _defaultOptions$local2.weekStartsOn) && void 0 !== _ref
                ? _ref
                : 0
            );
          if (!(weekStartsOn >= 0 && weekStartsOn <= 6))
            throw new RangeError(
              'weekStartsOn must be between 0 and 6 inclusively'
            );
          var date = toDate(dirtyDate),
            day = date.getUTCDay(),
            diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
          return (
            date.setUTCDate(date.getUTCDate() - diff),
            date.setUTCHours(0, 0, 0, 0),
            date
          );
        }
        function getUTCWeekYear(dirtyDate, options) {
          var _ref,
            _ref2,
            _ref3,
            _options$firstWeekCon,
            _options$locale,
            _options$locale$optio,
            _defaultOptions$local,
            _defaultOptions$local2;
          requiredArgs(1, arguments);
          var date = toDate(dirtyDate),
            year = date.getUTCFullYear(),
            defaultOptions = getDefaultOptions(),
            firstWeekContainsDate = toInteger(
              null !==
                (_ref =
                  null !==
                    (_ref2 =
                      null !==
                        (_ref3 =
                          null !==
                            (_options$firstWeekCon =
                              null == options
                                ? void 0
                                : options.firstWeekContainsDate) &&
                          void 0 !== _options$firstWeekCon
                            ? _options$firstWeekCon
                            : null == options ||
                              null === (_options$locale = options.locale) ||
                              void 0 === _options$locale ||
                              null ===
                                (_options$locale$optio =
                                  _options$locale.options) ||
                              void 0 === _options$locale$optio
                            ? void 0
                            : _options$locale$optio.firstWeekContainsDate) &&
                      void 0 !== _ref3
                        ? _ref3
                        : defaultOptions.firstWeekContainsDate) &&
                  void 0 !== _ref2
                    ? _ref2
                    : null ===
                        (_defaultOptions$local = defaultOptions.locale) ||
                      void 0 === _defaultOptions$local ||
                      null ===
                        (_defaultOptions$local2 =
                          _defaultOptions$local.options) ||
                      void 0 === _defaultOptions$local2
                    ? void 0
                    : _defaultOptions$local2.firstWeekContainsDate) &&
                void 0 !== _ref
                ? _ref
                : 1
            );
          if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7))
            throw new RangeError(
              'firstWeekContainsDate must be between 1 and 7 inclusively'
            );
          var firstWeekOfNextYear = new Date(0);
          firstWeekOfNextYear.setUTCFullYear(
            year + 1,
            0,
            firstWeekContainsDate
          ),
            firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
          var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options),
            firstWeekOfThisYear = new Date(0);
          firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate),
            firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
          var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
          return date.getTime() >= startOfNextYear.getTime()
            ? year + 1
            : date.getTime() >= startOfThisYear.getTime()
            ? year
            : year - 1;
        }
        function LocalWeekYearParser_typeof(obj) {
          return (
            (LocalWeekYearParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            LocalWeekYearParser_typeof(obj)
          );
        }
        function LocalWeekYearParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function LocalWeekYearParser_setPrototypeOf(o, p) {
          return (
            (LocalWeekYearParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            LocalWeekYearParser_setPrototypeOf(o, p)
          );
        }
        function LocalWeekYearParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function LocalWeekYearParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = LocalWeekYearParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget =
                LocalWeekYearParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function LocalWeekYearParser_possibleConstructorReturn(
              self,
              call
            ) {
              if (
                call &&
                ('object' === LocalWeekYearParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return LocalWeekYearParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function LocalWeekYearParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function LocalWeekYearParser_getPrototypeOf(o) {
          return (
            (LocalWeekYearParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            LocalWeekYearParser_getPrototypeOf(o)
          );
        }
        function LocalWeekYearParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var LocalWeekYearParser = (function (_Parser) {
          !(function LocalWeekYearParser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass &&
                LocalWeekYearParser_setPrototypeOf(subClass, superClass);
          })(LocalWeekYearParser, _Parser);
          var _super = LocalWeekYearParser_createSuper(LocalWeekYearParser);
          function LocalWeekYearParser() {
            var _this;
            !(function LocalWeekYearParser_classCallCheck(
              instance,
              Constructor
            ) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, LocalWeekYearParser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              LocalWeekYearParser_defineProperty(
                LocalWeekYearParser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                130
              ),
              LocalWeekYearParser_defineProperty(
                LocalWeekYearParser_assertThisInitialized(_this),
                'incompatibleTokens',
                [
                  'y',
                  'R',
                  'u',
                  'Q',
                  'q',
                  'M',
                  'L',
                  'I',
                  'd',
                  'D',
                  'i',
                  't',
                  'T',
                ]
              ),
              _this
            );
          }
          return (
            (function LocalWeekYearParser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  LocalWeekYearParser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  LocalWeekYearParser_defineProperties(
                    Constructor,
                    staticProps
                  ),
                Constructor
              );
            })(LocalWeekYearParser, [
              {
                key: 'parse',
                value: function parse(dateString, token, match) {
                  var valueCallback = function valueCallback(year) {
                    return { year, isTwoDigitYear: 'YY' === token };
                  };
                  switch (token) {
                    case 'Y':
                      return mapValue(
                        parseNDigits(4, dateString),
                        valueCallback
                      );
                    case 'Yo':
                      return mapValue(
                        match.ordinalNumber(dateString, { unit: 'year' }),
                        valueCallback
                      );
                    default:
                      return mapValue(
                        parseNDigits(token.length, dateString),
                        valueCallback
                      );
                  }
                },
              },
              {
                key: 'validate',
                value: function validate(_date, value) {
                  return value.isTwoDigitYear || value.year > 0;
                },
              },
              {
                key: 'set',
                value: function set(date, flags, value, options) {
                  var currentYear = getUTCWeekYear(date, options);
                  if (value.isTwoDigitYear) {
                    var normalizedTwoDigitYear = normalizeTwoDigitYear(
                      value.year,
                      currentYear
                    );
                    return (
                      date.setUTCFullYear(
                        normalizedTwoDigitYear,
                        0,
                        options.firstWeekContainsDate
                      ),
                      date.setUTCHours(0, 0, 0, 0),
                      startOfUTCWeek(date, options)
                    );
                  }
                  var year =
                    'era' in flags && 1 !== flags.era
                      ? 1 - value.year
                      : value.year;
                  return (
                    date.setUTCFullYear(year, 0, options.firstWeekContainsDate),
                    date.setUTCHours(0, 0, 0, 0),
                    startOfUTCWeek(date, options)
                  );
                },
              },
            ]),
            LocalWeekYearParser
          );
        })(Parser);
        function startOfUTCISOWeek(dirtyDate) {
          requiredArgs(1, arguments);
          var date = toDate(dirtyDate),
            day = date.getUTCDay(),
            diff = (day < 1 ? 7 : 0) + day - 1;
          return (
            date.setUTCDate(date.getUTCDate() - diff),
            date.setUTCHours(0, 0, 0, 0),
            date
          );
        }
        function ISOWeekYearParser_typeof(obj) {
          return (
            (ISOWeekYearParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            ISOWeekYearParser_typeof(obj)
          );
        }
        function ISOWeekYearParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function ISOWeekYearParser_setPrototypeOf(o, p) {
          return (
            (ISOWeekYearParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            ISOWeekYearParser_setPrototypeOf(o, p)
          );
        }
        function ISOWeekYearParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function ISOWeekYearParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = ISOWeekYearParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget =
                ISOWeekYearParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function ISOWeekYearParser_possibleConstructorReturn(
              self,
              call
            ) {
              if (
                call &&
                ('object' === ISOWeekYearParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return ISOWeekYearParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function ISOWeekYearParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function ISOWeekYearParser_getPrototypeOf(o) {
          return (
            (ISOWeekYearParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            ISOWeekYearParser_getPrototypeOf(o)
          );
        }
        function ISOWeekYearParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var ISOWeekYearParser = (function (_Parser) {
          !(function ISOWeekYearParser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass &&
                ISOWeekYearParser_setPrototypeOf(subClass, superClass);
          })(ISOWeekYearParser, _Parser);
          var _super = ISOWeekYearParser_createSuper(ISOWeekYearParser);
          function ISOWeekYearParser() {
            var _this;
            !(function ISOWeekYearParser_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, ISOWeekYearParser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              ISOWeekYearParser_defineProperty(
                ISOWeekYearParser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                130
              ),
              ISOWeekYearParser_defineProperty(
                ISOWeekYearParser_assertThisInitialized(_this),
                'incompatibleTokens',
                [
                  'G',
                  'y',
                  'Y',
                  'u',
                  'Q',
                  'q',
                  'M',
                  'L',
                  'w',
                  'd',
                  'D',
                  'e',
                  'c',
                  't',
                  'T',
                ]
              ),
              _this
            );
          }
          return (
            (function ISOWeekYearParser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  ISOWeekYearParser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  ISOWeekYearParser_defineProperties(Constructor, staticProps),
                Constructor
              );
            })(ISOWeekYearParser, [
              {
                key: 'parse',
                value: function parse(dateString, token) {
                  return parseNDigitsSigned(
                    'R' === token ? 4 : token.length,
                    dateString
                  );
                },
              },
              {
                key: 'set',
                value: function set(_date, _flags, value) {
                  var firstWeekOfYear = new Date(0);
                  return (
                    firstWeekOfYear.setUTCFullYear(value, 0, 4),
                    firstWeekOfYear.setUTCHours(0, 0, 0, 0),
                    startOfUTCISOWeek(firstWeekOfYear)
                  );
                },
              },
            ]),
            ISOWeekYearParser
          );
        })(Parser);
        function ExtendedYearParser_typeof(obj) {
          return (
            (ExtendedYearParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            ExtendedYearParser_typeof(obj)
          );
        }
        function ExtendedYearParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function ExtendedYearParser_setPrototypeOf(o, p) {
          return (
            (ExtendedYearParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            ExtendedYearParser_setPrototypeOf(o, p)
          );
        }
        function ExtendedYearParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function ExtendedYearParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = ExtendedYearParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget =
                ExtendedYearParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function ExtendedYearParser_possibleConstructorReturn(
              self,
              call
            ) {
              if (
                call &&
                ('object' === ExtendedYearParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return ExtendedYearParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function ExtendedYearParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function ExtendedYearParser_getPrototypeOf(o) {
          return (
            (ExtendedYearParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            ExtendedYearParser_getPrototypeOf(o)
          );
        }
        function ExtendedYearParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var ExtendedYearParser = (function (_Parser) {
          !(function ExtendedYearParser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass &&
                ExtendedYearParser_setPrototypeOf(subClass, superClass);
          })(ExtendedYearParser, _Parser);
          var _super = ExtendedYearParser_createSuper(ExtendedYearParser);
          function ExtendedYearParser() {
            var _this;
            !(function ExtendedYearParser_classCallCheck(
              instance,
              Constructor
            ) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, ExtendedYearParser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              ExtendedYearParser_defineProperty(
                ExtendedYearParser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                130
              ),
              ExtendedYearParser_defineProperty(
                ExtendedYearParser_assertThisInitialized(_this),
                'incompatibleTokens',
                ['G', 'y', 'Y', 'R', 'w', 'I', 'i', 'e', 'c', 't', 'T']
              ),
              _this
            );
          }
          return (
            (function ExtendedYearParser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  ExtendedYearParser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  ExtendedYearParser_defineProperties(Constructor, staticProps),
                Constructor
              );
            })(ExtendedYearParser, [
              {
                key: 'parse',
                value: function parse(dateString, token) {
                  return parseNDigitsSigned(
                    'u' === token ? 4 : token.length,
                    dateString
                  );
                },
              },
              {
                key: 'set',
                value: function set(date, _flags, value) {
                  return (
                    date.setUTCFullYear(value, 0, 1),
                    date.setUTCHours(0, 0, 0, 0),
                    date
                  );
                },
              },
            ]),
            ExtendedYearParser
          );
        })(Parser);
        function QuarterParser_typeof(obj) {
          return (
            (QuarterParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            QuarterParser_typeof(obj)
          );
        }
        function QuarterParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function QuarterParser_setPrototypeOf(o, p) {
          return (
            (QuarterParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            QuarterParser_setPrototypeOf(o, p)
          );
        }
        function QuarterParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function QuarterParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = QuarterParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget = QuarterParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function QuarterParser_possibleConstructorReturn(
              self,
              call
            ) {
              if (
                call &&
                ('object' === QuarterParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return QuarterParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function QuarterParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function QuarterParser_getPrototypeOf(o) {
          return (
            (QuarterParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            QuarterParser_getPrototypeOf(o)
          );
        }
        function QuarterParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var QuarterParser = (function (_Parser) {
          !(function QuarterParser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass && QuarterParser_setPrototypeOf(subClass, superClass);
          })(QuarterParser, _Parser);
          var _super = QuarterParser_createSuper(QuarterParser);
          function QuarterParser() {
            var _this;
            !(function QuarterParser_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, QuarterParser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              QuarterParser_defineProperty(
                QuarterParser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                120
              ),
              QuarterParser_defineProperty(
                QuarterParser_assertThisInitialized(_this),
                'incompatibleTokens',
                [
                  'Y',
                  'R',
                  'q',
                  'M',
                  'L',
                  'w',
                  'I',
                  'd',
                  'D',
                  'i',
                  'e',
                  'c',
                  't',
                  'T',
                ]
              ),
              _this
            );
          }
          return (
            (function QuarterParser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  QuarterParser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  QuarterParser_defineProperties(Constructor, staticProps),
                Constructor
              );
            })(QuarterParser, [
              {
                key: 'parse',
                value: function parse(dateString, token, match) {
                  switch (token) {
                    case 'Q':
                    case 'QQ':
                      return parseNDigits(token.length, dateString);
                    case 'Qo':
                      return match.ordinalNumber(dateString, {
                        unit: 'quarter',
                      });
                    case 'QQQ':
                      return (
                        match.quarter(dateString, {
                          width: 'abbreviated',
                          context: 'formatting',
                        }) ||
                        match.quarter(dateString, {
                          width: 'narrow',
                          context: 'formatting',
                        })
                      );
                    case 'QQQQQ':
                      return match.quarter(dateString, {
                        width: 'narrow',
                        context: 'formatting',
                      });
                    default:
                      return (
                        match.quarter(dateString, {
                          width: 'wide',
                          context: 'formatting',
                        }) ||
                        match.quarter(dateString, {
                          width: 'abbreviated',
                          context: 'formatting',
                        }) ||
                        match.quarter(dateString, {
                          width: 'narrow',
                          context: 'formatting',
                        })
                      );
                  }
                },
              },
              {
                key: 'validate',
                value: function validate(_date, value) {
                  return value >= 1 && value <= 4;
                },
              },
              {
                key: 'set',
                value: function set(date, _flags, value) {
                  return (
                    date.setUTCMonth(3 * (value - 1), 1),
                    date.setUTCHours(0, 0, 0, 0),
                    date
                  );
                },
              },
            ]),
            QuarterParser
          );
        })(Parser);
        function StandAloneQuarterParser_typeof(obj) {
          return (
            (StandAloneQuarterParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            StandAloneQuarterParser_typeof(obj)
          );
        }
        function StandAloneQuarterParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function StandAloneQuarterParser_setPrototypeOf(o, p) {
          return (
            (StandAloneQuarterParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            StandAloneQuarterParser_setPrototypeOf(o, p)
          );
        }
        function StandAloneQuarterParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function StandAloneQuarterParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = StandAloneQuarterParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget =
                StandAloneQuarterParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function StandAloneQuarterParser_possibleConstructorReturn(
              self,
              call
            ) {
              if (
                call &&
                ('object' === StandAloneQuarterParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return StandAloneQuarterParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function StandAloneQuarterParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function StandAloneQuarterParser_getPrototypeOf(o) {
          return (
            (StandAloneQuarterParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            StandAloneQuarterParser_getPrototypeOf(o)
          );
        }
        function StandAloneQuarterParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var StandAloneQuarterParser = (function (_Parser) {
          !(function StandAloneQuarterParser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass &&
                StandAloneQuarterParser_setPrototypeOf(subClass, superClass);
          })(StandAloneQuarterParser, _Parser);
          var _super = StandAloneQuarterParser_createSuper(
            StandAloneQuarterParser
          );
          function StandAloneQuarterParser() {
            var _this;
            !(function StandAloneQuarterParser_classCallCheck(
              instance,
              Constructor
            ) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, StandAloneQuarterParser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              StandAloneQuarterParser_defineProperty(
                StandAloneQuarterParser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                120
              ),
              StandAloneQuarterParser_defineProperty(
                StandAloneQuarterParser_assertThisInitialized(_this),
                'incompatibleTokens',
                [
                  'Y',
                  'R',
                  'Q',
                  'M',
                  'L',
                  'w',
                  'I',
                  'd',
                  'D',
                  'i',
                  'e',
                  'c',
                  't',
                  'T',
                ]
              ),
              _this
            );
          }
          return (
            (function StandAloneQuarterParser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  StandAloneQuarterParser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  StandAloneQuarterParser_defineProperties(
                    Constructor,
                    staticProps
                  ),
                Constructor
              );
            })(StandAloneQuarterParser, [
              {
                key: 'parse',
                value: function parse(dateString, token, match) {
                  switch (token) {
                    case 'q':
                    case 'qq':
                      return parseNDigits(token.length, dateString);
                    case 'qo':
                      return match.ordinalNumber(dateString, {
                        unit: 'quarter',
                      });
                    case 'qqq':
                      return (
                        match.quarter(dateString, {
                          width: 'abbreviated',
                          context: 'standalone',
                        }) ||
                        match.quarter(dateString, {
                          width: 'narrow',
                          context: 'standalone',
                        })
                      );
                    case 'qqqqq':
                      return match.quarter(dateString, {
                        width: 'narrow',
                        context: 'standalone',
                      });
                    default:
                      return (
                        match.quarter(dateString, {
                          width: 'wide',
                          context: 'standalone',
                        }) ||
                        match.quarter(dateString, {
                          width: 'abbreviated',
                          context: 'standalone',
                        }) ||
                        match.quarter(dateString, {
                          width: 'narrow',
                          context: 'standalone',
                        })
                      );
                  }
                },
              },
              {
                key: 'validate',
                value: function validate(_date, value) {
                  return value >= 1 && value <= 4;
                },
              },
              {
                key: 'set',
                value: function set(date, _flags, value) {
                  return (
                    date.setUTCMonth(3 * (value - 1), 1),
                    date.setUTCHours(0, 0, 0, 0),
                    date
                  );
                },
              },
            ]),
            StandAloneQuarterParser
          );
        })(Parser);
        function MonthParser_typeof(obj) {
          return (
            (MonthParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            MonthParser_typeof(obj)
          );
        }
        function MonthParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function MonthParser_setPrototypeOf(o, p) {
          return (
            (MonthParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            MonthParser_setPrototypeOf(o, p)
          );
        }
        function MonthParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function MonthParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = MonthParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget = MonthParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function MonthParser_possibleConstructorReturn(self, call) {
              if (
                call &&
                ('object' === MonthParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return MonthParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function MonthParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function MonthParser_getPrototypeOf(o) {
          return (
            (MonthParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            MonthParser_getPrototypeOf(o)
          );
        }
        function MonthParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var MonthParser = (function (_Parser) {
          !(function MonthParser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass && MonthParser_setPrototypeOf(subClass, superClass);
          })(MonthParser, _Parser);
          var _super = MonthParser_createSuper(MonthParser);
          function MonthParser() {
            var _this;
            !(function MonthParser_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, MonthParser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              MonthParser_defineProperty(
                MonthParser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'incompatibleTokens',
                [
                  'Y',
                  'R',
                  'q',
                  'Q',
                  'L',
                  'w',
                  'I',
                  'D',
                  'i',
                  'e',
                  'c',
                  't',
                  'T',
                ]
              ),
              MonthParser_defineProperty(
                MonthParser_assertThisInitialized(_this),
                'priority',
                110
              ),
              _this
            );
          }
          return (
            (function MonthParser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  MonthParser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  MonthParser_defineProperties(Constructor, staticProps),
                Constructor
              );
            })(MonthParser, [
              {
                key: 'parse',
                value: function parse(dateString, token, match) {
                  var valueCallback = function valueCallback(value) {
                    return value - 1;
                  };
                  switch (token) {
                    case 'M':
                      return mapValue(
                        parseNumericPattern(numericPatterns.month, dateString),
                        valueCallback
                      );
                    case 'MM':
                      return mapValue(
                        parseNDigits(2, dateString),
                        valueCallback
                      );
                    case 'Mo':
                      return mapValue(
                        match.ordinalNumber(dateString, { unit: 'month' }),
                        valueCallback
                      );
                    case 'MMM':
                      return (
                        match.month(dateString, {
                          width: 'abbreviated',
                          context: 'formatting',
                        }) ||
                        match.month(dateString, {
                          width: 'narrow',
                          context: 'formatting',
                        })
                      );
                    case 'MMMMM':
                      return match.month(dateString, {
                        width: 'narrow',
                        context: 'formatting',
                      });
                    default:
                      return (
                        match.month(dateString, {
                          width: 'wide',
                          context: 'formatting',
                        }) ||
                        match.month(dateString, {
                          width: 'abbreviated',
                          context: 'formatting',
                        }) ||
                        match.month(dateString, {
                          width: 'narrow',
                          context: 'formatting',
                        })
                      );
                  }
                },
              },
              {
                key: 'validate',
                value: function validate(_date, value) {
                  return value >= 0 && value <= 11;
                },
              },
              {
                key: 'set',
                value: function set(date, _flags, value) {
                  return (
                    date.setUTCMonth(value, 1),
                    date.setUTCHours(0, 0, 0, 0),
                    date
                  );
                },
              },
            ]),
            MonthParser
          );
        })(Parser);
        function StandAloneMonthParser_typeof(obj) {
          return (
            (StandAloneMonthParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            StandAloneMonthParser_typeof(obj)
          );
        }
        function StandAloneMonthParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function StandAloneMonthParser_setPrototypeOf(o, p) {
          return (
            (StandAloneMonthParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            StandAloneMonthParser_setPrototypeOf(o, p)
          );
        }
        function StandAloneMonthParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function StandAloneMonthParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = StandAloneMonthParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget =
                StandAloneMonthParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function StandAloneMonthParser_possibleConstructorReturn(
              self,
              call
            ) {
              if (
                call &&
                ('object' === StandAloneMonthParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return StandAloneMonthParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function StandAloneMonthParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function StandAloneMonthParser_getPrototypeOf(o) {
          return (
            (StandAloneMonthParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            StandAloneMonthParser_getPrototypeOf(o)
          );
        }
        function StandAloneMonthParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var StandAloneMonthParser = (function (_Parser) {
          !(function StandAloneMonthParser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass &&
                StandAloneMonthParser_setPrototypeOf(subClass, superClass);
          })(StandAloneMonthParser, _Parser);
          var _super = StandAloneMonthParser_createSuper(StandAloneMonthParser);
          function StandAloneMonthParser() {
            var _this;
            !(function StandAloneMonthParser_classCallCheck(
              instance,
              Constructor
            ) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, StandAloneMonthParser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              StandAloneMonthParser_defineProperty(
                StandAloneMonthParser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                110
              ),
              StandAloneMonthParser_defineProperty(
                StandAloneMonthParser_assertThisInitialized(_this),
                'incompatibleTokens',
                [
                  'Y',
                  'R',
                  'q',
                  'Q',
                  'M',
                  'w',
                  'I',
                  'D',
                  'i',
                  'e',
                  'c',
                  't',
                  'T',
                ]
              ),
              _this
            );
          }
          return (
            (function StandAloneMonthParser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  StandAloneMonthParser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  StandAloneMonthParser_defineProperties(
                    Constructor,
                    staticProps
                  ),
                Constructor
              );
            })(StandAloneMonthParser, [
              {
                key: 'parse',
                value: function parse(dateString, token, match) {
                  var valueCallback = function valueCallback(value) {
                    return value - 1;
                  };
                  switch (token) {
                    case 'L':
                      return mapValue(
                        parseNumericPattern(numericPatterns.month, dateString),
                        valueCallback
                      );
                    case 'LL':
                      return mapValue(
                        parseNDigits(2, dateString),
                        valueCallback
                      );
                    case 'Lo':
                      return mapValue(
                        match.ordinalNumber(dateString, { unit: 'month' }),
                        valueCallback
                      );
                    case 'LLL':
                      return (
                        match.month(dateString, {
                          width: 'abbreviated',
                          context: 'standalone',
                        }) ||
                        match.month(dateString, {
                          width: 'narrow',
                          context: 'standalone',
                        })
                      );
                    case 'LLLLL':
                      return match.month(dateString, {
                        width: 'narrow',
                        context: 'standalone',
                      });
                    default:
                      return (
                        match.month(dateString, {
                          width: 'wide',
                          context: 'standalone',
                        }) ||
                        match.month(dateString, {
                          width: 'abbreviated',
                          context: 'standalone',
                        }) ||
                        match.month(dateString, {
                          width: 'narrow',
                          context: 'standalone',
                        })
                      );
                  }
                },
              },
              {
                key: 'validate',
                value: function validate(_date, value) {
                  return value >= 0 && value <= 11;
                },
              },
              {
                key: 'set',
                value: function set(date, _flags, value) {
                  return (
                    date.setUTCMonth(value, 1),
                    date.setUTCHours(0, 0, 0, 0),
                    date
                  );
                },
              },
            ]),
            StandAloneMonthParser
          );
        })(Parser);
        var MILLISECONDS_IN_WEEK = 6048e5;
        function getUTCWeek(dirtyDate, options) {
          requiredArgs(1, arguments);
          var date = toDate(dirtyDate),
            diff =
              startOfUTCWeek(date, options).getTime() -
              (function startOfUTCWeekYear(dirtyDate, options) {
                var _ref,
                  _ref2,
                  _ref3,
                  _options$firstWeekCon,
                  _options$locale,
                  _options$locale$optio,
                  _defaultOptions$local,
                  _defaultOptions$local2;
                requiredArgs(1, arguments);
                var defaultOptions = getDefaultOptions(),
                  firstWeekContainsDate = toInteger(
                    null !==
                      (_ref =
                        null !==
                          (_ref2 =
                            null !==
                              (_ref3 =
                                null !==
                                  (_options$firstWeekCon =
                                    null == options
                                      ? void 0
                                      : options.firstWeekContainsDate) &&
                                void 0 !== _options$firstWeekCon
                                  ? _options$firstWeekCon
                                  : null == options ||
                                    null ===
                                      (_options$locale = options.locale) ||
                                    void 0 === _options$locale ||
                                    null ===
                                      (_options$locale$optio =
                                        _options$locale.options) ||
                                    void 0 === _options$locale$optio
                                  ? void 0
                                  : _options$locale$optio.firstWeekContainsDate) &&
                            void 0 !== _ref3
                              ? _ref3
                              : defaultOptions.firstWeekContainsDate) &&
                        void 0 !== _ref2
                          ? _ref2
                          : null ===
                              (_defaultOptions$local = defaultOptions.locale) ||
                            void 0 === _defaultOptions$local ||
                            null ===
                              (_defaultOptions$local2 =
                                _defaultOptions$local.options) ||
                            void 0 === _defaultOptions$local2
                          ? void 0
                          : _defaultOptions$local2.firstWeekContainsDate) &&
                      void 0 !== _ref
                      ? _ref
                      : 1
                  ),
                  year = getUTCWeekYear(dirtyDate, options),
                  firstWeek = new Date(0);
                return (
                  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate),
                  firstWeek.setUTCHours(0, 0, 0, 0),
                  startOfUTCWeek(firstWeek, options)
                );
              })(date, options).getTime();
          return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
        }
        function LocalWeekParser_typeof(obj) {
          return (
            (LocalWeekParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            LocalWeekParser_typeof(obj)
          );
        }
        function LocalWeekParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function LocalWeekParser_setPrototypeOf(o, p) {
          return (
            (LocalWeekParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            LocalWeekParser_setPrototypeOf(o, p)
          );
        }
        function LocalWeekParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function LocalWeekParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = LocalWeekParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget = LocalWeekParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function LocalWeekParser_possibleConstructorReturn(
              self,
              call
            ) {
              if (
                call &&
                ('object' === LocalWeekParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return LocalWeekParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function LocalWeekParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function LocalWeekParser_getPrototypeOf(o) {
          return (
            (LocalWeekParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            LocalWeekParser_getPrototypeOf(o)
          );
        }
        function LocalWeekParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var LocalWeekParser = (function (_Parser) {
          !(function LocalWeekParser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass &&
                LocalWeekParser_setPrototypeOf(subClass, superClass);
          })(LocalWeekParser, _Parser);
          var _super = LocalWeekParser_createSuper(LocalWeekParser);
          function LocalWeekParser() {
            var _this;
            !(function LocalWeekParser_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, LocalWeekParser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              LocalWeekParser_defineProperty(
                LocalWeekParser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                100
              ),
              LocalWeekParser_defineProperty(
                LocalWeekParser_assertThisInitialized(_this),
                'incompatibleTokens',
                [
                  'y',
                  'R',
                  'u',
                  'q',
                  'Q',
                  'M',
                  'L',
                  'I',
                  'd',
                  'D',
                  'i',
                  't',
                  'T',
                ]
              ),
              _this
            );
          }
          return (
            (function LocalWeekParser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  LocalWeekParser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  LocalWeekParser_defineProperties(Constructor, staticProps),
                Constructor
              );
            })(LocalWeekParser, [
              {
                key: 'parse',
                value: function parse(dateString, token, match) {
                  switch (token) {
                    case 'w':
                      return parseNumericPattern(
                        numericPatterns.week,
                        dateString
                      );
                    case 'wo':
                      return match.ordinalNumber(dateString, { unit: 'week' });
                    default:
                      return parseNDigits(token.length, dateString);
                  }
                },
              },
              {
                key: 'validate',
                value: function validate(_date, value) {
                  return value >= 1 && value <= 53;
                },
              },
              {
                key: 'set',
                value: function set(date, _flags, value, options) {
                  return startOfUTCWeek(
                    (function setUTCWeek(dirtyDate, dirtyWeek, options) {
                      requiredArgs(2, arguments);
                      var date = toDate(dirtyDate),
                        week = toInteger(dirtyWeek),
                        diff = getUTCWeek(date, options) - week;
                      return (
                        date.setUTCDate(date.getUTCDate() - 7 * diff), date
                      );
                    })(date, value, options),
                    options
                  );
                },
              },
            ]),
            LocalWeekParser
          );
        })(Parser);
        function getUTCISOWeekYear(dirtyDate) {
          requiredArgs(1, arguments);
          var date = toDate(dirtyDate),
            year = date.getUTCFullYear(),
            fourthOfJanuaryOfNextYear = new Date(0);
          fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4),
            fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
          var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear),
            fourthOfJanuaryOfThisYear = new Date(0);
          fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4),
            fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
          var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
          return date.getTime() >= startOfNextYear.getTime()
            ? year + 1
            : date.getTime() >= startOfThisYear.getTime()
            ? year
            : year - 1;
        }
        var getUTCISOWeek_MILLISECONDS_IN_WEEK = 6048e5;
        function getUTCISOWeek(dirtyDate) {
          requiredArgs(1, arguments);
          var date = toDate(dirtyDate),
            diff =
              startOfUTCISOWeek(date).getTime() -
              (function startOfUTCISOWeekYear(dirtyDate) {
                requiredArgs(1, arguments);
                var year = getUTCISOWeekYear(dirtyDate),
                  fourthOfJanuary = new Date(0);
                return (
                  fourthOfJanuary.setUTCFullYear(year, 0, 4),
                  fourthOfJanuary.setUTCHours(0, 0, 0, 0),
                  startOfUTCISOWeek(fourthOfJanuary)
                );
              })(date).getTime();
          return Math.round(diff / getUTCISOWeek_MILLISECONDS_IN_WEEK) + 1;
        }
        function ISOWeekParser_typeof(obj) {
          return (
            (ISOWeekParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            ISOWeekParser_typeof(obj)
          );
        }
        function ISOWeekParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function ISOWeekParser_setPrototypeOf(o, p) {
          return (
            (ISOWeekParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            ISOWeekParser_setPrototypeOf(o, p)
          );
        }
        function ISOWeekParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function ISOWeekParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = ISOWeekParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget = ISOWeekParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function ISOWeekParser_possibleConstructorReturn(
              self,
              call
            ) {
              if (
                call &&
                ('object' === ISOWeekParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return ISOWeekParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function ISOWeekParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function ISOWeekParser_getPrototypeOf(o) {
          return (
            (ISOWeekParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            ISOWeekParser_getPrototypeOf(o)
          );
        }
        function ISOWeekParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var ISOWeekParser = (function (_Parser) {
          !(function ISOWeekParser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass && ISOWeekParser_setPrototypeOf(subClass, superClass);
          })(ISOWeekParser, _Parser);
          var _super = ISOWeekParser_createSuper(ISOWeekParser);
          function ISOWeekParser() {
            var _this;
            !(function ISOWeekParser_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, ISOWeekParser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              ISOWeekParser_defineProperty(
                ISOWeekParser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                100
              ),
              ISOWeekParser_defineProperty(
                ISOWeekParser_assertThisInitialized(_this),
                'incompatibleTokens',
                [
                  'y',
                  'Y',
                  'u',
                  'q',
                  'Q',
                  'M',
                  'L',
                  'w',
                  'd',
                  'D',
                  'e',
                  'c',
                  't',
                  'T',
                ]
              ),
              _this
            );
          }
          return (
            (function ISOWeekParser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  ISOWeekParser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  ISOWeekParser_defineProperties(Constructor, staticProps),
                Constructor
              );
            })(ISOWeekParser, [
              {
                key: 'parse',
                value: function parse(dateString, token, match) {
                  switch (token) {
                    case 'I':
                      return parseNumericPattern(
                        numericPatterns.week,
                        dateString
                      );
                    case 'Io':
                      return match.ordinalNumber(dateString, { unit: 'week' });
                    default:
                      return parseNDigits(token.length, dateString);
                  }
                },
              },
              {
                key: 'validate',
                value: function validate(_date, value) {
                  return value >= 1 && value <= 53;
                },
              },
              {
                key: 'set',
                value: function set(date, _flags, value) {
                  return startOfUTCISOWeek(
                    (function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
                      requiredArgs(2, arguments);
                      var date = toDate(dirtyDate),
                        isoWeek = toInteger(dirtyISOWeek),
                        diff = getUTCISOWeek(date) - isoWeek;
                      return (
                        date.setUTCDate(date.getUTCDate() - 7 * diff), date
                      );
                    })(date, value)
                  );
                },
              },
            ]),
            ISOWeekParser
          );
        })(Parser);
        function DateParser_typeof(obj) {
          return (
            (DateParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            DateParser_typeof(obj)
          );
        }
        function DateParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function DateParser_setPrototypeOf(o, p) {
          return (
            (DateParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            DateParser_setPrototypeOf(o, p)
          );
        }
        function DateParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function DateParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = DateParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget = DateParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function DateParser_possibleConstructorReturn(self, call) {
              if (
                call &&
                ('object' === DateParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return DateParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function DateParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function DateParser_getPrototypeOf(o) {
          return (
            (DateParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            DateParser_getPrototypeOf(o)
          );
        }
        function DateParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
          DAYS_IN_MONTH_LEAP_YEAR = [
            31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31,
          ],
          DateParser = (function (_Parser) {
            !(function DateParser_inherits(subClass, superClass) {
              if ('function' != typeof superClass && null !== superClass)
                throw new TypeError(
                  'Super expression must either be null or a function'
                );
              (subClass.prototype = Object.create(
                superClass && superClass.prototype,
                {
                  constructor: {
                    value: subClass,
                    writable: !0,
                    configurable: !0,
                  },
                }
              )),
                superClass && DateParser_setPrototypeOf(subClass, superClass);
            })(DateParser, _Parser);
            var _super = DateParser_createSuper(DateParser);
            function DateParser() {
              var _this;
              !(function DateParser_classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor))
                  throw new TypeError('Cannot call a class as a function');
              })(this, DateParser);
              for (
                var _len = arguments.length, args = new Array(_len), _key = 0;
                _key < _len;
                _key++
              )
                args[_key] = arguments[_key];
              return (
                DateParser_defineProperty(
                  DateParser_assertThisInitialized(
                    (_this = _super.call.apply(_super, [this].concat(args)))
                  ),
                  'priority',
                  90
                ),
                DateParser_defineProperty(
                  DateParser_assertThisInitialized(_this),
                  'subPriority',
                  1
                ),
                DateParser_defineProperty(
                  DateParser_assertThisInitialized(_this),
                  'incompatibleTokens',
                  ['Y', 'R', 'q', 'Q', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']
                ),
                _this
              );
            }
            return (
              (function DateParser_createClass(
                Constructor,
                protoProps,
                staticProps
              ) {
                return (
                  protoProps &&
                    DateParser_defineProperties(
                      Constructor.prototype,
                      protoProps
                    ),
                  staticProps &&
                    DateParser_defineProperties(Constructor, staticProps),
                  Constructor
                );
              })(DateParser, [
                {
                  key: 'parse',
                  value: function parse(dateString, token, match) {
                    switch (token) {
                      case 'd':
                        return parseNumericPattern(
                          numericPatterns.date,
                          dateString
                        );
                      case 'do':
                        return match.ordinalNumber(dateString, {
                          unit: 'date',
                        });
                      default:
                        return parseNDigits(token.length, dateString);
                    }
                  },
                },
                {
                  key: 'validate',
                  value: function validate(date, value) {
                    var isLeapYear = isLeapYearIndex(date.getUTCFullYear()),
                      month = date.getUTCMonth();
                    return isLeapYear
                      ? value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month]
                      : value >= 1 && value <= DAYS_IN_MONTH[month];
                  },
                },
                {
                  key: 'set',
                  value: function set(date, _flags, value) {
                    return (
                      date.setUTCDate(value), date.setUTCHours(0, 0, 0, 0), date
                    );
                  },
                },
              ]),
              DateParser
            );
          })(Parser);
        function DayOfYearParser_typeof(obj) {
          return (
            (DayOfYearParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            DayOfYearParser_typeof(obj)
          );
        }
        function DayOfYearParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function DayOfYearParser_setPrototypeOf(o, p) {
          return (
            (DayOfYearParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            DayOfYearParser_setPrototypeOf(o, p)
          );
        }
        function DayOfYearParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function DayOfYearParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = DayOfYearParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget = DayOfYearParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function DayOfYearParser_possibleConstructorReturn(
              self,
              call
            ) {
              if (
                call &&
                ('object' === DayOfYearParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return DayOfYearParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function DayOfYearParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function DayOfYearParser_getPrototypeOf(o) {
          return (
            (DayOfYearParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            DayOfYearParser_getPrototypeOf(o)
          );
        }
        function DayOfYearParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var DayOfYearParser = (function (_Parser) {
          !(function DayOfYearParser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass &&
                DayOfYearParser_setPrototypeOf(subClass, superClass);
          })(DayOfYearParser, _Parser);
          var _super = DayOfYearParser_createSuper(DayOfYearParser);
          function DayOfYearParser() {
            var _this;
            !(function DayOfYearParser_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, DayOfYearParser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              DayOfYearParser_defineProperty(
                DayOfYearParser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                90
              ),
              DayOfYearParser_defineProperty(
                DayOfYearParser_assertThisInitialized(_this),
                'subpriority',
                1
              ),
              DayOfYearParser_defineProperty(
                DayOfYearParser_assertThisInitialized(_this),
                'incompatibleTokens',
                [
                  'Y',
                  'R',
                  'q',
                  'Q',
                  'M',
                  'L',
                  'w',
                  'I',
                  'd',
                  'E',
                  'i',
                  'e',
                  'c',
                  't',
                  'T',
                ]
              ),
              _this
            );
          }
          return (
            (function DayOfYearParser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  DayOfYearParser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  DayOfYearParser_defineProperties(Constructor, staticProps),
                Constructor
              );
            })(DayOfYearParser, [
              {
                key: 'parse',
                value: function parse(dateString, token, match) {
                  switch (token) {
                    case 'D':
                    case 'DD':
                      return parseNumericPattern(
                        numericPatterns.dayOfYear,
                        dateString
                      );
                    case 'Do':
                      return match.ordinalNumber(dateString, { unit: 'date' });
                    default:
                      return parseNDigits(token.length, dateString);
                  }
                },
              },
              {
                key: 'validate',
                value: function validate(date, value) {
                  return isLeapYearIndex(date.getUTCFullYear())
                    ? value >= 1 && value <= 366
                    : value >= 1 && value <= 365;
                },
              },
              {
                key: 'set',
                value: function set(date, _flags, value) {
                  return (
                    date.setUTCMonth(0, value),
                    date.setUTCHours(0, 0, 0, 0),
                    date
                  );
                },
              },
            ]),
            DayOfYearParser
          );
        })(Parser);
        function setUTCDay(dirtyDate, dirtyDay, options) {
          var _ref,
            _ref2,
            _ref3,
            _options$weekStartsOn,
            _options$locale,
            _options$locale$optio,
            _defaultOptions$local,
            _defaultOptions$local2;
          requiredArgs(2, arguments);
          var defaultOptions = getDefaultOptions(),
            weekStartsOn = toInteger(
              null !==
                (_ref =
                  null !==
                    (_ref2 =
                      null !==
                        (_ref3 =
                          null !==
                            (_options$weekStartsOn =
                              null == options
                                ? void 0
                                : options.weekStartsOn) &&
                          void 0 !== _options$weekStartsOn
                            ? _options$weekStartsOn
                            : null == options ||
                              null === (_options$locale = options.locale) ||
                              void 0 === _options$locale ||
                              null ===
                                (_options$locale$optio =
                                  _options$locale.options) ||
                              void 0 === _options$locale$optio
                            ? void 0
                            : _options$locale$optio.weekStartsOn) &&
                      void 0 !== _ref3
                        ? _ref3
                        : defaultOptions.weekStartsOn) && void 0 !== _ref2
                    ? _ref2
                    : null ===
                        (_defaultOptions$local = defaultOptions.locale) ||
                      void 0 === _defaultOptions$local ||
                      null ===
                        (_defaultOptions$local2 =
                          _defaultOptions$local.options) ||
                      void 0 === _defaultOptions$local2
                    ? void 0
                    : _defaultOptions$local2.weekStartsOn) && void 0 !== _ref
                ? _ref
                : 0
            );
          if (!(weekStartsOn >= 0 && weekStartsOn <= 6))
            throw new RangeError(
              'weekStartsOn must be between 0 and 6 inclusively'
            );
          var date = toDate(dirtyDate),
            day = toInteger(dirtyDay),
            diff =
              (((day % 7) + 7) % 7 < weekStartsOn ? 7 : 0) +
              day -
              date.getUTCDay();
          return date.setUTCDate(date.getUTCDate() + diff), date;
        }
        function DayParser_typeof(obj) {
          return (
            (DayParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            DayParser_typeof(obj)
          );
        }
        function DayParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function DayParser_setPrototypeOf(o, p) {
          return (
            (DayParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            DayParser_setPrototypeOf(o, p)
          );
        }
        function DayParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function DayParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = DayParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget = DayParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function DayParser_possibleConstructorReturn(self, call) {
              if (
                call &&
                ('object' === DayParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return DayParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function DayParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function DayParser_getPrototypeOf(o) {
          return (
            (DayParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            DayParser_getPrototypeOf(o)
          );
        }
        function DayParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var DayParser = (function (_Parser) {
          !(function DayParser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass && DayParser_setPrototypeOf(subClass, superClass);
          })(DayParser, _Parser);
          var _super = DayParser_createSuper(DayParser);
          function DayParser() {
            var _this;
            !(function DayParser_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, DayParser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              DayParser_defineProperty(
                DayParser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                90
              ),
              DayParser_defineProperty(
                DayParser_assertThisInitialized(_this),
                'incompatibleTokens',
                ['D', 'i', 'e', 'c', 't', 'T']
              ),
              _this
            );
          }
          return (
            (function DayParser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  DayParser_defineProperties(Constructor.prototype, protoProps),
                staticProps &&
                  DayParser_defineProperties(Constructor, staticProps),
                Constructor
              );
            })(DayParser, [
              {
                key: 'parse',
                value: function parse(dateString, token, match) {
                  switch (token) {
                    case 'E':
                    case 'EE':
                    case 'EEE':
                      return (
                        match.day(dateString, {
                          width: 'abbreviated',
                          context: 'formatting',
                        }) ||
                        match.day(dateString, {
                          width: 'short',
                          context: 'formatting',
                        }) ||
                        match.day(dateString, {
                          width: 'narrow',
                          context: 'formatting',
                        })
                      );
                    case 'EEEEE':
                      return match.day(dateString, {
                        width: 'narrow',
                        context: 'formatting',
                      });
                    case 'EEEEEE':
                      return (
                        match.day(dateString, {
                          width: 'short',
                          context: 'formatting',
                        }) ||
                        match.day(dateString, {
                          width: 'narrow',
                          context: 'formatting',
                        })
                      );
                    default:
                      return (
                        match.day(dateString, {
                          width: 'wide',
                          context: 'formatting',
                        }) ||
                        match.day(dateString, {
                          width: 'abbreviated',
                          context: 'formatting',
                        }) ||
                        match.day(dateString, {
                          width: 'short',
                          context: 'formatting',
                        }) ||
                        match.day(dateString, {
                          width: 'narrow',
                          context: 'formatting',
                        })
                      );
                  }
                },
              },
              {
                key: 'validate',
                value: function validate(_date, value) {
                  return value >= 0 && value <= 6;
                },
              },
              {
                key: 'set',
                value: function set(date, _flags, value, options) {
                  return (
                    (date = setUTCDay(date, value, options)).setUTCHours(
                      0,
                      0,
                      0,
                      0
                    ),
                    date
                  );
                },
              },
            ]),
            DayParser
          );
        })(Parser);
        function LocalDayParser_typeof(obj) {
          return (
            (LocalDayParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            LocalDayParser_typeof(obj)
          );
        }
        function LocalDayParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function LocalDayParser_setPrototypeOf(o, p) {
          return (
            (LocalDayParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            LocalDayParser_setPrototypeOf(o, p)
          );
        }
        function LocalDayParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function LocalDayParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = LocalDayParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget = LocalDayParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function LocalDayParser_possibleConstructorReturn(
              self,
              call
            ) {
              if (
                call &&
                ('object' === LocalDayParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return LocalDayParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function LocalDayParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function LocalDayParser_getPrototypeOf(o) {
          return (
            (LocalDayParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            LocalDayParser_getPrototypeOf(o)
          );
        }
        function LocalDayParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var LocalDayParser = (function (_Parser) {
          !(function LocalDayParser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass && LocalDayParser_setPrototypeOf(subClass, superClass);
          })(LocalDayParser, _Parser);
          var _super = LocalDayParser_createSuper(LocalDayParser);
          function LocalDayParser() {
            var _this;
            !(function LocalDayParser_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, LocalDayParser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              LocalDayParser_defineProperty(
                LocalDayParser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                90
              ),
              LocalDayParser_defineProperty(
                LocalDayParser_assertThisInitialized(_this),
                'incompatibleTokens',
                [
                  'y',
                  'R',
                  'u',
                  'q',
                  'Q',
                  'M',
                  'L',
                  'I',
                  'd',
                  'D',
                  'E',
                  'i',
                  'c',
                  't',
                  'T',
                ]
              ),
              _this
            );
          }
          return (
            (function LocalDayParser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  LocalDayParser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  LocalDayParser_defineProperties(Constructor, staticProps),
                Constructor
              );
            })(LocalDayParser, [
              {
                key: 'parse',
                value: function parse(dateString, token, match, options) {
                  var valueCallback = function valueCallback(value) {
                    var wholeWeekDays = 7 * Math.floor((value - 1) / 7);
                    return (
                      ((value + options.weekStartsOn + 6) % 7) + wholeWeekDays
                    );
                  };
                  switch (token) {
                    case 'e':
                    case 'ee':
                      return mapValue(
                        parseNDigits(token.length, dateString),
                        valueCallback
                      );
                    case 'eo':
                      return mapValue(
                        match.ordinalNumber(dateString, { unit: 'day' }),
                        valueCallback
                      );
                    case 'eee':
                      return (
                        match.day(dateString, {
                          width: 'abbreviated',
                          context: 'formatting',
                        }) ||
                        match.day(dateString, {
                          width: 'short',
                          context: 'formatting',
                        }) ||
                        match.day(dateString, {
                          width: 'narrow',
                          context: 'formatting',
                        })
                      );
                    case 'eeeee':
                      return match.day(dateString, {
                        width: 'narrow',
                        context: 'formatting',
                      });
                    case 'eeeeee':
                      return (
                        match.day(dateString, {
                          width: 'short',
                          context: 'formatting',
                        }) ||
                        match.day(dateString, {
                          width: 'narrow',
                          context: 'formatting',
                        })
                      );
                    default:
                      return (
                        match.day(dateString, {
                          width: 'wide',
                          context: 'formatting',
                        }) ||
                        match.day(dateString, {
                          width: 'abbreviated',
                          context: 'formatting',
                        }) ||
                        match.day(dateString, {
                          width: 'short',
                          context: 'formatting',
                        }) ||
                        match.day(dateString, {
                          width: 'narrow',
                          context: 'formatting',
                        })
                      );
                  }
                },
              },
              {
                key: 'validate',
                value: function validate(_date, value) {
                  return value >= 0 && value <= 6;
                },
              },
              {
                key: 'set',
                value: function set(date, _flags, value, options) {
                  return (
                    (date = setUTCDay(date, value, options)).setUTCHours(
                      0,
                      0,
                      0,
                      0
                    ),
                    date
                  );
                },
              },
            ]),
            LocalDayParser
          );
        })(Parser);
        function StandAloneLocalDayParser_typeof(obj) {
          return (
            (StandAloneLocalDayParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            StandAloneLocalDayParser_typeof(obj)
          );
        }
        function StandAloneLocalDayParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function StandAloneLocalDayParser_setPrototypeOf(o, p) {
          return (
            (StandAloneLocalDayParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            StandAloneLocalDayParser_setPrototypeOf(o, p)
          );
        }
        function StandAloneLocalDayParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function StandAloneLocalDayParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = StandAloneLocalDayParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget =
                StandAloneLocalDayParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function StandAloneLocalDayParser_possibleConstructorReturn(
              self,
              call
            ) {
              if (
                call &&
                ('object' === StandAloneLocalDayParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return StandAloneLocalDayParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function StandAloneLocalDayParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function StandAloneLocalDayParser_getPrototypeOf(o) {
          return (
            (StandAloneLocalDayParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            StandAloneLocalDayParser_getPrototypeOf(o)
          );
        }
        function StandAloneLocalDayParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var StandAloneLocalDayParser = (function (_Parser) {
          !(function StandAloneLocalDayParser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass &&
                StandAloneLocalDayParser_setPrototypeOf(subClass, superClass);
          })(StandAloneLocalDayParser, _Parser);
          var _super = StandAloneLocalDayParser_createSuper(
            StandAloneLocalDayParser
          );
          function StandAloneLocalDayParser() {
            var _this;
            !(function StandAloneLocalDayParser_classCallCheck(
              instance,
              Constructor
            ) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, StandAloneLocalDayParser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              StandAloneLocalDayParser_defineProperty(
                StandAloneLocalDayParser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                90
              ),
              StandAloneLocalDayParser_defineProperty(
                StandAloneLocalDayParser_assertThisInitialized(_this),
                'incompatibleTokens',
                [
                  'y',
                  'R',
                  'u',
                  'q',
                  'Q',
                  'M',
                  'L',
                  'I',
                  'd',
                  'D',
                  'E',
                  'i',
                  'e',
                  't',
                  'T',
                ]
              ),
              _this
            );
          }
          return (
            (function StandAloneLocalDayParser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  StandAloneLocalDayParser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  StandAloneLocalDayParser_defineProperties(
                    Constructor,
                    staticProps
                  ),
                Constructor
              );
            })(StandAloneLocalDayParser, [
              {
                key: 'parse',
                value: function parse(dateString, token, match, options) {
                  var valueCallback = function valueCallback(value) {
                    var wholeWeekDays = 7 * Math.floor((value - 1) / 7);
                    return (
                      ((value + options.weekStartsOn + 6) % 7) + wholeWeekDays
                    );
                  };
                  switch (token) {
                    case 'c':
                    case 'cc':
                      return mapValue(
                        parseNDigits(token.length, dateString),
                        valueCallback
                      );
                    case 'co':
                      return mapValue(
                        match.ordinalNumber(dateString, { unit: 'day' }),
                        valueCallback
                      );
                    case 'ccc':
                      return (
                        match.day(dateString, {
                          width: 'abbreviated',
                          context: 'standalone',
                        }) ||
                        match.day(dateString, {
                          width: 'short',
                          context: 'standalone',
                        }) ||
                        match.day(dateString, {
                          width: 'narrow',
                          context: 'standalone',
                        })
                      );
                    case 'ccccc':
                      return match.day(dateString, {
                        width: 'narrow',
                        context: 'standalone',
                      });
                    case 'cccccc':
                      return (
                        match.day(dateString, {
                          width: 'short',
                          context: 'standalone',
                        }) ||
                        match.day(dateString, {
                          width: 'narrow',
                          context: 'standalone',
                        })
                      );
                    default:
                      return (
                        match.day(dateString, {
                          width: 'wide',
                          context: 'standalone',
                        }) ||
                        match.day(dateString, {
                          width: 'abbreviated',
                          context: 'standalone',
                        }) ||
                        match.day(dateString, {
                          width: 'short',
                          context: 'standalone',
                        }) ||
                        match.day(dateString, {
                          width: 'narrow',
                          context: 'standalone',
                        })
                      );
                  }
                },
              },
              {
                key: 'validate',
                value: function validate(_date, value) {
                  return value >= 0 && value <= 6;
                },
              },
              {
                key: 'set',
                value: function set(date, _flags, value, options) {
                  return (
                    (date = setUTCDay(date, value, options)).setUTCHours(
                      0,
                      0,
                      0,
                      0
                    ),
                    date
                  );
                },
              },
            ]),
            StandAloneLocalDayParser
          );
        })(Parser);
        function ISODayParser_typeof(obj) {
          return (
            (ISODayParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            ISODayParser_typeof(obj)
          );
        }
        function ISODayParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function ISODayParser_setPrototypeOf(o, p) {
          return (
            (ISODayParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            ISODayParser_setPrototypeOf(o, p)
          );
        }
        function ISODayParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function ISODayParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = ISODayParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget = ISODayParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function ISODayParser_possibleConstructorReturn(
              self,
              call
            ) {
              if (
                call &&
                ('object' === ISODayParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return ISODayParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function ISODayParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function ISODayParser_getPrototypeOf(o) {
          return (
            (ISODayParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            ISODayParser_getPrototypeOf(o)
          );
        }
        function ISODayParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var ISODayParser = (function (_Parser) {
          !(function ISODayParser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass && ISODayParser_setPrototypeOf(subClass, superClass);
          })(ISODayParser, _Parser);
          var _super = ISODayParser_createSuper(ISODayParser);
          function ISODayParser() {
            var _this;
            !(function ISODayParser_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, ISODayParser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              ISODayParser_defineProperty(
                ISODayParser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                90
              ),
              ISODayParser_defineProperty(
                ISODayParser_assertThisInitialized(_this),
                'incompatibleTokens',
                [
                  'y',
                  'Y',
                  'u',
                  'q',
                  'Q',
                  'M',
                  'L',
                  'w',
                  'd',
                  'D',
                  'E',
                  'e',
                  'c',
                  't',
                  'T',
                ]
              ),
              _this
            );
          }
          return (
            (function ISODayParser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  ISODayParser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  ISODayParser_defineProperties(Constructor, staticProps),
                Constructor
              );
            })(ISODayParser, [
              {
                key: 'parse',
                value: function parse(dateString, token, match) {
                  var valueCallback = function valueCallback(value) {
                    return 0 === value ? 7 : value;
                  };
                  switch (token) {
                    case 'i':
                    case 'ii':
                      return parseNDigits(token.length, dateString);
                    case 'io':
                      return match.ordinalNumber(dateString, { unit: 'day' });
                    case 'iii':
                      return mapValue(
                        match.day(dateString, {
                          width: 'abbreviated',
                          context: 'formatting',
                        }) ||
                          match.day(dateString, {
                            width: 'short',
                            context: 'formatting',
                          }) ||
                          match.day(dateString, {
                            width: 'narrow',
                            context: 'formatting',
                          }),
                        valueCallback
                      );
                    case 'iiiii':
                      return mapValue(
                        match.day(dateString, {
                          width: 'narrow',
                          context: 'formatting',
                        }),
                        valueCallback
                      );
                    case 'iiiiii':
                      return mapValue(
                        match.day(dateString, {
                          width: 'short',
                          context: 'formatting',
                        }) ||
                          match.day(dateString, {
                            width: 'narrow',
                            context: 'formatting',
                          }),
                        valueCallback
                      );
                    default:
                      return mapValue(
                        match.day(dateString, {
                          width: 'wide',
                          context: 'formatting',
                        }) ||
                          match.day(dateString, {
                            width: 'abbreviated',
                            context: 'formatting',
                          }) ||
                          match.day(dateString, {
                            width: 'short',
                            context: 'formatting',
                          }) ||
                          match.day(dateString, {
                            width: 'narrow',
                            context: 'formatting',
                          }),
                        valueCallback
                      );
                  }
                },
              },
              {
                key: 'validate',
                value: function validate(_date, value) {
                  return value >= 1 && value <= 7;
                },
              },
              {
                key: 'set',
                value: function set(date, _flags, value) {
                  return (
                    (date = (function setUTCISODay(dirtyDate, dirtyDay) {
                      requiredArgs(2, arguments);
                      var day = toInteger(dirtyDay);
                      day % 7 == 0 && (day -= 7);
                      var date = toDate(dirtyDate),
                        diff =
                          (((day % 7) + 7) % 7 < 1 ? 7 : 0) +
                          day -
                          date.getUTCDay();
                      return date.setUTCDate(date.getUTCDate() + diff), date;
                    })(date, value)),
                    date.setUTCHours(0, 0, 0, 0),
                    date
                  );
                },
              },
            ]),
            ISODayParser
          );
        })(Parser);
        function AMPMParser_typeof(obj) {
          return (
            (AMPMParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            AMPMParser_typeof(obj)
          );
        }
        function AMPMParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function AMPMParser_setPrototypeOf(o, p) {
          return (
            (AMPMParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            AMPMParser_setPrototypeOf(o, p)
          );
        }
        function AMPMParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function AMPMParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = AMPMParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget = AMPMParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function AMPMParser_possibleConstructorReturn(self, call) {
              if (
                call &&
                ('object' === AMPMParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return AMPMParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function AMPMParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function AMPMParser_getPrototypeOf(o) {
          return (
            (AMPMParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            AMPMParser_getPrototypeOf(o)
          );
        }
        function AMPMParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var AMPMParser = (function (_Parser) {
          !(function AMPMParser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass && AMPMParser_setPrototypeOf(subClass, superClass);
          })(AMPMParser, _Parser);
          var _super = AMPMParser_createSuper(AMPMParser);
          function AMPMParser() {
            var _this;
            !(function AMPMParser_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, AMPMParser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              AMPMParser_defineProperty(
                AMPMParser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                80
              ),
              AMPMParser_defineProperty(
                AMPMParser_assertThisInitialized(_this),
                'incompatibleTokens',
                ['b', 'B', 'H', 'k', 't', 'T']
              ),
              _this
            );
          }
          return (
            (function AMPMParser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  AMPMParser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  AMPMParser_defineProperties(Constructor, staticProps),
                Constructor
              );
            })(AMPMParser, [
              {
                key: 'parse',
                value: function parse(dateString, token, match) {
                  switch (token) {
                    case 'a':
                    case 'aa':
                    case 'aaa':
                      return (
                        match.dayPeriod(dateString, {
                          width: 'abbreviated',
                          context: 'formatting',
                        }) ||
                        match.dayPeriod(dateString, {
                          width: 'narrow',
                          context: 'formatting',
                        })
                      );
                    case 'aaaaa':
                      return match.dayPeriod(dateString, {
                        width: 'narrow',
                        context: 'formatting',
                      });
                    default:
                      return (
                        match.dayPeriod(dateString, {
                          width: 'wide',
                          context: 'formatting',
                        }) ||
                        match.dayPeriod(dateString, {
                          width: 'abbreviated',
                          context: 'formatting',
                        }) ||
                        match.dayPeriod(dateString, {
                          width: 'narrow',
                          context: 'formatting',
                        })
                      );
                  }
                },
              },
              {
                key: 'set',
                value: function set(date, _flags, value) {
                  return (
                    date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0), date
                  );
                },
              },
            ]),
            AMPMParser
          );
        })(Parser);
        function AMPMMidnightParser_typeof(obj) {
          return (
            (AMPMMidnightParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            AMPMMidnightParser_typeof(obj)
          );
        }
        function AMPMMidnightParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function AMPMMidnightParser_setPrototypeOf(o, p) {
          return (
            (AMPMMidnightParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            AMPMMidnightParser_setPrototypeOf(o, p)
          );
        }
        function AMPMMidnightParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function AMPMMidnightParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = AMPMMidnightParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget =
                AMPMMidnightParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function AMPMMidnightParser_possibleConstructorReturn(
              self,
              call
            ) {
              if (
                call &&
                ('object' === AMPMMidnightParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return AMPMMidnightParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function AMPMMidnightParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function AMPMMidnightParser_getPrototypeOf(o) {
          return (
            (AMPMMidnightParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            AMPMMidnightParser_getPrototypeOf(o)
          );
        }
        function AMPMMidnightParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var AMPMMidnightParser = (function (_Parser) {
          !(function AMPMMidnightParser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass &&
                AMPMMidnightParser_setPrototypeOf(subClass, superClass);
          })(AMPMMidnightParser, _Parser);
          var _super = AMPMMidnightParser_createSuper(AMPMMidnightParser);
          function AMPMMidnightParser() {
            var _this;
            !(function AMPMMidnightParser_classCallCheck(
              instance,
              Constructor
            ) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, AMPMMidnightParser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              AMPMMidnightParser_defineProperty(
                AMPMMidnightParser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                80
              ),
              AMPMMidnightParser_defineProperty(
                AMPMMidnightParser_assertThisInitialized(_this),
                'incompatibleTokens',
                ['a', 'B', 'H', 'k', 't', 'T']
              ),
              _this
            );
          }
          return (
            (function AMPMMidnightParser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  AMPMMidnightParser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  AMPMMidnightParser_defineProperties(Constructor, staticProps),
                Constructor
              );
            })(AMPMMidnightParser, [
              {
                key: 'parse',
                value: function parse(dateString, token, match) {
                  switch (token) {
                    case 'b':
                    case 'bb':
                    case 'bbb':
                      return (
                        match.dayPeriod(dateString, {
                          width: 'abbreviated',
                          context: 'formatting',
                        }) ||
                        match.dayPeriod(dateString, {
                          width: 'narrow',
                          context: 'formatting',
                        })
                      );
                    case 'bbbbb':
                      return match.dayPeriod(dateString, {
                        width: 'narrow',
                        context: 'formatting',
                      });
                    default:
                      return (
                        match.dayPeriod(dateString, {
                          width: 'wide',
                          context: 'formatting',
                        }) ||
                        match.dayPeriod(dateString, {
                          width: 'abbreviated',
                          context: 'formatting',
                        }) ||
                        match.dayPeriod(dateString, {
                          width: 'narrow',
                          context: 'formatting',
                        })
                      );
                  }
                },
              },
              {
                key: 'set',
                value: function set(date, _flags, value) {
                  return (
                    date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0), date
                  );
                },
              },
            ]),
            AMPMMidnightParser
          );
        })(Parser);
        function DayPeriodParser_typeof(obj) {
          return (
            (DayPeriodParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            DayPeriodParser_typeof(obj)
          );
        }
        function DayPeriodParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function DayPeriodParser_setPrototypeOf(o, p) {
          return (
            (DayPeriodParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            DayPeriodParser_setPrototypeOf(o, p)
          );
        }
        function DayPeriodParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function DayPeriodParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = DayPeriodParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget = DayPeriodParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function DayPeriodParser_possibleConstructorReturn(
              self,
              call
            ) {
              if (
                call &&
                ('object' === DayPeriodParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return DayPeriodParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function DayPeriodParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function DayPeriodParser_getPrototypeOf(o) {
          return (
            (DayPeriodParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            DayPeriodParser_getPrototypeOf(o)
          );
        }
        function DayPeriodParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var DayPeriodParser = (function (_Parser) {
          !(function DayPeriodParser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass &&
                DayPeriodParser_setPrototypeOf(subClass, superClass);
          })(DayPeriodParser, _Parser);
          var _super = DayPeriodParser_createSuper(DayPeriodParser);
          function DayPeriodParser() {
            var _this;
            !(function DayPeriodParser_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, DayPeriodParser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              DayPeriodParser_defineProperty(
                DayPeriodParser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                80
              ),
              DayPeriodParser_defineProperty(
                DayPeriodParser_assertThisInitialized(_this),
                'incompatibleTokens',
                ['a', 'b', 't', 'T']
              ),
              _this
            );
          }
          return (
            (function DayPeriodParser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  DayPeriodParser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  DayPeriodParser_defineProperties(Constructor, staticProps),
                Constructor
              );
            })(DayPeriodParser, [
              {
                key: 'parse',
                value: function parse(dateString, token, match) {
                  switch (token) {
                    case 'B':
                    case 'BB':
                    case 'BBB':
                      return (
                        match.dayPeriod(dateString, {
                          width: 'abbreviated',
                          context: 'formatting',
                        }) ||
                        match.dayPeriod(dateString, {
                          width: 'narrow',
                          context: 'formatting',
                        })
                      );
                    case 'BBBBB':
                      return match.dayPeriod(dateString, {
                        width: 'narrow',
                        context: 'formatting',
                      });
                    default:
                      return (
                        match.dayPeriod(dateString, {
                          width: 'wide',
                          context: 'formatting',
                        }) ||
                        match.dayPeriod(dateString, {
                          width: 'abbreviated',
                          context: 'formatting',
                        }) ||
                        match.dayPeriod(dateString, {
                          width: 'narrow',
                          context: 'formatting',
                        })
                      );
                  }
                },
              },
              {
                key: 'set',
                value: function set(date, _flags, value) {
                  return (
                    date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0), date
                  );
                },
              },
            ]),
            DayPeriodParser
          );
        })(Parser);
        function Hour1to12Parser_typeof(obj) {
          return (
            (Hour1to12Parser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            Hour1to12Parser_typeof(obj)
          );
        }
        function Hour1to12Parser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function Hour1to12Parser_setPrototypeOf(o, p) {
          return (
            (Hour1to12Parser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            Hour1to12Parser_setPrototypeOf(o, p)
          );
        }
        function Hour1to12Parser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function Hour1to12Parser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = Hour1to12Parser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget = Hour1to12Parser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function Hour1to12Parser_possibleConstructorReturn(
              self,
              call
            ) {
              if (
                call &&
                ('object' === Hour1to12Parser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return Hour1to12Parser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function Hour1to12Parser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function Hour1to12Parser_getPrototypeOf(o) {
          return (
            (Hour1to12Parser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            Hour1to12Parser_getPrototypeOf(o)
          );
        }
        function Hour1to12Parser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var Hour1to12Parser = (function (_Parser) {
          !(function Hour1to12Parser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass &&
                Hour1to12Parser_setPrototypeOf(subClass, superClass);
          })(Hour1to12Parser, _Parser);
          var _super = Hour1to12Parser_createSuper(Hour1to12Parser);
          function Hour1to12Parser() {
            var _this;
            !(function Hour1to12Parser_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, Hour1to12Parser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              Hour1to12Parser_defineProperty(
                Hour1to12Parser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                70
              ),
              Hour1to12Parser_defineProperty(
                Hour1to12Parser_assertThisInitialized(_this),
                'incompatibleTokens',
                ['H', 'K', 'k', 't', 'T']
              ),
              _this
            );
          }
          return (
            (function Hour1to12Parser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  Hour1to12Parser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  Hour1to12Parser_defineProperties(Constructor, staticProps),
                Constructor
              );
            })(Hour1to12Parser, [
              {
                key: 'parse',
                value: function parse(dateString, token, match) {
                  switch (token) {
                    case 'h':
                      return parseNumericPattern(
                        numericPatterns.hour12h,
                        dateString
                      );
                    case 'ho':
                      return match.ordinalNumber(dateString, { unit: 'hour' });
                    default:
                      return parseNDigits(token.length, dateString);
                  }
                },
              },
              {
                key: 'validate',
                value: function validate(_date, value) {
                  return value >= 1 && value <= 12;
                },
              },
              {
                key: 'set',
                value: function set(date, _flags, value) {
                  var isPM = date.getUTCHours() >= 12;
                  return (
                    isPM && value < 12
                      ? date.setUTCHours(value + 12, 0, 0, 0)
                      : isPM || 12 !== value
                      ? date.setUTCHours(value, 0, 0, 0)
                      : date.setUTCHours(0, 0, 0, 0),
                    date
                  );
                },
              },
            ]),
            Hour1to12Parser
          );
        })(Parser);
        function Hour0to23Parser_typeof(obj) {
          return (
            (Hour0to23Parser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            Hour0to23Parser_typeof(obj)
          );
        }
        function Hour0to23Parser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function Hour0to23Parser_setPrototypeOf(o, p) {
          return (
            (Hour0to23Parser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            Hour0to23Parser_setPrototypeOf(o, p)
          );
        }
        function Hour0to23Parser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function Hour0to23Parser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = Hour0to23Parser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget = Hour0to23Parser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function Hour0to23Parser_possibleConstructorReturn(
              self,
              call
            ) {
              if (
                call &&
                ('object' === Hour0to23Parser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return Hour0to23Parser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function Hour0to23Parser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function Hour0to23Parser_getPrototypeOf(o) {
          return (
            (Hour0to23Parser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            Hour0to23Parser_getPrototypeOf(o)
          );
        }
        function Hour0to23Parser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var Hour0to23Parser = (function (_Parser) {
          !(function Hour0to23Parser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass &&
                Hour0to23Parser_setPrototypeOf(subClass, superClass);
          })(Hour0to23Parser, _Parser);
          var _super = Hour0to23Parser_createSuper(Hour0to23Parser);
          function Hour0to23Parser() {
            var _this;
            !(function Hour0to23Parser_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, Hour0to23Parser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              Hour0to23Parser_defineProperty(
                Hour0to23Parser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                70
              ),
              Hour0to23Parser_defineProperty(
                Hour0to23Parser_assertThisInitialized(_this),
                'incompatibleTokens',
                ['a', 'b', 'h', 'K', 'k', 't', 'T']
              ),
              _this
            );
          }
          return (
            (function Hour0to23Parser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  Hour0to23Parser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  Hour0to23Parser_defineProperties(Constructor, staticProps),
                Constructor
              );
            })(Hour0to23Parser, [
              {
                key: 'parse',
                value: function parse(dateString, token, match) {
                  switch (token) {
                    case 'H':
                      return parseNumericPattern(
                        numericPatterns.hour23h,
                        dateString
                      );
                    case 'Ho':
                      return match.ordinalNumber(dateString, { unit: 'hour' });
                    default:
                      return parseNDigits(token.length, dateString);
                  }
                },
              },
              {
                key: 'validate',
                value: function validate(_date, value) {
                  return value >= 0 && value <= 23;
                },
              },
              {
                key: 'set',
                value: function set(date, _flags, value) {
                  return date.setUTCHours(value, 0, 0, 0), date;
                },
              },
            ]),
            Hour0to23Parser
          );
        })(Parser);
        function Hour0To11Parser_typeof(obj) {
          return (
            (Hour0To11Parser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            Hour0To11Parser_typeof(obj)
          );
        }
        function Hour0To11Parser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function Hour0To11Parser_setPrototypeOf(o, p) {
          return (
            (Hour0To11Parser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            Hour0To11Parser_setPrototypeOf(o, p)
          );
        }
        function Hour0To11Parser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function Hour0To11Parser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = Hour0To11Parser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget = Hour0To11Parser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function Hour0To11Parser_possibleConstructorReturn(
              self,
              call
            ) {
              if (
                call &&
                ('object' === Hour0To11Parser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return Hour0To11Parser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function Hour0To11Parser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function Hour0To11Parser_getPrototypeOf(o) {
          return (
            (Hour0To11Parser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            Hour0To11Parser_getPrototypeOf(o)
          );
        }
        function Hour0To11Parser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var Hour0To11Parser = (function (_Parser) {
          !(function Hour0To11Parser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass &&
                Hour0To11Parser_setPrototypeOf(subClass, superClass);
          })(Hour0To11Parser, _Parser);
          var _super = Hour0To11Parser_createSuper(Hour0To11Parser);
          function Hour0To11Parser() {
            var _this;
            !(function Hour0To11Parser_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, Hour0To11Parser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              Hour0To11Parser_defineProperty(
                Hour0To11Parser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                70
              ),
              Hour0To11Parser_defineProperty(
                Hour0To11Parser_assertThisInitialized(_this),
                'incompatibleTokens',
                ['h', 'H', 'k', 't', 'T']
              ),
              _this
            );
          }
          return (
            (function Hour0To11Parser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  Hour0To11Parser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  Hour0To11Parser_defineProperties(Constructor, staticProps),
                Constructor
              );
            })(Hour0To11Parser, [
              {
                key: 'parse',
                value: function parse(dateString, token, match) {
                  switch (token) {
                    case 'K':
                      return parseNumericPattern(
                        numericPatterns.hour11h,
                        dateString
                      );
                    case 'Ko':
                      return match.ordinalNumber(dateString, { unit: 'hour' });
                    default:
                      return parseNDigits(token.length, dateString);
                  }
                },
              },
              {
                key: 'validate',
                value: function validate(_date, value) {
                  return value >= 0 && value <= 11;
                },
              },
              {
                key: 'set',
                value: function set(date, _flags, value) {
                  return (
                    date.getUTCHours() >= 12 && value < 12
                      ? date.setUTCHours(value + 12, 0, 0, 0)
                      : date.setUTCHours(value, 0, 0, 0),
                    date
                  );
                },
              },
            ]),
            Hour0To11Parser
          );
        })(Parser);
        function Hour1To24Parser_typeof(obj) {
          return (
            (Hour1To24Parser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            Hour1To24Parser_typeof(obj)
          );
        }
        function Hour1To24Parser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function Hour1To24Parser_setPrototypeOf(o, p) {
          return (
            (Hour1To24Parser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            Hour1To24Parser_setPrototypeOf(o, p)
          );
        }
        function Hour1To24Parser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function Hour1To24Parser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = Hour1To24Parser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget = Hour1To24Parser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function Hour1To24Parser_possibleConstructorReturn(
              self,
              call
            ) {
              if (
                call &&
                ('object' === Hour1To24Parser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return Hour1To24Parser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function Hour1To24Parser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function Hour1To24Parser_getPrototypeOf(o) {
          return (
            (Hour1To24Parser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            Hour1To24Parser_getPrototypeOf(o)
          );
        }
        function Hour1To24Parser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var Hour1To24Parser = (function (_Parser) {
          !(function Hour1To24Parser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass &&
                Hour1To24Parser_setPrototypeOf(subClass, superClass);
          })(Hour1To24Parser, _Parser);
          var _super = Hour1To24Parser_createSuper(Hour1To24Parser);
          function Hour1To24Parser() {
            var _this;
            !(function Hour1To24Parser_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, Hour1To24Parser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              Hour1To24Parser_defineProperty(
                Hour1To24Parser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                70
              ),
              Hour1To24Parser_defineProperty(
                Hour1To24Parser_assertThisInitialized(_this),
                'incompatibleTokens',
                ['a', 'b', 'h', 'H', 'K', 't', 'T']
              ),
              _this
            );
          }
          return (
            (function Hour1To24Parser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  Hour1To24Parser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  Hour1To24Parser_defineProperties(Constructor, staticProps),
                Constructor
              );
            })(Hour1To24Parser, [
              {
                key: 'parse',
                value: function parse(dateString, token, match) {
                  switch (token) {
                    case 'k':
                      return parseNumericPattern(
                        numericPatterns.hour24h,
                        dateString
                      );
                    case 'ko':
                      return match.ordinalNumber(dateString, { unit: 'hour' });
                    default:
                      return parseNDigits(token.length, dateString);
                  }
                },
              },
              {
                key: 'validate',
                value: function validate(_date, value) {
                  return value >= 1 && value <= 24;
                },
              },
              {
                key: 'set',
                value: function set(date, _flags, value) {
                  var hours = value <= 24 ? value % 24 : value;
                  return date.setUTCHours(hours, 0, 0, 0), date;
                },
              },
            ]),
            Hour1To24Parser
          );
        })(Parser);
        function MinuteParser_typeof(obj) {
          return (
            (MinuteParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            MinuteParser_typeof(obj)
          );
        }
        function MinuteParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function MinuteParser_setPrototypeOf(o, p) {
          return (
            (MinuteParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            MinuteParser_setPrototypeOf(o, p)
          );
        }
        function MinuteParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function MinuteParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = MinuteParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget = MinuteParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function MinuteParser_possibleConstructorReturn(
              self,
              call
            ) {
              if (
                call &&
                ('object' === MinuteParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return MinuteParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function MinuteParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function MinuteParser_getPrototypeOf(o) {
          return (
            (MinuteParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            MinuteParser_getPrototypeOf(o)
          );
        }
        function MinuteParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var MinuteParser = (function (_Parser) {
          !(function MinuteParser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass && MinuteParser_setPrototypeOf(subClass, superClass);
          })(MinuteParser, _Parser);
          var _super = MinuteParser_createSuper(MinuteParser);
          function MinuteParser() {
            var _this;
            !(function MinuteParser_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, MinuteParser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              MinuteParser_defineProperty(
                MinuteParser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                60
              ),
              MinuteParser_defineProperty(
                MinuteParser_assertThisInitialized(_this),
                'incompatibleTokens',
                ['t', 'T']
              ),
              _this
            );
          }
          return (
            (function MinuteParser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  MinuteParser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  MinuteParser_defineProperties(Constructor, staticProps),
                Constructor
              );
            })(MinuteParser, [
              {
                key: 'parse',
                value: function parse(dateString, token, match) {
                  switch (token) {
                    case 'm':
                      return parseNumericPattern(
                        numericPatterns.minute,
                        dateString
                      );
                    case 'mo':
                      return match.ordinalNumber(dateString, {
                        unit: 'minute',
                      });
                    default:
                      return parseNDigits(token.length, dateString);
                  }
                },
              },
              {
                key: 'validate',
                value: function validate(_date, value) {
                  return value >= 0 && value <= 59;
                },
              },
              {
                key: 'set',
                value: function set(date, _flags, value) {
                  return date.setUTCMinutes(value, 0, 0), date;
                },
              },
            ]),
            MinuteParser
          );
        })(Parser);
        function SecondParser_typeof(obj) {
          return (
            (SecondParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            SecondParser_typeof(obj)
          );
        }
        function SecondParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function SecondParser_setPrototypeOf(o, p) {
          return (
            (SecondParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            SecondParser_setPrototypeOf(o, p)
          );
        }
        function SecondParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function SecondParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = SecondParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget = SecondParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function SecondParser_possibleConstructorReturn(
              self,
              call
            ) {
              if (
                call &&
                ('object' === SecondParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return SecondParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function SecondParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function SecondParser_getPrototypeOf(o) {
          return (
            (SecondParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            SecondParser_getPrototypeOf(o)
          );
        }
        function SecondParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var SecondParser = (function (_Parser) {
          !(function SecondParser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass && SecondParser_setPrototypeOf(subClass, superClass);
          })(SecondParser, _Parser);
          var _super = SecondParser_createSuper(SecondParser);
          function SecondParser() {
            var _this;
            !(function SecondParser_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, SecondParser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              SecondParser_defineProperty(
                SecondParser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                50
              ),
              SecondParser_defineProperty(
                SecondParser_assertThisInitialized(_this),
                'incompatibleTokens',
                ['t', 'T']
              ),
              _this
            );
          }
          return (
            (function SecondParser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  SecondParser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  SecondParser_defineProperties(Constructor, staticProps),
                Constructor
              );
            })(SecondParser, [
              {
                key: 'parse',
                value: function parse(dateString, token, match) {
                  switch (token) {
                    case 's':
                      return parseNumericPattern(
                        numericPatterns.second,
                        dateString
                      );
                    case 'so':
                      return match.ordinalNumber(dateString, {
                        unit: 'second',
                      });
                    default:
                      return parseNDigits(token.length, dateString);
                  }
                },
              },
              {
                key: 'validate',
                value: function validate(_date, value) {
                  return value >= 0 && value <= 59;
                },
              },
              {
                key: 'set',
                value: function set(date, _flags, value) {
                  return date.setUTCSeconds(value, 0), date;
                },
              },
            ]),
            SecondParser
          );
        })(Parser);
        function FractionOfSecondParser_typeof(obj) {
          return (
            (FractionOfSecondParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            FractionOfSecondParser_typeof(obj)
          );
        }
        function FractionOfSecondParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function FractionOfSecondParser_setPrototypeOf(o, p) {
          return (
            (FractionOfSecondParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            FractionOfSecondParser_setPrototypeOf(o, p)
          );
        }
        function FractionOfSecondParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function FractionOfSecondParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = FractionOfSecondParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget =
                FractionOfSecondParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function FractionOfSecondParser_possibleConstructorReturn(
              self,
              call
            ) {
              if (
                call &&
                ('object' === FractionOfSecondParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return FractionOfSecondParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function FractionOfSecondParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function FractionOfSecondParser_getPrototypeOf(o) {
          return (
            (FractionOfSecondParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            FractionOfSecondParser_getPrototypeOf(o)
          );
        }
        function FractionOfSecondParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var FractionOfSecondParser = (function (_Parser) {
          !(function FractionOfSecondParser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass &&
                FractionOfSecondParser_setPrototypeOf(subClass, superClass);
          })(FractionOfSecondParser, _Parser);
          var _super = FractionOfSecondParser_createSuper(
            FractionOfSecondParser
          );
          function FractionOfSecondParser() {
            var _this;
            !(function FractionOfSecondParser_classCallCheck(
              instance,
              Constructor
            ) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, FractionOfSecondParser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              FractionOfSecondParser_defineProperty(
                FractionOfSecondParser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                30
              ),
              FractionOfSecondParser_defineProperty(
                FractionOfSecondParser_assertThisInitialized(_this),
                'incompatibleTokens',
                ['t', 'T']
              ),
              _this
            );
          }
          return (
            (function FractionOfSecondParser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  FractionOfSecondParser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  FractionOfSecondParser_defineProperties(
                    Constructor,
                    staticProps
                  ),
                Constructor
              );
            })(FractionOfSecondParser, [
              {
                key: 'parse',
                value: function parse(dateString, token) {
                  return mapValue(
                    parseNDigits(token.length, dateString),
                    function valueCallback(value) {
                      return Math.floor(value * Math.pow(10, 3 - token.length));
                    }
                  );
                },
              },
              {
                key: 'set',
                value: function set(date, _flags, value) {
                  return date.setUTCMilliseconds(value), date;
                },
              },
            ]),
            FractionOfSecondParser
          );
        })(Parser);
        function ISOTimezoneWithZParser_typeof(obj) {
          return (
            (ISOTimezoneWithZParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            ISOTimezoneWithZParser_typeof(obj)
          );
        }
        function ISOTimezoneWithZParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function ISOTimezoneWithZParser_setPrototypeOf(o, p) {
          return (
            (ISOTimezoneWithZParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            ISOTimezoneWithZParser_setPrototypeOf(o, p)
          );
        }
        function ISOTimezoneWithZParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function ISOTimezoneWithZParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = ISOTimezoneWithZParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget =
                ISOTimezoneWithZParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function ISOTimezoneWithZParser_possibleConstructorReturn(
              self,
              call
            ) {
              if (
                call &&
                ('object' === ISOTimezoneWithZParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return ISOTimezoneWithZParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function ISOTimezoneWithZParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function ISOTimezoneWithZParser_getPrototypeOf(o) {
          return (
            (ISOTimezoneWithZParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            ISOTimezoneWithZParser_getPrototypeOf(o)
          );
        }
        function ISOTimezoneWithZParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var ISOTimezoneWithZParser = (function (_Parser) {
          !(function ISOTimezoneWithZParser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass &&
                ISOTimezoneWithZParser_setPrototypeOf(subClass, superClass);
          })(ISOTimezoneWithZParser, _Parser);
          var _super = ISOTimezoneWithZParser_createSuper(
            ISOTimezoneWithZParser
          );
          function ISOTimezoneWithZParser() {
            var _this;
            !(function ISOTimezoneWithZParser_classCallCheck(
              instance,
              Constructor
            ) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, ISOTimezoneWithZParser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              ISOTimezoneWithZParser_defineProperty(
                ISOTimezoneWithZParser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                10
              ),
              ISOTimezoneWithZParser_defineProperty(
                ISOTimezoneWithZParser_assertThisInitialized(_this),
                'incompatibleTokens',
                ['t', 'T', 'x']
              ),
              _this
            );
          }
          return (
            (function ISOTimezoneWithZParser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  ISOTimezoneWithZParser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  ISOTimezoneWithZParser_defineProperties(
                    Constructor,
                    staticProps
                  ),
                Constructor
              );
            })(ISOTimezoneWithZParser, [
              {
                key: 'parse',
                value: function parse(dateString, token) {
                  switch (token) {
                    case 'X':
                      return parseTimezonePattern(
                        timezonePatterns_basicOptionalMinutes,
                        dateString
                      );
                    case 'XX':
                      return parseTimezonePattern(
                        timezonePatterns_basic,
                        dateString
                      );
                    case 'XXXX':
                      return parseTimezonePattern(
                        timezonePatterns_basicOptionalSeconds,
                        dateString
                      );
                    case 'XXXXX':
                      return parseTimezonePattern(
                        timezonePatterns_extendedOptionalSeconds,
                        dateString
                      );
                    default:
                      return parseTimezonePattern(
                        timezonePatterns_extended,
                        dateString
                      );
                  }
                },
              },
              {
                key: 'set',
                value: function set(date, flags, value) {
                  return flags.timestampIsSet
                    ? date
                    : new Date(date.getTime() - value);
                },
              },
            ]),
            ISOTimezoneWithZParser
          );
        })(Parser);
        function ISOTimezoneParser_typeof(obj) {
          return (
            (ISOTimezoneParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            ISOTimezoneParser_typeof(obj)
          );
        }
        function ISOTimezoneParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function ISOTimezoneParser_setPrototypeOf(o, p) {
          return (
            (ISOTimezoneParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            ISOTimezoneParser_setPrototypeOf(o, p)
          );
        }
        function ISOTimezoneParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function ISOTimezoneParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = ISOTimezoneParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget =
                ISOTimezoneParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function ISOTimezoneParser_possibleConstructorReturn(
              self,
              call
            ) {
              if (
                call &&
                ('object' === ISOTimezoneParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return ISOTimezoneParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function ISOTimezoneParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function ISOTimezoneParser_getPrototypeOf(o) {
          return (
            (ISOTimezoneParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            ISOTimezoneParser_getPrototypeOf(o)
          );
        }
        function ISOTimezoneParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var ISOTimezoneParser = (function (_Parser) {
          !(function ISOTimezoneParser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass &&
                ISOTimezoneParser_setPrototypeOf(subClass, superClass);
          })(ISOTimezoneParser, _Parser);
          var _super = ISOTimezoneParser_createSuper(ISOTimezoneParser);
          function ISOTimezoneParser() {
            var _this;
            !(function ISOTimezoneParser_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, ISOTimezoneParser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              ISOTimezoneParser_defineProperty(
                ISOTimezoneParser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                10
              ),
              ISOTimezoneParser_defineProperty(
                ISOTimezoneParser_assertThisInitialized(_this),
                'incompatibleTokens',
                ['t', 'T', 'X']
              ),
              _this
            );
          }
          return (
            (function ISOTimezoneParser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  ISOTimezoneParser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  ISOTimezoneParser_defineProperties(Constructor, staticProps),
                Constructor
              );
            })(ISOTimezoneParser, [
              {
                key: 'parse',
                value: function parse(dateString, token) {
                  switch (token) {
                    case 'x':
                      return parseTimezonePattern(
                        timezonePatterns_basicOptionalMinutes,
                        dateString
                      );
                    case 'xx':
                      return parseTimezonePattern(
                        timezonePatterns_basic,
                        dateString
                      );
                    case 'xxxx':
                      return parseTimezonePattern(
                        timezonePatterns_basicOptionalSeconds,
                        dateString
                      );
                    case 'xxxxx':
                      return parseTimezonePattern(
                        timezonePatterns_extendedOptionalSeconds,
                        dateString
                      );
                    default:
                      return parseTimezonePattern(
                        timezonePatterns_extended,
                        dateString
                      );
                  }
                },
              },
              {
                key: 'set',
                value: function set(date, flags, value) {
                  return flags.timestampIsSet
                    ? date
                    : new Date(date.getTime() - value);
                },
              },
            ]),
            ISOTimezoneParser
          );
        })(Parser);
        function TimestampSecondsParser_typeof(obj) {
          return (
            (TimestampSecondsParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            TimestampSecondsParser_typeof(obj)
          );
        }
        function TimestampSecondsParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function TimestampSecondsParser_setPrototypeOf(o, p) {
          return (
            (TimestampSecondsParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            TimestampSecondsParser_setPrototypeOf(o, p)
          );
        }
        function TimestampSecondsParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function TimestampSecondsParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = TimestampSecondsParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget =
                TimestampSecondsParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function TimestampSecondsParser_possibleConstructorReturn(
              self,
              call
            ) {
              if (
                call &&
                ('object' === TimestampSecondsParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return TimestampSecondsParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function TimestampSecondsParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function TimestampSecondsParser_getPrototypeOf(o) {
          return (
            (TimestampSecondsParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            TimestampSecondsParser_getPrototypeOf(o)
          );
        }
        function TimestampSecondsParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var TimestampSecondsParser = (function (_Parser) {
          !(function TimestampSecondsParser_inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            (subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0,
                },
              }
            )),
              superClass &&
                TimestampSecondsParser_setPrototypeOf(subClass, superClass);
          })(TimestampSecondsParser, _Parser);
          var _super = TimestampSecondsParser_createSuper(
            TimestampSecondsParser
          );
          function TimestampSecondsParser() {
            var _this;
            !(function TimestampSecondsParser_classCallCheck(
              instance,
              Constructor
            ) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, TimestampSecondsParser);
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            return (
              TimestampSecondsParser_defineProperty(
                TimestampSecondsParser_assertThisInitialized(
                  (_this = _super.call.apply(_super, [this].concat(args)))
                ),
                'priority',
                40
              ),
              TimestampSecondsParser_defineProperty(
                TimestampSecondsParser_assertThisInitialized(_this),
                'incompatibleTokens',
                '*'
              ),
              _this
            );
          }
          return (
            (function TimestampSecondsParser_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              return (
                protoProps &&
                  TimestampSecondsParser_defineProperties(
                    Constructor.prototype,
                    protoProps
                  ),
                staticProps &&
                  TimestampSecondsParser_defineProperties(
                    Constructor,
                    staticProps
                  ),
                Constructor
              );
            })(TimestampSecondsParser, [
              {
                key: 'parse',
                value: function parse(dateString) {
                  return parseAnyDigitsSigned(dateString);
                },
              },
              {
                key: 'set',
                value: function set(_date, _flags, value) {
                  return [new Date(1e3 * value), { timestampIsSet: !0 }];
                },
              },
            ]),
            TimestampSecondsParser
          );
        })(Parser);
        function TimestampMillisecondsParser_typeof(obj) {
          return (
            (TimestampMillisecondsParser_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            TimestampMillisecondsParser_typeof(obj)
          );
        }
        function TimestampMillisecondsParser_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            (descriptor.enumerable = descriptor.enumerable || !1),
              (descriptor.configurable = !0),
              'value' in descriptor && (descriptor.writable = !0),
              Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function TimestampMillisecondsParser_setPrototypeOf(o, p) {
          return (
            (TimestampMillisecondsParser_setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                return (o.__proto__ = p), o;
              }),
            TimestampMillisecondsParser_setPrototypeOf(o, p)
          );
        }
        function TimestampMillisecondsParser_createSuper(Derived) {
          var hasNativeReflectConstruct =
            (function TimestampMillisecondsParser_isNativeReflectConstruct() {
              if ('undefined' == typeof Reflect || !Reflect.construct)
                return !1;
              if (Reflect.construct.sham) return !1;
              if ('function' == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (e) {
                return !1;
              }
            })();
          return function _createSuperInternal() {
            var result,
              Super = TimestampMillisecondsParser_getPrototypeOf(Derived);
            if (hasNativeReflectConstruct) {
              var NewTarget =
                TimestampMillisecondsParser_getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return (function TimestampMillisecondsParser_possibleConstructorReturn(
              self,
              call
            ) {
              if (
                call &&
                ('object' === TimestampMillisecondsParser_typeof(call) ||
                  'function' == typeof call)
              )
                return call;
              return TimestampMillisecondsParser_assertThisInitialized(self);
            })(this, result);
          };
        }
        function TimestampMillisecondsParser_assertThisInitialized(self) {
          if (void 0 === self)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return self;
        }
        function TimestampMillisecondsParser_getPrototypeOf(o) {
          return (
            (TimestampMillisecondsParser_getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            TimestampMillisecondsParser_getPrototypeOf(o)
          );
        }
        function TimestampMillisecondsParser_defineProperty(obj, key, value) {
          return (
            key in obj
              ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (obj[key] = value),
            obj
          );
        }
        var TimestampMillisecondsParser = (function (_Parser) {
            !(function TimestampMillisecondsParser_inherits(
              subClass,
              superClass
            ) {
              if ('function' != typeof superClass && null !== superClass)
                throw new TypeError(
                  'Super expression must either be null or a function'
                );
              (subClass.prototype = Object.create(
                superClass && superClass.prototype,
                {
                  constructor: {
                    value: subClass,
                    writable: !0,
                    configurable: !0,
                  },
                }
              )),
                superClass &&
                  TimestampMillisecondsParser_setPrototypeOf(
                    subClass,
                    superClass
                  );
            })(TimestampMillisecondsParser, _Parser);
            var _super = TimestampMillisecondsParser_createSuper(
              TimestampMillisecondsParser
            );
            function TimestampMillisecondsParser() {
              var _this;
              !(function TimestampMillisecondsParser_classCallCheck(
                instance,
                Constructor
              ) {
                if (!(instance instanceof Constructor))
                  throw new TypeError('Cannot call a class as a function');
              })(this, TimestampMillisecondsParser);
              for (
                var _len = arguments.length, args = new Array(_len), _key = 0;
                _key < _len;
                _key++
              )
                args[_key] = arguments[_key];
              return (
                TimestampMillisecondsParser_defineProperty(
                  TimestampMillisecondsParser_assertThisInitialized(
                    (_this = _super.call.apply(_super, [this].concat(args)))
                  ),
                  'priority',
                  20
                ),
                TimestampMillisecondsParser_defineProperty(
                  TimestampMillisecondsParser_assertThisInitialized(_this),
                  'incompatibleTokens',
                  '*'
                ),
                _this
              );
            }
            return (
              (function TimestampMillisecondsParser_createClass(
                Constructor,
                protoProps,
                staticProps
              ) {
                return (
                  protoProps &&
                    TimestampMillisecondsParser_defineProperties(
                      Constructor.prototype,
                      protoProps
                    ),
                  staticProps &&
                    TimestampMillisecondsParser_defineProperties(
                      Constructor,
                      staticProps
                    ),
                  Constructor
                );
              })(TimestampMillisecondsParser, [
                {
                  key: 'parse',
                  value: function parse(dateString) {
                    return parseAnyDigitsSigned(dateString);
                  },
                },
                {
                  key: 'set',
                  value: function set(_date, _flags, value) {
                    return [new Date(value), { timestampIsSet: !0 }];
                  },
                },
              ]),
              TimestampMillisecondsParser
            );
          })(Parser),
          parsers = {
            G: new EraParser(),
            y: new YearParser(),
            Y: new LocalWeekYearParser(),
            R: new ISOWeekYearParser(),
            u: new ExtendedYearParser(),
            Q: new QuarterParser(),
            q: new StandAloneQuarterParser(),
            M: new MonthParser(),
            L: new StandAloneMonthParser(),
            w: new LocalWeekParser(),
            I: new ISOWeekParser(),
            d: new DateParser(),
            D: new DayOfYearParser(),
            E: new DayParser(),
            e: new LocalDayParser(),
            c: new StandAloneLocalDayParser(),
            i: new ISODayParser(),
            a: new AMPMParser(),
            b: new AMPMMidnightParser(),
            B: new DayPeriodParser(),
            h: new Hour1to12Parser(),
            H: new Hour0to23Parser(),
            K: new Hour0To11Parser(),
            k: new Hour1To24Parser(),
            m: new MinuteParser(),
            s: new SecondParser(),
            S: new FractionOfSecondParser(),
            X: new ISOTimezoneWithZParser(),
            x: new ISOTimezoneParser(),
            t: new TimestampSecondsParser(),
            T: new TimestampMillisecondsParser(),
          };
        function parse_typeof(obj) {
          return (
            (parse_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            parse_typeof(obj)
          );
        }
        function _createForOfIteratorHelper(o, allowArrayLike) {
          var it;
          if ('undefined' == typeof Symbol || null == o[Symbol.iterator]) {
            if (
              Array.isArray(o) ||
              (it = (function _unsupportedIterableToArray(o, minLen) {
                if (!o) return;
                if ('string' == typeof o) return _arrayLikeToArray(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                'Object' === n && o.constructor && (n = o.constructor.name);
                if ('Map' === n || 'Set' === n) return Array.from(o);
                if (
                  'Arguments' === n ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                )
                  return _arrayLikeToArray(o, minLen);
              })(o)) ||
              (allowArrayLike && o && 'number' == typeof o.length)
            ) {
              it && (o = it);
              var i = 0,
                F = function F() {};
              return {
                s: F,
                n: function n() {
                  return i >= o.length
                    ? { done: !0 }
                    : { done: !1, value: o[i++] };
                },
                e: function e(_e) {
                  throw _e;
                },
                f: F,
              };
            }
            throw new TypeError(
              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
            );
          }
          var err,
            normalCompletion = !0,
            didErr = !1;
          return {
            s: function s() {
              it = o[Symbol.iterator]();
            },
            n: function n() {
              var step = it.next();
              return (normalCompletion = step.done), step;
            },
            e: function e(_e2) {
              (didErr = !0), (err = _e2);
            },
            f: function f() {
              try {
                normalCompletion || null == it.return || it.return();
              } finally {
                if (didErr) throw err;
              }
            },
          };
        }
        function _arrayLikeToArray(arr, len) {
          (null == len || len > arr.length) && (len = arr.length);
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }
        var formattingTokensRegExp =
            /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g,
          longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g,
          escapedStringRegExp = /^'([^]*?)'?$/,
          doubleQuoteRegExp = /''/g,
          notWhitespaceRegExp = /\S/,
          unescapedLatinCharacterRegExp = /[a-zA-Z]/;
        function parse(
          dirtyDateString,
          dirtyFormatString,
          dirtyReferenceDate,
          options
        ) {
          var _ref,
            _options$locale,
            _ref2,
            _ref3,
            _ref4,
            _options$firstWeekCon,
            _options$locale2,
            _options$locale2$opti,
            _defaultOptions$local,
            _defaultOptions$local2,
            _ref5,
            _ref6,
            _ref7,
            _options$weekStartsOn,
            _options$locale3,
            _options$locale3$opti,
            _defaultOptions$local3,
            _defaultOptions$local4;
          requiredArgs(3, arguments);
          var dateString = String(dirtyDateString),
            formatString = String(dirtyFormatString),
            defaultOptions = getDefaultOptions(),
            locale =
              null !==
                (_ref =
                  null !==
                    (_options$locale =
                      null == options ? void 0 : options.locale) &&
                  void 0 !== _options$locale
                    ? _options$locale
                    : defaultOptions.locale) && void 0 !== _ref
                ? _ref
                : defaultLocale;
          if (!locale.match)
            throw new RangeError('locale must contain match property');
          var firstWeekContainsDate = toInteger(
            null !==
              (_ref2 =
                null !==
                  (_ref3 =
                    null !==
                      (_ref4 =
                        null !==
                          (_options$firstWeekCon =
                            null == options
                              ? void 0
                              : options.firstWeekContainsDate) &&
                        void 0 !== _options$firstWeekCon
                          ? _options$firstWeekCon
                          : null == options ||
                            null === (_options$locale2 = options.locale) ||
                            void 0 === _options$locale2 ||
                            null ===
                              (_options$locale2$opti =
                                _options$locale2.options) ||
                            void 0 === _options$locale2$opti
                          ? void 0
                          : _options$locale2$opti.firstWeekContainsDate) &&
                    void 0 !== _ref4
                      ? _ref4
                      : defaultOptions.firstWeekContainsDate) &&
                void 0 !== _ref3
                  ? _ref3
                  : null === (_defaultOptions$local = defaultOptions.locale) ||
                    void 0 === _defaultOptions$local ||
                    null ===
                      (_defaultOptions$local2 =
                        _defaultOptions$local.options) ||
                    void 0 === _defaultOptions$local2
                  ? void 0
                  : _defaultOptions$local2.firstWeekContainsDate) &&
              void 0 !== _ref2
              ? _ref2
              : 1
          );
          if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7))
            throw new RangeError(
              'firstWeekContainsDate must be between 1 and 7 inclusively'
            );
          var weekStartsOn = toInteger(
            null !==
              (_ref5 =
                null !==
                  (_ref6 =
                    null !==
                      (_ref7 =
                        null !==
                          (_options$weekStartsOn =
                            null == options ? void 0 : options.weekStartsOn) &&
                        void 0 !== _options$weekStartsOn
                          ? _options$weekStartsOn
                          : null == options ||
                            null === (_options$locale3 = options.locale) ||
                            void 0 === _options$locale3 ||
                            null ===
                              (_options$locale3$opti =
                                _options$locale3.options) ||
                            void 0 === _options$locale3$opti
                          ? void 0
                          : _options$locale3$opti.weekStartsOn) &&
                    void 0 !== _ref7
                      ? _ref7
                      : defaultOptions.weekStartsOn) && void 0 !== _ref6
                  ? _ref6
                  : null === (_defaultOptions$local3 = defaultOptions.locale) ||
                    void 0 === _defaultOptions$local3 ||
                    null ===
                      (_defaultOptions$local4 =
                        _defaultOptions$local3.options) ||
                    void 0 === _defaultOptions$local4
                  ? void 0
                  : _defaultOptions$local4.weekStartsOn) && void 0 !== _ref5
              ? _ref5
              : 0
          );
          if (!(weekStartsOn >= 0 && weekStartsOn <= 6))
            throw new RangeError(
              'weekStartsOn must be between 0 and 6 inclusively'
            );
          if ('' === formatString)
            return '' === dateString
              ? toDate(dirtyReferenceDate)
              : new Date(NaN);
          var _step,
            subFnOptions = { firstWeekContainsDate, weekStartsOn, locale },
            setters = [new DateToSystemTimezoneSetter()],
            tokens = formatString
              .match(longFormattingTokensRegExp)
              .map(function (substring) {
                var firstCharacter = substring[0];
                return firstCharacter in format_longFormatters
                  ? (0, format_longFormatters[firstCharacter])(
                      substring,
                      locale.formatLong
                    )
                  : substring;
              })
              .join('')
              .match(formattingTokensRegExp),
            usedTokens = [],
            _iterator = _createForOfIteratorHelper(tokens);
          try {
            var _loop = function _loop() {
              var token = _step.value;
              (null != options && options.useAdditionalWeekYearTokens) ||
                !isProtectedWeekYearToken(token) ||
                throwProtectedError(token, formatString, dirtyDateString),
                (null != options && options.useAdditionalDayOfYearTokens) ||
                  !isProtectedDayOfYearToken(token) ||
                  throwProtectedError(token, formatString, dirtyDateString);
              var firstCharacter = token[0],
                parser = parsers[firstCharacter];
              if (parser) {
                var incompatibleTokens = parser.incompatibleTokens;
                if (Array.isArray(incompatibleTokens)) {
                  var incompatibleToken = usedTokens.find(function (usedToken) {
                    return (
                      incompatibleTokens.includes(usedToken.token) ||
                      usedToken.token === firstCharacter
                    );
                  });
                  if (incompatibleToken)
                    throw new RangeError(
                      "The format string mustn't contain `"
                        .concat(incompatibleToken.fullToken, '` and `')
                        .concat(token, '` at the same time')
                    );
                } else if (
                  '*' === parser.incompatibleTokens &&
                  usedTokens.length > 0
                )
                  throw new RangeError(
                    "The format string mustn't contain `".concat(
                      token,
                      '` and any other token at the same time'
                    )
                  );
                usedTokens.push({ token: firstCharacter, fullToken: token });
                var parseResult = parser.run(
                  dateString,
                  token,
                  locale.match,
                  subFnOptions
                );
                if (!parseResult) return { v: new Date(NaN) };
                setters.push(parseResult.setter),
                  (dateString = parseResult.rest);
              } else {
                if (firstCharacter.match(unescapedLatinCharacterRegExp))
                  throw new RangeError(
                    'Format string contains an unescaped latin alphabet character `' +
                      firstCharacter +
                      '`'
                  );
                if (
                  ("''" === token
                    ? (token = "'")
                    : "'" === firstCharacter &&
                      (token = (function cleanEscapedString(input) {
                        return input
                          .match(escapedStringRegExp)[1]
                          .replace(doubleQuoteRegExp, "'");
                      })(token)),
                  0 !== dateString.indexOf(token))
                )
                  return { v: new Date(NaN) };
                dateString = dateString.slice(token.length);
              }
            };
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var _ret = _loop();
              if ('object' === parse_typeof(_ret)) return _ret.v;
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          if (dateString.length > 0 && notWhitespaceRegExp.test(dateString))
            return new Date(NaN);
          var uniquePrioritySetters = setters
              .map(function (setter) {
                return setter.priority;
              })
              .sort(function (a, b) {
                return b - a;
              })
              .filter(function (priority, index, array) {
                return array.indexOf(priority) === index;
              })
              .map(function (priority) {
                return setters
                  .filter(function (setter) {
                    return setter.priority === priority;
                  })
                  .sort(function (a, b) {
                    return b.subPriority - a.subPriority;
                  });
              })
              .map(function (setterArray) {
                return setterArray[0];
              }),
            date = toDate(dirtyReferenceDate);
          if (isNaN(date.getTime())) return new Date(NaN);
          var _step2,
            utcDate = subMilliseconds(
              date,
              getTimezoneOffsetInMilliseconds(date)
            ),
            flags = {},
            _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters);
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var setter = _step2.value;
              if (!setter.validate(utcDate, subFnOptions)) return new Date(NaN);
              var result = setter.set(utcDate, flags, subFnOptions);
              Array.isArray(result)
                ? ((utcDate = result[0]), assign_assign(flags, result[1]))
                : (utcDate = result);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          return utcDate;
        }
        function parseISO(argument, options) {
          var _options$additionalDi;
          requiredArgs(1, arguments);
          var additionalDigits = toInteger(
            null !==
              (_options$additionalDi =
                null == options ? void 0 : options.additionalDigits) &&
              void 0 !== _options$additionalDi
              ? _options$additionalDi
              : 2
          );
          if (
            2 !== additionalDigits &&
            1 !== additionalDigits &&
            0 !== additionalDigits
          )
            throw new RangeError('additionalDigits must be 0, 1 or 2');
          if (
            'string' != typeof argument &&
            '[object String]' !== Object.prototype.toString.call(argument)
          )
            return new Date(NaN);
          var date,
            dateStrings = (function splitDateString(dateString) {
              var timeString,
                dateStrings = {},
                array = dateString.split(patterns.dateTimeDelimiter);
              if (array.length > 2) return dateStrings;
              /:/.test(array[0])
                ? (timeString = array[0])
                : ((dateStrings.date = array[0]),
                  (timeString = array[1]),
                  patterns.timeZoneDelimiter.test(dateStrings.date) &&
                    ((dateStrings.date = dateString.split(
                      patterns.timeZoneDelimiter
                    )[0]),
                    (timeString = dateString.substr(
                      dateStrings.date.length,
                      dateString.length
                    ))));
              if (timeString) {
                var token = patterns.timezone.exec(timeString);
                token
                  ? ((dateStrings.time = timeString.replace(token[1], '')),
                    (dateStrings.timezone = token[1]))
                  : (dateStrings.time = timeString);
              }
              return dateStrings;
            })(argument);
          if (dateStrings.date) {
            var parseYearResult = (function parseYear(
              dateString,
              additionalDigits
            ) {
              var regex = new RegExp(
                  '^(?:(\\d{4}|[+-]\\d{' +
                    (4 + additionalDigits) +
                    '})|(\\d{2}|[+-]\\d{' +
                    (2 + additionalDigits) +
                    '})$)'
                ),
                captures = dateString.match(regex);
              if (!captures) return { year: NaN, restDateString: '' };
              var year = captures[1] ? parseInt(captures[1]) : null,
                century = captures[2] ? parseInt(captures[2]) : null;
              return {
                year: null === century ? year : 100 * century,
                restDateString: dateString.slice(
                  (captures[1] || captures[2]).length
                ),
              };
            })(dateStrings.date, additionalDigits);
            date = (function parseDate(dateString, year) {
              if (null === year) return new Date(NaN);
              var captures = dateString.match(dateRegex);
              if (!captures) return new Date(NaN);
              var isWeekDate = !!captures[4],
                dayOfYear = parseDateUnit(captures[1]),
                month = parseDateUnit(captures[2]) - 1,
                day = parseDateUnit(captures[3]),
                week = parseDateUnit(captures[4]),
                dayOfWeek = parseDateUnit(captures[5]) - 1;
              if (isWeekDate)
                return (function validateWeekDate(_year, week, day) {
                  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
                })(0, week, dayOfWeek)
                  ? (function dayOfISOWeekYear(isoWeekYear, week, day) {
                      var date = new Date(0);
                      date.setUTCFullYear(isoWeekYear, 0, 4);
                      var fourthOfJanuaryDay = date.getUTCDay() || 7,
                        diff = 7 * (week - 1) + day + 1 - fourthOfJanuaryDay;
                      return date.setUTCDate(date.getUTCDate() + diff), date;
                    })(year, week, dayOfWeek)
                  : new Date(NaN);
              var date = new Date(0);
              return (function validateDate(year, month, date) {
                return (
                  month >= 0 &&
                  month <= 11 &&
                  date >= 1 &&
                  date <=
                    (daysInMonths[month] ||
                      (parseISO_isLeapYearIndex(year) ? 29 : 28))
                );
              })(year, month, day) &&
                (function validateDayOfYearDate(year, dayOfYear) {
                  return (
                    dayOfYear >= 1 &&
                    dayOfYear <= (parseISO_isLeapYearIndex(year) ? 366 : 365)
                  );
                })(year, dayOfYear)
                ? (date.setUTCFullYear(year, month, Math.max(dayOfYear, day)),
                  date)
                : new Date(NaN);
            })(parseYearResult.restDateString, parseYearResult.year);
          }
          if (!date || isNaN(date.getTime())) return new Date(NaN);
          var offset,
            timestamp = date.getTime(),
            time = 0;
          if (
            dateStrings.time &&
            ((time = (function parseTime(timeString) {
              var captures = timeString.match(timeRegex);
              if (!captures) return NaN;
              var hours = parseTimeUnit(captures[1]),
                minutes = parseTimeUnit(captures[2]),
                seconds = parseTimeUnit(captures[3]);
              if (
                !(function validateTime(hours, minutes, seconds) {
                  if (24 === hours) return 0 === minutes && 0 === seconds;
                  return (
                    seconds >= 0 &&
                    seconds < 60 &&
                    minutes >= 0 &&
                    minutes < 60 &&
                    hours >= 0 &&
                    hours < 25
                  );
                })(hours, minutes, seconds)
              )
                return NaN;
              return (
                hours * millisecondsInHour +
                minutes * millisecondsInMinute +
                1e3 * seconds
              );
            })(dateStrings.time)),
            isNaN(time))
          )
            return new Date(NaN);
          if (!dateStrings.timezone) {
            var dirtyDate = new Date(timestamp + time),
              result = new Date(0);
            return (
              result.setFullYear(
                dirtyDate.getUTCFullYear(),
                dirtyDate.getUTCMonth(),
                dirtyDate.getUTCDate()
              ),
              result.setHours(
                dirtyDate.getUTCHours(),
                dirtyDate.getUTCMinutes(),
                dirtyDate.getUTCSeconds(),
                dirtyDate.getUTCMilliseconds()
              ),
              result
            );
          }
          return (
            (offset = (function parseTimezone(timezoneString) {
              if ('Z' === timezoneString) return 0;
              var captures = timezoneString.match(timezoneRegex);
              if (!captures) return 0;
              var sign = '+' === captures[1] ? -1 : 1,
                hours = parseInt(captures[2]),
                minutes = (captures[3] && parseInt(captures[3])) || 0;
              if (
                !(function validateTimezone(_hours, minutes) {
                  return minutes >= 0 && minutes <= 59;
                })(0, minutes)
              )
                return NaN;
              return (
                sign *
                (hours * millisecondsInHour + minutes * millisecondsInMinute)
              );
            })(dateStrings.timezone)),
            isNaN(offset) ? new Date(NaN) : new Date(timestamp + time + offset)
          );
        }
        var patterns = {
            dateTimeDelimiter: /[T ]/,
            timeZoneDelimiter: /[Z ]/i,
            timezone: /([Z+-].*)$/,
          },
          dateRegex =
            /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/,
          timeRegex =
            /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/,
          timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
        function parseDateUnit(value) {
          return value ? parseInt(value) : 1;
        }
        function parseTimeUnit(value) {
          return (value && parseFloat(value.replace(',', '.'))) || 0;
        }
        var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        function parseISO_isLeapYearIndex(year) {
          return year % 400 == 0 || (year % 4 == 0 && year % 100 != 0);
        }
        function isDate_typeof(obj) {
          return (
            (isDate_typeof =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function _typeof(obj) {
                    return typeof obj;
                  }
                : function _typeof(obj) {
                    return obj &&
                      'function' == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? 'symbol'
                      : typeof obj;
                  }),
            isDate_typeof(obj)
          );
        }
        function isValid(dirtyDate) {
          if (
            (requiredArgs(1, arguments),
            !(function isDate(value) {
              return (
                requiredArgs(1, arguments),
                value instanceof Date ||
                  ('object' === isDate_typeof(value) &&
                    '[object Date]' === Object.prototype.toString.call(value))
              );
            })(dirtyDate) && 'number' != typeof dirtyDate)
          )
            return !1;
          var date = toDate(dirtyDate);
          return !isNaN(Number(date));
        }
        var MILLISECONDS_IN_DAY = 864e5;
        function addLeadingZeros(number, targetLength) {
          for (
            var sign = number < 0 ? '-' : '',
              output = Math.abs(number).toString();
            output.length < targetLength;

          )
            output = '0' + output;
          return sign + output;
        }
        const lightFormatters = {
          y: function y(date, token) {
            var signedYear = date.getUTCFullYear(),
              year = signedYear > 0 ? signedYear : 1 - signedYear;
            return addLeadingZeros(
              'yy' === token ? year % 100 : year,
              token.length
            );
          },
          M: function M(date, token) {
            var month = date.getUTCMonth();
            return 'M' === token
              ? String(month + 1)
              : addLeadingZeros(month + 1, 2);
          },
          d: function d(date, token) {
            return addLeadingZeros(date.getUTCDate(), token.length);
          },
          a: function a(date, token) {
            var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';
            switch (token) {
              case 'a':
              case 'aa':
                return dayPeriodEnumValue.toUpperCase();
              case 'aaa':
                return dayPeriodEnumValue;
              case 'aaaaa':
                return dayPeriodEnumValue[0];
              default:
                return 'am' === dayPeriodEnumValue ? 'a.m.' : 'p.m.';
            }
          },
          h: function h(date, token) {
            return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
          },
          H: function H(date, token) {
            return addLeadingZeros(date.getUTCHours(), token.length);
          },
          m: function m(date, token) {
            return addLeadingZeros(date.getUTCMinutes(), token.length);
          },
          s: function s(date, token) {
            return addLeadingZeros(date.getUTCSeconds(), token.length);
          },
          S: function S(date, token) {
            var numberOfDigits = token.length,
              milliseconds = date.getUTCMilliseconds();
            return addLeadingZeros(
              Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3)),
              token.length
            );
          },
        };
        var dayPeriodEnum_midnight = 'midnight',
          dayPeriodEnum_noon = 'noon',
          dayPeriodEnum_morning = 'morning',
          dayPeriodEnum_afternoon = 'afternoon',
          dayPeriodEnum_evening = 'evening',
          dayPeriodEnum_night = 'night',
          formatters_formatters = {
            G: function G(date, token, localize) {
              var era = date.getUTCFullYear() > 0 ? 1 : 0;
              switch (token) {
                case 'G':
                case 'GG':
                case 'GGG':
                  return localize.era(era, { width: 'abbreviated' });
                case 'GGGGG':
                  return localize.era(era, { width: 'narrow' });
                default:
                  return localize.era(era, { width: 'wide' });
              }
            },
            y: function y(date, token, localize) {
              if ('yo' === token) {
                var signedYear = date.getUTCFullYear(),
                  year = signedYear > 0 ? signedYear : 1 - signedYear;
                return localize.ordinalNumber(year, { unit: 'year' });
              }
              return lightFormatters.y(date, token);
            },
            Y: function Y(date, token, localize, options) {
              var signedWeekYear = getUTCWeekYear(date, options),
                weekYear =
                  signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
              return 'YY' === token
                ? addLeadingZeros(weekYear % 100, 2)
                : 'Yo' === token
                ? localize.ordinalNumber(weekYear, { unit: 'year' })
                : addLeadingZeros(weekYear, token.length);
            },
            R: function R(date, token) {
              return addLeadingZeros(getUTCISOWeekYear(date), token.length);
            },
            u: function u(date, token) {
              return addLeadingZeros(date.getUTCFullYear(), token.length);
            },
            Q: function Q(date, token, localize) {
              var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
              switch (token) {
                case 'Q':
                  return String(quarter);
                case 'QQ':
                  return addLeadingZeros(quarter, 2);
                case 'Qo':
                  return localize.ordinalNumber(quarter, { unit: 'quarter' });
                case 'QQQ':
                  return localize.quarter(quarter, {
                    width: 'abbreviated',
                    context: 'formatting',
                  });
                case 'QQQQQ':
                  return localize.quarter(quarter, {
                    width: 'narrow',
                    context: 'formatting',
                  });
                default:
                  return localize.quarter(quarter, {
                    width: 'wide',
                    context: 'formatting',
                  });
              }
            },
            q: function q(date, token, localize) {
              var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
              switch (token) {
                case 'q':
                  return String(quarter);
                case 'qq':
                  return addLeadingZeros(quarter, 2);
                case 'qo':
                  return localize.ordinalNumber(quarter, { unit: 'quarter' });
                case 'qqq':
                  return localize.quarter(quarter, {
                    width: 'abbreviated',
                    context: 'standalone',
                  });
                case 'qqqqq':
                  return localize.quarter(quarter, {
                    width: 'narrow',
                    context: 'standalone',
                  });
                default:
                  return localize.quarter(quarter, {
                    width: 'wide',
                    context: 'standalone',
                  });
              }
            },
            M: function M(date, token, localize) {
              var month = date.getUTCMonth();
              switch (token) {
                case 'M':
                case 'MM':
                  return lightFormatters.M(date, token);
                case 'Mo':
                  return localize.ordinalNumber(month + 1, { unit: 'month' });
                case 'MMM':
                  return localize.month(month, {
                    width: 'abbreviated',
                    context: 'formatting',
                  });
                case 'MMMMM':
                  return localize.month(month, {
                    width: 'narrow',
                    context: 'formatting',
                  });
                default:
                  return localize.month(month, {
                    width: 'wide',
                    context: 'formatting',
                  });
              }
            },
            L: function L(date, token, localize) {
              var month = date.getUTCMonth();
              switch (token) {
                case 'L':
                  return String(month + 1);
                case 'LL':
                  return addLeadingZeros(month + 1, 2);
                case 'Lo':
                  return localize.ordinalNumber(month + 1, { unit: 'month' });
                case 'LLL':
                  return localize.month(month, {
                    width: 'abbreviated',
                    context: 'standalone',
                  });
                case 'LLLLL':
                  return localize.month(month, {
                    width: 'narrow',
                    context: 'standalone',
                  });
                default:
                  return localize.month(month, {
                    width: 'wide',
                    context: 'standalone',
                  });
              }
            },
            w: function w(date, token, localize, options) {
              var week = getUTCWeek(date, options);
              return 'wo' === token
                ? localize.ordinalNumber(week, { unit: 'week' })
                : addLeadingZeros(week, token.length);
            },
            I: function I(date, token, localize) {
              var isoWeek = getUTCISOWeek(date);
              return 'Io' === token
                ? localize.ordinalNumber(isoWeek, { unit: 'week' })
                : addLeadingZeros(isoWeek, token.length);
            },
            d: function d(date, token, localize) {
              return 'do' === token
                ? localize.ordinalNumber(date.getUTCDate(), { unit: 'date' })
                : lightFormatters.d(date, token);
            },
            D: function D(date, token, localize) {
              var dayOfYear = (function getUTCDayOfYear(dirtyDate) {
                requiredArgs(1, arguments);
                var date = toDate(dirtyDate),
                  timestamp = date.getTime();
                date.setUTCMonth(0, 1), date.setUTCHours(0, 0, 0, 0);
                var difference = timestamp - date.getTime();
                return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
              })(date);
              return 'Do' === token
                ? localize.ordinalNumber(dayOfYear, { unit: 'dayOfYear' })
                : addLeadingZeros(dayOfYear, token.length);
            },
            E: function E(date, token, localize) {
              var dayOfWeek = date.getUTCDay();
              switch (token) {
                case 'E':
                case 'EE':
                case 'EEE':
                  return localize.day(dayOfWeek, {
                    width: 'abbreviated',
                    context: 'formatting',
                  });
                case 'EEEEE':
                  return localize.day(dayOfWeek, {
                    width: 'narrow',
                    context: 'formatting',
                  });
                case 'EEEEEE':
                  return localize.day(dayOfWeek, {
                    width: 'short',
                    context: 'formatting',
                  });
                default:
                  return localize.day(dayOfWeek, {
                    width: 'wide',
                    context: 'formatting',
                  });
              }
            },
            e: function e(date, token, localize, options) {
              var dayOfWeek = date.getUTCDay(),
                localDayOfWeek =
                  (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
              switch (token) {
                case 'e':
                  return String(localDayOfWeek);
                case 'ee':
                  return addLeadingZeros(localDayOfWeek, 2);
                case 'eo':
                  return localize.ordinalNumber(localDayOfWeek, {
                    unit: 'day',
                  });
                case 'eee':
                  return localize.day(dayOfWeek, {
                    width: 'abbreviated',
                    context: 'formatting',
                  });
                case 'eeeee':
                  return localize.day(dayOfWeek, {
                    width: 'narrow',
                    context: 'formatting',
                  });
                case 'eeeeee':
                  return localize.day(dayOfWeek, {
                    width: 'short',
                    context: 'formatting',
                  });
                default:
                  return localize.day(dayOfWeek, {
                    width: 'wide',
                    context: 'formatting',
                  });
              }
            },
            c: function c(date, token, localize, options) {
              var dayOfWeek = date.getUTCDay(),
                localDayOfWeek =
                  (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
              switch (token) {
                case 'c':
                  return String(localDayOfWeek);
                case 'cc':
                  return addLeadingZeros(localDayOfWeek, token.length);
                case 'co':
                  return localize.ordinalNumber(localDayOfWeek, {
                    unit: 'day',
                  });
                case 'ccc':
                  return localize.day(dayOfWeek, {
                    width: 'abbreviated',
                    context: 'standalone',
                  });
                case 'ccccc':
                  return localize.day(dayOfWeek, {
                    width: 'narrow',
                    context: 'standalone',
                  });
                case 'cccccc':
                  return localize.day(dayOfWeek, {
                    width: 'short',
                    context: 'standalone',
                  });
                default:
                  return localize.day(dayOfWeek, {
                    width: 'wide',
                    context: 'standalone',
                  });
              }
            },
            i: function i(date, token, localize) {
              var dayOfWeek = date.getUTCDay(),
                isoDayOfWeek = 0 === dayOfWeek ? 7 : dayOfWeek;
              switch (token) {
                case 'i':
                  return String(isoDayOfWeek);
                case 'ii':
                  return addLeadingZeros(isoDayOfWeek, token.length);
                case 'io':
                  return localize.ordinalNumber(isoDayOfWeek, { unit: 'day' });
                case 'iii':
                  return localize.day(dayOfWeek, {
                    width: 'abbreviated',
                    context: 'formatting',
                  });
                case 'iiiii':
                  return localize.day(dayOfWeek, {
                    width: 'narrow',
                    context: 'formatting',
                  });
                case 'iiiiii':
                  return localize.day(dayOfWeek, {
                    width: 'short',
                    context: 'formatting',
                  });
                default:
                  return localize.day(dayOfWeek, {
                    width: 'wide',
                    context: 'formatting',
                  });
              }
            },
            a: function a(date, token, localize) {
              var dayPeriodEnumValue =
                date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';
              switch (token) {
                case 'a':
                case 'aa':
                  return localize.dayPeriod(dayPeriodEnumValue, {
                    width: 'abbreviated',
                    context: 'formatting',
                  });
                case 'aaa':
                  return localize
                    .dayPeriod(dayPeriodEnumValue, {
                      width: 'abbreviated',
                      context: 'formatting',
                    })
                    .toLowerCase();
                case 'aaaaa':
                  return localize.dayPeriod(dayPeriodEnumValue, {
                    width: 'narrow',
                    context: 'formatting',
                  });
                default:
                  return localize.dayPeriod(dayPeriodEnumValue, {
                    width: 'wide',
                    context: 'formatting',
                  });
              }
            },
            b: function b(date, token, localize) {
              var dayPeriodEnumValue,
                hours = date.getUTCHours();
              switch (
                ((dayPeriodEnumValue =
                  12 === hours
                    ? dayPeriodEnum_noon
                    : 0 === hours
                    ? dayPeriodEnum_midnight
                    : hours / 12 >= 1
                    ? 'pm'
                    : 'am'),
                token)
              ) {
                case 'b':
                case 'bb':
                  return localize.dayPeriod(dayPeriodEnumValue, {
                    width: 'abbreviated',
                    context: 'formatting',
                  });
                case 'bbb':
                  return localize
                    .dayPeriod(dayPeriodEnumValue, {
                      width: 'abbreviated',
                      context: 'formatting',
                    })
                    .toLowerCase();
                case 'bbbbb':
                  return localize.dayPeriod(dayPeriodEnumValue, {
                    width: 'narrow',
                    context: 'formatting',
                  });
                default:
                  return localize.dayPeriod(dayPeriodEnumValue, {
                    width: 'wide',
                    context: 'formatting',
                  });
              }
            },
            B: function B(date, token, localize) {
              var dayPeriodEnumValue,
                hours = date.getUTCHours();
              switch (
                ((dayPeriodEnumValue =
                  hours >= 17
                    ? dayPeriodEnum_evening
                    : hours >= 12
                    ? dayPeriodEnum_afternoon
                    : hours >= 4
                    ? dayPeriodEnum_morning
                    : dayPeriodEnum_night),
                token)
              ) {
                case 'B':
                case 'BB':
                case 'BBB':
                  return localize.dayPeriod(dayPeriodEnumValue, {
                    width: 'abbreviated',
                    context: 'formatting',
                  });
                case 'BBBBB':
                  return localize.dayPeriod(dayPeriodEnumValue, {
                    width: 'narrow',
                    context: 'formatting',
                  });
                default:
                  return localize.dayPeriod(dayPeriodEnumValue, {
                    width: 'wide',
                    context: 'formatting',
                  });
              }
            },
            h: function h(date, token, localize) {
              if ('ho' === token) {
                var hours = date.getUTCHours() % 12;
                return (
                  0 === hours && (hours = 12),
                  localize.ordinalNumber(hours, { unit: 'hour' })
                );
              }
              return lightFormatters.h(date, token);
            },
            H: function H(date, token, localize) {
              return 'Ho' === token
                ? localize.ordinalNumber(date.getUTCHours(), { unit: 'hour' })
                : lightFormatters.H(date, token);
            },
            K: function K(date, token, localize) {
              var hours = date.getUTCHours() % 12;
              return 'Ko' === token
                ? localize.ordinalNumber(hours, { unit: 'hour' })
                : addLeadingZeros(hours, token.length);
            },
            k: function k(date, token, localize) {
              var hours = date.getUTCHours();
              return (
                0 === hours && (hours = 24),
                'ko' === token
                  ? localize.ordinalNumber(hours, { unit: 'hour' })
                  : addLeadingZeros(hours, token.length)
              );
            },
            m: function m(date, token, localize) {
              return 'mo' === token
                ? localize.ordinalNumber(date.getUTCMinutes(), {
                    unit: 'minute',
                  })
                : lightFormatters.m(date, token);
            },
            s: function s(date, token, localize) {
              return 'so' === token
                ? localize.ordinalNumber(date.getUTCSeconds(), {
                    unit: 'second',
                  })
                : lightFormatters.s(date, token);
            },
            S: function S(date, token) {
              return lightFormatters.S(date, token);
            },
            X: function X(date, token, _localize, options) {
              var timezoneOffset = (
                options._originalDate || date
              ).getTimezoneOffset();
              if (0 === timezoneOffset) return 'Z';
              switch (token) {
                case 'X':
                  return formatTimezoneWithOptionalMinutes(timezoneOffset);
                case 'XXXX':
                case 'XX':
                  return formatTimezone(timezoneOffset);
                default:
                  return formatTimezone(timezoneOffset, ':');
              }
            },
            x: function x(date, token, _localize, options) {
              var timezoneOffset = (
                options._originalDate || date
              ).getTimezoneOffset();
              switch (token) {
                case 'x':
                  return formatTimezoneWithOptionalMinutes(timezoneOffset);
                case 'xxxx':
                case 'xx':
                  return formatTimezone(timezoneOffset);
                default:
                  return formatTimezone(timezoneOffset, ':');
              }
            },
            O: function O(date, token, _localize, options) {
              var timezoneOffset = (
                options._originalDate || date
              ).getTimezoneOffset();
              switch (token) {
                case 'O':
                case 'OO':
                case 'OOO':
                  return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
                default:
                  return 'GMT' + formatTimezone(timezoneOffset, ':');
              }
            },
            z: function z(date, token, _localize, options) {
              var timezoneOffset = (
                options._originalDate || date
              ).getTimezoneOffset();
              switch (token) {
                case 'z':
                case 'zz':
                case 'zzz':
                  return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
                default:
                  return 'GMT' + formatTimezone(timezoneOffset, ':');
              }
            },
            t: function t(date, token, _localize, options) {
              var originalDate = options._originalDate || date;
              return addLeadingZeros(
                Math.floor(originalDate.getTime() / 1e3),
                token.length
              );
            },
            T: function T(date, token, _localize, options) {
              return addLeadingZeros(
                (options._originalDate || date).getTime(),
                token.length
              );
            },
          };
        function formatTimezoneShort(offset, dirtyDelimiter) {
          var sign = offset > 0 ? '-' : '+',
            absOffset = Math.abs(offset),
            hours = Math.floor(absOffset / 60),
            minutes = absOffset % 60;
          if (0 === minutes) return sign + String(hours);
          var delimiter = dirtyDelimiter || '';
          return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
        }
        function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
          return offset % 60 == 0
            ? (offset > 0 ? '-' : '+') +
                addLeadingZeros(Math.abs(offset) / 60, 2)
            : formatTimezone(offset, dirtyDelimiter);
        }
        function formatTimezone(offset, dirtyDelimiter) {
          var delimiter = dirtyDelimiter || '',
            sign = offset > 0 ? '-' : '+',
            absOffset = Math.abs(offset);
          return (
            sign +
            addLeadingZeros(Math.floor(absOffset / 60), 2) +
            delimiter +
            addLeadingZeros(absOffset % 60, 2)
          );
        }
        const format_formatters = formatters_formatters;
        var format_formattingTokensRegExp =
            /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g,
          format_longFormattingTokensRegExp =
            /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g,
          format_escapedStringRegExp = /^'([^]*?)'?$/,
          format_doubleQuoteRegExp = /''/g,
          format_unescapedLatinCharacterRegExp = /[a-zA-Z]/;
        function format(dirtyDate, dirtyFormatStr, options) {
          var _ref,
            _options$locale,
            _ref2,
            _ref3,
            _ref4,
            _options$firstWeekCon,
            _options$locale2,
            _options$locale2$opti,
            _defaultOptions$local,
            _defaultOptions$local2,
            _ref5,
            _ref6,
            _ref7,
            _options$weekStartsOn,
            _options$locale3,
            _options$locale3$opti,
            _defaultOptions$local3,
            _defaultOptions$local4;
          requiredArgs(2, arguments);
          var formatStr = String(dirtyFormatStr),
            defaultOptions = getDefaultOptions(),
            locale =
              null !==
                (_ref =
                  null !==
                    (_options$locale =
                      null == options ? void 0 : options.locale) &&
                  void 0 !== _options$locale
                    ? _options$locale
                    : defaultOptions.locale) && void 0 !== _ref
                ? _ref
                : defaultLocale,
            firstWeekContainsDate = toInteger(
              null !==
                (_ref2 =
                  null !==
                    (_ref3 =
                      null !==
                        (_ref4 =
                          null !==
                            (_options$firstWeekCon =
                              null == options
                                ? void 0
                                : options.firstWeekContainsDate) &&
                          void 0 !== _options$firstWeekCon
                            ? _options$firstWeekCon
                            : null == options ||
                              null === (_options$locale2 = options.locale) ||
                              void 0 === _options$locale2 ||
                              null ===
                                (_options$locale2$opti =
                                  _options$locale2.options) ||
                              void 0 === _options$locale2$opti
                            ? void 0
                            : _options$locale2$opti.firstWeekContainsDate) &&
                      void 0 !== _ref4
                        ? _ref4
                        : defaultOptions.firstWeekContainsDate) &&
                  void 0 !== _ref3
                    ? _ref3
                    : null ===
                        (_defaultOptions$local = defaultOptions.locale) ||
                      void 0 === _defaultOptions$local ||
                      null ===
                        (_defaultOptions$local2 =
                          _defaultOptions$local.options) ||
                      void 0 === _defaultOptions$local2
                    ? void 0
                    : _defaultOptions$local2.firstWeekContainsDate) &&
                void 0 !== _ref2
                ? _ref2
                : 1
            );
          if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7))
            throw new RangeError(
              'firstWeekContainsDate must be between 1 and 7 inclusively'
            );
          var weekStartsOn = toInteger(
            null !==
              (_ref5 =
                null !==
                  (_ref6 =
                    null !==
                      (_ref7 =
                        null !==
                          (_options$weekStartsOn =
                            null == options ? void 0 : options.weekStartsOn) &&
                        void 0 !== _options$weekStartsOn
                          ? _options$weekStartsOn
                          : null == options ||
                            null === (_options$locale3 = options.locale) ||
                            void 0 === _options$locale3 ||
                            null ===
                              (_options$locale3$opti =
                                _options$locale3.options) ||
                            void 0 === _options$locale3$opti
                          ? void 0
                          : _options$locale3$opti.weekStartsOn) &&
                    void 0 !== _ref7
                      ? _ref7
                      : defaultOptions.weekStartsOn) && void 0 !== _ref6
                  ? _ref6
                  : null === (_defaultOptions$local3 = defaultOptions.locale) ||
                    void 0 === _defaultOptions$local3 ||
                    null ===
                      (_defaultOptions$local4 =
                        _defaultOptions$local3.options) ||
                    void 0 === _defaultOptions$local4
                  ? void 0
                  : _defaultOptions$local4.weekStartsOn) && void 0 !== _ref5
              ? _ref5
              : 0
          );
          if (!(weekStartsOn >= 0 && weekStartsOn <= 6))
            throw new RangeError(
              'weekStartsOn must be between 0 and 6 inclusively'
            );
          if (!locale.localize)
            throw new RangeError('locale must contain localize property');
          if (!locale.formatLong)
            throw new RangeError('locale must contain formatLong property');
          var originalDate = toDate(dirtyDate);
          if (!isValid(originalDate))
            throw new RangeError('Invalid time value');
          var utcDate = subMilliseconds(
              originalDate,
              getTimezoneOffsetInMilliseconds(originalDate)
            ),
            formatterOptions = {
              firstWeekContainsDate,
              weekStartsOn,
              locale,
              _originalDate: originalDate,
            };
          return formatStr
            .match(format_longFormattingTokensRegExp)
            .map(function (substring) {
              var firstCharacter = substring[0];
              return 'p' === firstCharacter || 'P' === firstCharacter
                ? (0, format_longFormatters[firstCharacter])(
                    substring,
                    locale.formatLong
                  )
                : substring;
            })
            .join('')
            .match(format_formattingTokensRegExp)
            .map(function (substring) {
              if ("''" === substring) return "'";
              var firstCharacter = substring[0];
              if ("'" === firstCharacter)
                return (function format_cleanEscapedString(input) {
                  var matched = input.match(format_escapedStringRegExp);
                  if (!matched) return input;
                  return matched[1].replace(format_doubleQuoteRegExp, "'");
                })(substring);
              var formatter = format_formatters[firstCharacter];
              if (formatter)
                return (
                  (null != options && options.useAdditionalWeekYearTokens) ||
                    !isProtectedWeekYearToken(substring) ||
                    throwProtectedError(
                      substring,
                      dirtyFormatStr,
                      String(dirtyDate)
                    ),
                  (null != options && options.useAdditionalDayOfYearTokens) ||
                    !isProtectedDayOfYearToken(substring) ||
                    throwProtectedError(
                      substring,
                      dirtyFormatStr,
                      String(dirtyDate)
                    ),
                  formatter(
                    utcDate,
                    substring,
                    locale.localize,
                    formatterOptions
                  )
                );
              if (firstCharacter.match(format_unescapedLatinCharacterRegExp))
                throw new RangeError(
                  'Format string contains an unescaped latin alphabet character `' +
                    firstCharacter +
                    '`'
                );
              return substring;
            })
            .join('');
        }
        var MILLISECONDS_IN_MINUTE = 6e4;
        var MILLISECONDS_IN_HOUR = 36e5;
        function addDays(dirtyDate, dirtyAmount) {
          requiredArgs(2, arguments);
          var date = toDate(dirtyDate),
            amount = toInteger(dirtyAmount);
          return isNaN(amount)
            ? new Date(NaN)
            : amount
            ? (date.setDate(date.getDate() + amount), date)
            : date;
        }
        function addMonths(dirtyDate, dirtyAmount) {
          requiredArgs(2, arguments);
          var date = toDate(dirtyDate),
            amount = toInteger(dirtyAmount);
          if (isNaN(amount)) return new Date(NaN);
          if (!amount) return date;
          var dayOfMonth = date.getDate(),
            endOfDesiredMonth = new Date(date.getTime());
          return (
            endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0),
            dayOfMonth >= endOfDesiredMonth.getDate()
              ? endOfDesiredMonth
              : (date.setFullYear(
                  endOfDesiredMonth.getFullYear(),
                  endOfDesiredMonth.getMonth(),
                  dayOfMonth
                ),
                date)
          );
        }
        function differenceInMilliseconds(dateLeft, dateRight) {
          return (
            requiredArgs(2, arguments),
            toDate(dateLeft).getTime() - toDate(dateRight).getTime()
          );
        }
        var roundingMap = {
            ceil: Math.ceil,
            round: Math.round,
            floor: Math.floor,
            trunc: function trunc(value) {
              return value < 0 ? Math.ceil(value) : Math.floor(value);
            },
          },
          defaultRoundingMethod = 'trunc';
        function getRoundingMethod(method) {
          return method
            ? roundingMap[method]
            : roundingMap[defaultRoundingMethod];
        }
        function startOfDay(dirtyDate) {
          requiredArgs(1, arguments);
          var date = toDate(dirtyDate);
          return date.setHours(0, 0, 0, 0), date;
        }
        var differenceInCalendarDays_MILLISECONDS_IN_DAY = 864e5;
        function compareLocalAsc(dateLeft, dateRight) {
          var diff =
            dateLeft.getFullYear() - dateRight.getFullYear() ||
            dateLeft.getMonth() - dateRight.getMonth() ||
            dateLeft.getDate() - dateRight.getDate() ||
            dateLeft.getHours() - dateRight.getHours() ||
            dateLeft.getMinutes() - dateRight.getMinutes() ||
            dateLeft.getSeconds() - dateRight.getSeconds() ||
            dateLeft.getMilliseconds() - dateRight.getMilliseconds();
          return diff < 0 ? -1 : diff > 0 ? 1 : diff;
        }
        function differenceInDays(dirtyDateLeft, dirtyDateRight) {
          requiredArgs(2, arguments);
          var dateLeft = toDate(dirtyDateLeft),
            dateRight = toDate(dirtyDateRight),
            sign = compareLocalAsc(dateLeft, dateRight),
            difference = Math.abs(
              (function differenceInCalendarDays(
                dirtyDateLeft,
                dirtyDateRight
              ) {
                requiredArgs(2, arguments);
                var startOfDayLeft = startOfDay(dirtyDateLeft),
                  startOfDayRight = startOfDay(dirtyDateRight),
                  timestampLeft =
                    startOfDayLeft.getTime() -
                    getTimezoneOffsetInMilliseconds(startOfDayLeft),
                  timestampRight =
                    startOfDayRight.getTime() -
                    getTimezoneOffsetInMilliseconds(startOfDayRight);
                return Math.round(
                  (timestampLeft - timestampRight) /
                    differenceInCalendarDays_MILLISECONDS_IN_DAY
                );
              })(dateLeft, dateRight)
            );
          dateLeft.setDate(dateLeft.getDate() - sign * difference);
          var result =
            sign *
            (difference -
              Number(compareLocalAsc(dateLeft, dateRight) === -sign));
          return 0 === result ? 0 : result;
        }
        function compareAsc(dirtyDateLeft, dirtyDateRight) {
          requiredArgs(2, arguments);
          var dateLeft = toDate(dirtyDateLeft),
            dateRight = toDate(dirtyDateRight),
            diff = dateLeft.getTime() - dateRight.getTime();
          return diff < 0 ? -1 : diff > 0 ? 1 : diff;
        }
        function endOfDay(dirtyDate) {
          requiredArgs(1, arguments);
          var date = toDate(dirtyDate);
          return date.setHours(23, 59, 59, 999), date;
        }
        function endOfMonth(dirtyDate) {
          requiredArgs(1, arguments);
          var date = toDate(dirtyDate),
            month = date.getMonth();
          return (
            date.setFullYear(date.getFullYear(), month + 1, 0),
            date.setHours(23, 59, 59, 999),
            date
          );
        }
        function differenceInMonths(dirtyDateLeft, dirtyDateRight) {
          requiredArgs(2, arguments);
          var result,
            dateLeft = toDate(dirtyDateLeft),
            dateRight = toDate(dirtyDateRight),
            sign = compareAsc(dateLeft, dateRight),
            difference = Math.abs(
              (function differenceInCalendarMonths(
                dirtyDateLeft,
                dirtyDateRight
              ) {
                requiredArgs(2, arguments);
                var dateLeft = toDate(dirtyDateLeft),
                  dateRight = toDate(dirtyDateRight);
                return (
                  12 * (dateLeft.getFullYear() - dateRight.getFullYear()) +
                  (dateLeft.getMonth() - dateRight.getMonth())
                );
              })(dateLeft, dateRight)
            );
          if (difference < 1) result = 0;
          else {
            1 === dateLeft.getMonth() &&
              dateLeft.getDate() > 27 &&
              dateLeft.setDate(30),
              dateLeft.setMonth(dateLeft.getMonth() - sign * difference);
            var isLastMonthNotFull = compareAsc(dateLeft, dateRight) === -sign;
            (function isLastDayOfMonth(dirtyDate) {
              requiredArgs(1, arguments);
              var date = toDate(dirtyDate);
              return endOfDay(date).getTime() === endOfMonth(date).getTime();
            })(toDate(dirtyDateLeft)) &&
              1 === difference &&
              1 === compareAsc(dirtyDateLeft, dateRight) &&
              (isLastMonthNotFull = !1),
              (result = sign * (difference - Number(isLastMonthNotFull)));
          }
          return 0 === result ? 0 : result;
        }
        function differenceInYears(dirtyDateLeft, dirtyDateRight) {
          requiredArgs(2, arguments);
          var dateLeft = toDate(dirtyDateLeft),
            dateRight = toDate(dirtyDateRight),
            sign = compareAsc(dateLeft, dateRight),
            difference = Math.abs(
              (function differenceInCalendarYears(
                dirtyDateLeft,
                dirtyDateRight
              ) {
                requiredArgs(2, arguments);
                var dateLeft = toDate(dirtyDateLeft),
                  dateRight = toDate(dirtyDateRight);
                return dateLeft.getFullYear() - dateRight.getFullYear();
              })(dateLeft, dateRight)
            );
          dateLeft.setFullYear(1584), dateRight.setFullYear(1584);
          var isLastYearNotFull = compareAsc(dateLeft, dateRight) === -sign,
            result = sign * (difference - Number(isLastYearNotFull));
          return 0 === result ? 0 : result;
        }
        function startOfWeek(dirtyDate, options) {
          var _ref,
            _ref2,
            _ref3,
            _options$weekStartsOn,
            _options$locale,
            _options$locale$optio,
            _defaultOptions$local,
            _defaultOptions$local2;
          requiredArgs(1, arguments);
          var defaultOptions = getDefaultOptions(),
            weekStartsOn = toInteger(
              null !==
                (_ref =
                  null !==
                    (_ref2 =
                      null !==
                        (_ref3 =
                          null !==
                            (_options$weekStartsOn =
                              null == options
                                ? void 0
                                : options.weekStartsOn) &&
                          void 0 !== _options$weekStartsOn
                            ? _options$weekStartsOn
                            : null == options ||
                              null === (_options$locale = options.locale) ||
                              void 0 === _options$locale ||
                              null ===
                                (_options$locale$optio =
                                  _options$locale.options) ||
                              void 0 === _options$locale$optio
                            ? void 0
                            : _options$locale$optio.weekStartsOn) &&
                      void 0 !== _ref3
                        ? _ref3
                        : defaultOptions.weekStartsOn) && void 0 !== _ref2
                    ? _ref2
                    : null ===
                        (_defaultOptions$local = defaultOptions.locale) ||
                      void 0 === _defaultOptions$local ||
                      null ===
                        (_defaultOptions$local2 =
                          _defaultOptions$local.options) ||
                      void 0 === _defaultOptions$local2
                    ? void 0
                    : _defaultOptions$local2.weekStartsOn) && void 0 !== _ref
                ? _ref
                : 0
            );
          if (!(weekStartsOn >= 0 && weekStartsOn <= 6))
            throw new RangeError(
              'weekStartsOn must be between 0 and 6 inclusively'
            );
          var date = toDate(dirtyDate),
            day = date.getDay(),
            diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
          return (
            date.setDate(date.getDate() - diff), date.setHours(0, 0, 0, 0), date
          );
        }
        const FORMATS = {
          datetime: 'MMM d, yyyy, h:mm:ss aaaa',
          millisecond: 'h:mm:ss.SSS aaaa',
          second: 'h:mm:ss aaaa',
          minute: 'h:mm aaaa',
          hour: 'ha',
          day: 'MMM d',
          week: 'PP',
          month: 'MMM yyyy',
          quarter: 'qqq - yyyy',
          year: 'yyyy',
        };
        chart.IQ._date.override({
          _id: 'date-fns',
          formats: function () {
            return FORMATS;
          },
          parse: function (value, fmt) {
            if (null == value) return null;
            const type = typeof value;
            return (
              'number' === type || value instanceof Date
                ? (value = toDate(value))
                : 'string' === type &&
                  (value =
                    'string' == typeof fmt
                      ? parse(value, fmt, new Date(), this.options)
                      : parseISO(value, this.options)),
              isValid(value) ? value.getTime() : null
            );
          },
          format: function (time, fmt) {
            return format(time, fmt, this.options);
          },
          add: function (time, amount, unit) {
            switch (unit) {
              case 'millisecond':
                return addMilliseconds(time, amount);
              case 'second':
                return (function addSeconds(dirtyDate, dirtyAmount) {
                  return (
                    requiredArgs(2, arguments),
                    addMilliseconds(dirtyDate, 1e3 * toInteger(dirtyAmount))
                  );
                })(time, amount);
              case 'minute':
                return (function addMinutes(dirtyDate, dirtyAmount) {
                  return (
                    requiredArgs(2, arguments),
                    addMilliseconds(
                      dirtyDate,
                      toInteger(dirtyAmount) * MILLISECONDS_IN_MINUTE
                    )
                  );
                })(time, amount);
              case 'hour':
                return (function addHours(dirtyDate, dirtyAmount) {
                  return (
                    requiredArgs(2, arguments),
                    addMilliseconds(
                      dirtyDate,
                      toInteger(dirtyAmount) * MILLISECONDS_IN_HOUR
                    )
                  );
                })(time, amount);
              case 'day':
                return addDays(time, amount);
              case 'week':
                return (function addWeeks(dirtyDate, dirtyAmount) {
                  return (
                    requiredArgs(2, arguments),
                    addDays(dirtyDate, 7 * toInteger(dirtyAmount))
                  );
                })(time, amount);
              case 'month':
                return addMonths(time, amount);
              case 'quarter':
                return (function addQuarters(dirtyDate, dirtyAmount) {
                  return (
                    requiredArgs(2, arguments),
                    addMonths(dirtyDate, 3 * toInteger(dirtyAmount))
                  );
                })(time, amount);
              case 'year':
                return (function addYears(dirtyDate, dirtyAmount) {
                  return (
                    requiredArgs(2, arguments),
                    addMonths(dirtyDate, 12 * toInteger(dirtyAmount))
                  );
                })(time, amount);
              default:
                return time;
            }
          },
          diff: function (max, min, unit) {
            switch (unit) {
              case 'millisecond':
                return differenceInMilliseconds(max, min);
              case 'second':
                return (function differenceInSeconds(
                  dateLeft,
                  dateRight,
                  options
                ) {
                  requiredArgs(2, arguments);
                  var diff =
                    differenceInMilliseconds(dateLeft, dateRight) / 1e3;
                  return getRoundingMethod(
                    null == options ? void 0 : options.roundingMethod
                  )(diff);
                })(max, min);
              case 'minute':
                return (function differenceInMinutes(
                  dateLeft,
                  dateRight,
                  options
                ) {
                  requiredArgs(2, arguments);
                  var diff =
                    differenceInMilliseconds(dateLeft, dateRight) /
                    millisecondsInMinute;
                  return getRoundingMethod(
                    null == options ? void 0 : options.roundingMethod
                  )(diff);
                })(max, min);
              case 'hour':
                return (function differenceInHours(
                  dateLeft,
                  dateRight,
                  options
                ) {
                  requiredArgs(2, arguments);
                  var diff =
                    differenceInMilliseconds(dateLeft, dateRight) /
                    millisecondsInHour;
                  return getRoundingMethod(
                    null == options ? void 0 : options.roundingMethod
                  )(diff);
                })(max, min);
              case 'day':
                return differenceInDays(max, min);
              case 'week':
                return (function differenceInWeeks(
                  dateLeft,
                  dateRight,
                  options
                ) {
                  requiredArgs(2, arguments);
                  var diff = differenceInDays(dateLeft, dateRight) / 7;
                  return getRoundingMethod(
                    null == options ? void 0 : options.roundingMethod
                  )(diff);
                })(max, min);
              case 'month':
                return differenceInMonths(max, min);
              case 'quarter':
                return (function differenceInQuarters(
                  dateLeft,
                  dateRight,
                  options
                ) {
                  requiredArgs(2, arguments);
                  var diff = differenceInMonths(dateLeft, dateRight) / 3;
                  return getRoundingMethod(
                    null == options ? void 0 : options.roundingMethod
                  )(diff);
                })(max, min);
              case 'year':
                return differenceInYears(max, min);
              default:
                return 0;
            }
          },
          startOf: function (time, unit, weekday) {
            switch (unit) {
              case 'second':
                return (function startOfSecond(dirtyDate) {
                  requiredArgs(1, arguments);
                  var date = toDate(dirtyDate);
                  return date.setMilliseconds(0), date;
                })(time);
              case 'minute':
                return (function startOfMinute(dirtyDate) {
                  requiredArgs(1, arguments);
                  var date = toDate(dirtyDate);
                  return date.setSeconds(0, 0), date;
                })(time);
              case 'hour':
                return (function startOfHour(dirtyDate) {
                  requiredArgs(1, arguments);
                  var date = toDate(dirtyDate);
                  return date.setMinutes(0, 0, 0), date;
                })(time);
              case 'day':
                return startOfDay(time);
              case 'week':
                return startOfWeek(time);
              case 'isoWeek':
                return startOfWeek(time, { weekStartsOn: +weekday });
              case 'month':
                return (function startOfMonth(dirtyDate) {
                  requiredArgs(1, arguments);
                  var date = toDate(dirtyDate);
                  return date.setDate(1), date.setHours(0, 0, 0, 0), date;
                })(time);
              case 'quarter':
                return (function startOfQuarter(dirtyDate) {
                  requiredArgs(1, arguments);
                  var date = toDate(dirtyDate),
                    currentMonth = date.getMonth(),
                    month = currentMonth - (currentMonth % 3);
                  return (
                    date.setMonth(month, 1), date.setHours(0, 0, 0, 0), date
                  );
                })(time);
              case 'year':
                return (function startOfYear(dirtyDate) {
                  requiredArgs(1, arguments);
                  var cleanDate = toDate(dirtyDate),
                    date = new Date(0);
                  return (
                    date.setFullYear(cleanDate.getFullYear(), 0, 1),
                    date.setHours(0, 0, 0, 0),
                    date
                  );
                })(time);
              default:
                return time;
            }
          },
          endOf: function (time, unit) {
            switch (unit) {
              case 'second':
                return (function endOfSecond(dirtyDate) {
                  requiredArgs(1, arguments);
                  var date = toDate(dirtyDate);
                  return date.setMilliseconds(999), date;
                })(time);
              case 'minute':
                return (function endOfMinute(dirtyDate) {
                  requiredArgs(1, arguments);
                  var date = toDate(dirtyDate);
                  return date.setSeconds(59, 999), date;
                })(time);
              case 'hour':
                return (function endOfHour(dirtyDate) {
                  requiredArgs(1, arguments);
                  var date = toDate(dirtyDate);
                  return date.setMinutes(59, 59, 999), date;
                })(time);
              case 'day':
                return endOfDay(time);
              case 'week':
                return (function endOfWeek(dirtyDate, options) {
                  var _ref,
                    _ref2,
                    _ref3,
                    _options$weekStartsOn,
                    _options$locale,
                    _options$locale$optio,
                    _defaultOptions$local,
                    _defaultOptions$local2;
                  requiredArgs(1, arguments);
                  var defaultOptions = getDefaultOptions(),
                    weekStartsOn = toInteger(
                      null !==
                        (_ref =
                          null !==
                            (_ref2 =
                              null !==
                                (_ref3 =
                                  null !==
                                    (_options$weekStartsOn =
                                      null == options
                                        ? void 0
                                        : options.weekStartsOn) &&
                                  void 0 !== _options$weekStartsOn
                                    ? _options$weekStartsOn
                                    : null == options ||
                                      null ===
                                        (_options$locale = options.locale) ||
                                      void 0 === _options$locale ||
                                      null ===
                                        (_options$locale$optio =
                                          _options$locale.options) ||
                                      void 0 === _options$locale$optio
                                    ? void 0
                                    : _options$locale$optio.weekStartsOn) &&
                              void 0 !== _ref3
                                ? _ref3
                                : defaultOptions.weekStartsOn) &&
                          void 0 !== _ref2
                            ? _ref2
                            : null ===
                                (_defaultOptions$local =
                                  defaultOptions.locale) ||
                              void 0 === _defaultOptions$local ||
                              null ===
                                (_defaultOptions$local2 =
                                  _defaultOptions$local.options) ||
                              void 0 === _defaultOptions$local2
                            ? void 0
                            : _defaultOptions$local2.weekStartsOn) &&
                        void 0 !== _ref
                        ? _ref
                        : 0
                    );
                  if (!(weekStartsOn >= 0 && weekStartsOn <= 6))
                    throw new RangeError(
                      'weekStartsOn must be between 0 and 6 inclusively'
                    );
                  var date = toDate(dirtyDate),
                    day = date.getDay(),
                    diff =
                      6 + (day < weekStartsOn ? -7 : 0) - (day - weekStartsOn);
                  return (
                    date.setDate(date.getDate() + diff),
                    date.setHours(23, 59, 59, 999),
                    date
                  );
                })(time);
              case 'month':
                return endOfMonth(time);
              case 'quarter':
                return (function endOfQuarter(dirtyDate) {
                  requiredArgs(1, arguments);
                  var date = toDate(dirtyDate),
                    currentMonth = date.getMonth(),
                    month = currentMonth - (currentMonth % 3) + 3;
                  return (
                    date.setMonth(month, 0),
                    date.setHours(23, 59, 59, 999),
                    date
                  );
                })(time);
              case 'year':
                return (function endOfYear(dirtyDate) {
                  requiredArgs(1, arguments);
                  var date = toDate(dirtyDate),
                    year = date.getFullYear();
                  return (
                    date.setFullYear(year + 1, 0, 0),
                    date.setHours(23, 59, 59, 999),
                    date
                  );
                })(time);
              default:
                return time;
            }
          },
        });
      },
    './node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[14].use[1]!./node_modules/postcss-loader/dist/cjs.js!./node_modules/resolve-url-loader/index.js!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[14].use[4]!./node_modules/swiper/modules/navigation/navigation.scss':
      (module, __webpack_exports__, __webpack_require__) => {
        'use strict';
        __webpack_require__.d(__webpack_exports__, {
          Z: () => __WEBPACK_DEFAULT_EXPORT__,
        });
        var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ =
            __webpack_require__(
              './node_modules/css-loader/dist/runtime/sourceMaps.js'
            ),
          _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default =
            __webpack_require__.n(
              _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__
            ),
          _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ =
            __webpack_require__(
              './node_modules/css-loader/dist/runtime/api.js'
            ),
          ___CSS_LOADER_EXPORT___ = __webpack_require__.n(
            _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__
          )()(
            _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()
          );
        ___CSS_LOADER_EXPORT___.push([
          module.id,
          ':root{--swiper-navigation-size: 44px}.swiper-button-prev,.swiper-button-next{position:absolute;top:50%;width:calc(var(--swiper-navigation-size)/44*27);height:var(--swiper-navigation-size);margin-top:calc(0px - var(--swiper-navigation-size)/2);z-index:10;cursor:pointer;display:flex;align-items:center;justify-content:center;color:var(--swiper-navigation-color, var(--swiper-theme-color))}.swiper-button-prev.swiper-button-disabled,.swiper-button-next.swiper-button-disabled{opacity:.35;cursor:auto;pointer-events:none}.swiper-button-prev.swiper-button-hidden,.swiper-button-next.swiper-button-hidden{opacity:0;cursor:auto;pointer-events:none}.swiper-navigation-disabled .swiper-button-prev,.swiper-navigation-disabled .swiper-button-next{display:none !important}.swiper-button-prev:after,.swiper-button-next:after{font-family:swiper-icons;font-size:var(--swiper-navigation-size);text-transform:none !important;letter-spacing:0;font-variant:initial;line-height:1}.swiper-button-prev,.swiper-rtl .swiper-button-next{left:10px;right:auto}.swiper-button-prev:after,.swiper-rtl .swiper-button-next:after{content:"prev"}.swiper-button-next,.swiper-rtl .swiper-button-prev{right:10px;left:auto}.swiper-button-next:after,.swiper-rtl .swiper-button-prev:after{content:"next"}.swiper-button-lock{display:none}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/swiper/modules/navigation/navigation.scss',
            ],
            names: [],
            mappings:
              'AAEE,MACE,8BAAA,CAMJ,wCAEE,iBAAA,CACA,OAAA,CACA,+CAAA,CACA,oCAAA,CACA,sDAAA,CACA,UAAA,CACA,cAAA,CACA,YAAA,CACA,kBAAA,CACA,sBAAA,CACA,+DAAA,CACA,sFACE,WAAA,CACA,WAAA,CACA,mBAAA,CAEF,kFACE,SAAA,CACA,WAAA,CACA,mBAAA,CAEF,gGACE,uBAAA,CAEF,oDACE,wBAAA,CACA,uCAAA,CACA,8BAAA,CACA,gBAAA,CACA,oBAAA,CACA,aAAA,CAGJ,oDAKE,SAAA,CACA,UAAA,CAJA,gEACE,cAAA,CAKJ,oDAKE,UAAA,CACA,SAAA,CAJA,gEACE,cAAA,CAMJ,oBACE,YAAA',
            sourcesContent: [
              "@import '../../swiper-vars.scss';\n@at-root {\n  :root {\n    --swiper-navigation-size: 44px;\n    /*\n  --swiper-navigation-color: var(--swiper-theme-color);\n  */\n  }\n}\n.swiper-button-prev,\n.swiper-button-next {\n  position: absolute;\n  top: 50%;\n  width: calc(var(--swiper-navigation-size) / 44 * 27);\n  height: var(--swiper-navigation-size);\n  margin-top: calc(0px - (var(--swiper-navigation-size) / 2));\n  z-index: 10;\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  color: var(--swiper-navigation-color, var(--swiper-theme-color));\n  &.swiper-button-disabled {\n    opacity: 0.35;\n    cursor: auto;\n    pointer-events: none;\n  }\n  &.swiper-button-hidden {\n    opacity: 0;\n    cursor: auto;\n    pointer-events: none;\n  }\n  .swiper-navigation-disabled & {\n    display: none !important;\n  }\n  &:after {\n    font-family: swiper-icons;\n    font-size: var(--swiper-navigation-size);\n    text-transform: none !important;\n    letter-spacing: 0;\n    font-variant: initial;\n    line-height: 1;\n  }\n}\n.swiper-button-prev,\n.swiper-rtl .swiper-button-next {\n  &:after {\n    content: 'prev';\n  }\n  left: 10px;\n  right: auto;\n}\n.swiper-button-next,\n.swiper-rtl .swiper-button-prev {\n  &:after {\n    content: 'next';\n  }\n  right: 10px;\n  left: auto;\n}\n\n.swiper-button-lock {\n  display: none;\n}\n",
            ],
            sourceRoot: '',
          },
        ]);
        const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
      },
    './node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[14].use[1]!./node_modules/postcss-loader/dist/cjs.js!./node_modules/resolve-url-loader/index.js!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[14].use[4]!./node_modules/swiper/modules/pagination/pagination.scss':
      (module, __webpack_exports__, __webpack_require__) => {
        'use strict';
        __webpack_require__.d(__webpack_exports__, {
          Z: () => __WEBPACK_DEFAULT_EXPORT__,
        });
        var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ =
            __webpack_require__(
              './node_modules/css-loader/dist/runtime/sourceMaps.js'
            ),
          _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default =
            __webpack_require__.n(
              _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__
            ),
          _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ =
            __webpack_require__(
              './node_modules/css-loader/dist/runtime/api.js'
            ),
          ___CSS_LOADER_EXPORT___ = __webpack_require__.n(
            _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__
          )()(
            _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()
          );
        ___CSS_LOADER_EXPORT___.push([
          module.id,
          '.swiper-pagination{position:absolute;text-align:center;transition:300ms opacity;transform:translate3d(0, 0, 0);z-index:10}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-pagination-disabled>.swiper-pagination,.swiper-pagination.swiper-pagination-disabled{display:none !important}.swiper-pagination-fraction,.swiper-pagination-custom,.swiper-horizontal>.swiper-pagination-bullets,.swiper-pagination-bullets.swiper-pagination-horizontal{bottom:10px;left:0;width:100%}.swiper-pagination-bullets-dynamic{overflow:hidden;font-size:0}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transform:scale(0.33);position:relative}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{transform:scale(0.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{transform:scale(0.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{transform:scale(0.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{transform:scale(0.33)}.swiper-pagination-bullet{width:var(--swiper-pagination-bullet-width, var(--swiper-pagination-bullet-size, 8px));height:var(--swiper-pagination-bullet-height, var(--swiper-pagination-bullet-size, 8px));display:inline-block;border-radius:50%;background:var(--swiper-pagination-bullet-inactive-color, #000);opacity:var(--swiper-pagination-bullet-inactive-opacity, 0.2)}button.swiper-pagination-bullet{border:none;margin:0;padding:0;box-shadow:none;-webkit-appearance:none;-moz-appearance:none;appearance:none}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet:only-child{display:none !important}.swiper-pagination-bullet-active{opacity:var(--swiper-pagination-bullet-opacity, 1);background:var(--swiper-pagination-color, var(--swiper-theme-color))}.swiper-vertical>.swiper-pagination-bullets,.swiper-pagination-vertical.swiper-pagination-bullets{right:10px;top:50%;transform:translate3d(0px, -50%, 0)}.swiper-vertical>.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-pagination-vertical.swiper-pagination-bullets .swiper-pagination-bullet{margin:var(--swiper-pagination-bullet-vertical-gap, 6px) 0;display:block}.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;transform:translateY(-50%);width:8px}.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;transition:200ms transform,200ms top}.swiper-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 var(--swiper-pagination-bullet-horizontal-gap, 4px)}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;transform:translateX(-50%);white-space:nowrap}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:200ms transform,200ms left}.swiper-horizontal.swiper-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:200ms transform,200ms right}.swiper-pagination-progressbar{background:rgba(0,0,0,.25);position:absolute}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:var(--swiper-pagination-color, var(--swiper-theme-color));position:absolute;left:0;top:0;width:100%;height:100%;transform:scale(0);transform-origin:left top}.swiper-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{transform-origin:right top}.swiper-horizontal>.swiper-pagination-progressbar,.swiper-pagination-progressbar.swiper-pagination-horizontal,.swiper-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-vertical.swiper-pagination-progressbar-opposite{width:100%;height:4px;left:0;top:0}.swiper-vertical>.swiper-pagination-progressbar,.swiper-pagination-progressbar.swiper-pagination-vertical,.swiper-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-horizontal.swiper-pagination-progressbar-opposite{width:4px;height:100%;left:0;top:0}.swiper-pagination-lock{display:none}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/swiper/modules/pagination/pagination.scss',
            ],
            names: [],
            mappings:
              'AAgBA,mBACE,iBAAA,CACA,iBAAA,CACA,wBAAA,CACA,8BAAA,CACA,UAAA,CACA,4CACE,SAAA,CAEF,6FAEE,uBAAA,CAIJ,4JAIE,WAAA,CACA,MAAA,CACA,UAAA,CAGF,mCACE,eAAA,CACA,WAAA,CACA,6DACE,qBAAA,CACA,iBAAA,CAEF,oEACE,kBAAA,CAEF,yEACE,kBAAA,CAEF,yEACE,qBAAA,CAEF,8EACE,qBAAA,CAEF,yEACE,qBAAA,CAEF,8EACE,qBAAA,CAGJ,0BACE,sFAAA,CACA,wFAAA,CACA,oBAAA,CACA,iBAAA,CACA,+DAAA,CACA,6DAAA,CACS,gCACP,WAAA,CACA,QAAA,CACA,SAAA,CACA,eAAA,CACA,uBAAA,CAAA,oBAAA,CAAA,eAAA,CAEF,uDACE,cAAA,CAGF,qCACE,uBAAA,CAGJ,iCACE,kDAAA,CACA,oEAAA,CAGF,kGAEE,UAAA,CACA,OAAA,CACA,mCAAA,CACA,sJACE,0DAAA,CACA,aAAA,CAEF,sKACE,OAAA,CACA,0BAAA,CACA,SAAA,CACA,0NACE,oBAAA,CACA,oCAAA,CAMJ,0JACE,4DAAA,CAEF,0KACE,QAAA,CACA,0BAAA,CACA,kBAAA,CACA,8NACE,qCAAA,CAIN,2FACE,sCAAA,CAGF,+BACE,0BAAA,CACA,iBAAA,CACA,mEACE,oEAAA,CACA,iBAAA,CACA,MAAA,CACA,KAAA,CACA,UAAA,CACA,WAAA,CACA,kBAAA,CACA,yBAAA,CAEF,+EACE,0BAAA,CAEF,sSAIE,UAAA,CACA,UAAA,CACA,MAAA,CACA,KAAA,CAEF,sSAIE,SAAA,CACA,WAAA,CACA,MAAA,CACA,KAAA,CAGJ,wBACE,YAAA',
            sourcesContent: [
              "@import '../../swiper-vars.scss';\n@at-root {\n  :root {\n    /*\n  --swiper-pagination-color: var(--swiper-theme-color);\n  --swiper-pagination-bullet-size: 8px;\n  --swiper-pagination-bullet-width: 8px;\n  --swiper-pagination-bullet-height: 8px;\n  --swiper-pagination-bullet-inactive-color: #000;\n  --swiper-pagination-bullet-inactive-opacity: 0.2;\n  --swiper-pagination-bullet-opacity: 1;\n  --swiper-pagination-bullet-horizontal-gap: 4px;\n  --swiper-pagination-bullet-vertical-gap: 6px;\n  */\n  }\n}\n.swiper-pagination {\n  position: absolute;\n  text-align: center;\n  transition: 300ms opacity;\n  transform: translate3d(0, 0, 0);\n  z-index: 10;\n  &.swiper-pagination-hidden {\n    opacity: 0;\n  }\n  .swiper-pagination-disabled > &,\n  &.swiper-pagination-disabled {\n    display: none !important;\n  }\n}\n/* Common Styles */\n.swiper-pagination-fraction,\n.swiper-pagination-custom,\n.swiper-horizontal > .swiper-pagination-bullets,\n.swiper-pagination-bullets.swiper-pagination-horizontal {\n  bottom: 10px;\n  left: 0;\n  width: 100%;\n}\n/* Bullets */\n.swiper-pagination-bullets-dynamic {\n  overflow: hidden;\n  font-size: 0;\n  .swiper-pagination-bullet {\n    transform: scale(0.33);\n    position: relative;\n  }\n  .swiper-pagination-bullet-active {\n    transform: scale(1);\n  }\n  .swiper-pagination-bullet-active-main {\n    transform: scale(1);\n  }\n  .swiper-pagination-bullet-active-prev {\n    transform: scale(0.66);\n  }\n  .swiper-pagination-bullet-active-prev-prev {\n    transform: scale(0.33);\n  }\n  .swiper-pagination-bullet-active-next {\n    transform: scale(0.66);\n  }\n  .swiper-pagination-bullet-active-next-next {\n    transform: scale(0.33);\n  }\n}\n.swiper-pagination-bullet {\n  width: var(--swiper-pagination-bullet-width, var(--swiper-pagination-bullet-size, 8px));\n  height: var(--swiper-pagination-bullet-height, var(--swiper-pagination-bullet-size, 8px));\n  display: inline-block;\n  border-radius: 50%;\n  background: var(--swiper-pagination-bullet-inactive-color, #000);\n  opacity: var(--swiper-pagination-bullet-inactive-opacity, 0.2);\n  @at-root button#{&} {\n    border: none;\n    margin: 0;\n    padding: 0;\n    box-shadow: none;\n    appearance: none;\n  }\n  .swiper-pagination-clickable & {\n    cursor: pointer;\n  }\n\n  &:only-child {\n    display: none !important;\n  }\n}\n.swiper-pagination-bullet-active {\n  opacity: var(--swiper-pagination-bullet-opacity, 1);\n  background: var(--swiper-pagination-color, var(--swiper-theme-color));\n}\n\n.swiper-vertical > .swiper-pagination-bullets,\n.swiper-pagination-vertical.swiper-pagination-bullets {\n  right: 10px;\n  top: 50%;\n  transform: translate3d(0px, -50%, 0);\n  .swiper-pagination-bullet {\n    margin: var(--swiper-pagination-bullet-vertical-gap, 6px) 0;\n    display: block;\n  }\n  &.swiper-pagination-bullets-dynamic {\n    top: 50%;\n    transform: translateY(-50%);\n    width: 8px;\n    .swiper-pagination-bullet {\n      display: inline-block;\n      transition: 200ms transform, 200ms top;\n    }\n  }\n}\n.swiper-horizontal > .swiper-pagination-bullets,\n.swiper-pagination-horizontal.swiper-pagination-bullets {\n  .swiper-pagination-bullet {\n    margin: 0 var(--swiper-pagination-bullet-horizontal-gap, 4px);\n  }\n  &.swiper-pagination-bullets-dynamic {\n    left: 50%;\n    transform: translateX(-50%);\n    white-space: nowrap;\n    .swiper-pagination-bullet {\n      transition: 200ms transform, 200ms left;\n    }\n  }\n}\n.swiper-horizontal.swiper-rtl > .swiper-pagination-bullets-dynamic .swiper-pagination-bullet {\n  transition: 200ms transform, 200ms right;\n}\n/* Progress */\n.swiper-pagination-progressbar {\n  background: rgba(0, 0, 0, 0.25);\n  position: absolute;\n  .swiper-pagination-progressbar-fill {\n    background: var(--swiper-pagination-color, var(--swiper-theme-color));\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    transform: scale(0);\n    transform-origin: left top;\n  }\n  .swiper-rtl & .swiper-pagination-progressbar-fill {\n    transform-origin: right top;\n  }\n  .swiper-horizontal > &,\n  &.swiper-pagination-horizontal,\n  .swiper-vertical > &.swiper-pagination-progressbar-opposite,\n  &.swiper-pagination-vertical.swiper-pagination-progressbar-opposite {\n    width: 100%;\n    height: 4px;\n    left: 0;\n    top: 0;\n  }\n  .swiper-vertical > &,\n  &.swiper-pagination-vertical,\n  .swiper-horizontal > &.swiper-pagination-progressbar-opposite,\n  &.swiper-pagination-horizontal.swiper-pagination-progressbar-opposite {\n    width: 4px;\n    height: 100%;\n    left: 0;\n    top: 0;\n  }\n}\n.swiper-pagination-lock {\n  display: none;\n}\n",
            ],
            sourceRoot: '',
          },
        ]);
        const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
      },
    './node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[14].use[1]!./node_modules/postcss-loader/dist/cjs.js!./node_modules/resolve-url-loader/index.js!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[14].use[4]!./node_modules/swiper/swiper.scss':
      (module, __webpack_exports__, __webpack_require__) => {
        'use strict';
        __webpack_require__.d(__webpack_exports__, {
          Z: () => __WEBPACK_DEFAULT_EXPORT__,
        });
        var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ =
            __webpack_require__(
              './node_modules/css-loader/dist/runtime/sourceMaps.js'
            ),
          _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default =
            __webpack_require__.n(
              _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__
            ),
          _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ =
            __webpack_require__(
              './node_modules/css-loader/dist/runtime/api.js'
            ),
          ___CSS_LOADER_EXPORT___ = __webpack_require__.n(
            _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__
          )()(
            _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()
          );
        ___CSS_LOADER_EXPORT___.push([
          module.id,
          '@font-face{font-family:"swiper-icons";src:url("data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA") format("woff");font-weight:400;font-style:normal}:root{--swiper-theme-color: #007aff}.swiper{margin-left:auto;margin-right:auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1}.swiper-vertical>.swiper-wrapper{flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:flex;transition-property:transform;box-sizing:content-box}.swiper-android .swiper-slide,.swiper-wrapper{transform:translate3d(0px, 0, 0)}.swiper-pointer-events{touch-action:pan-y}.swiper-pointer-events.swiper-vertical{touch-action:pan-x}.swiper-slide{flex-shrink:0;width:100%;height:100%;position:relative;transition-property:transform}.swiper-slide-invisible-blank{visibility:hidden}.swiper-autoheight,.swiper-autoheight .swiper-slide{height:auto}.swiper-autoheight .swiper-wrapper{align-items:flex-start;transition-property:transform,height}.swiper-backface-hidden .swiper-slide{transform:translateZ(0);-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-3d,.swiper-3d.swiper-css-mode .swiper-wrapper{perspective:1200px}.swiper-3d .swiper-wrapper,.swiper-3d .swiper-slide,.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top,.swiper-3d .swiper-slide-shadow-bottom,.swiper-3d .swiper-cube-shadow{transform-style:preserve-3d}.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top,.swiper-3d .swiper-slide-shadow-bottom{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}.swiper-3d .swiper-slide-shadow{background:rgba(0,0,0,.15)}.swiper-3d .swiper-slide-shadow-left{background-image:linear-gradient(to left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0))}.swiper-3d .swiper-slide-shadow-right{background-image:linear-gradient(to right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0))}.swiper-3d .swiper-slide-shadow-top{background-image:linear-gradient(to top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0))}.swiper-3d .swiper-slide-shadow-bottom{background-image:linear-gradient(to bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0))}.swiper-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}.swiper-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-css-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:start start}.swiper-horizontal.swiper-css-mode>.swiper-wrapper{scroll-snap-type:x mandatory}.swiper-vertical.swiper-css-mode>.swiper-wrapper{scroll-snap-type:y mandatory}.swiper-centered>.swiper-wrapper::before{content:"";flex-shrink:0;order:9999}.swiper-centered.swiper-horizontal>.swiper-wrapper>.swiper-slide:first-child{-webkit-margin-start:var(--swiper-centered-offset-before);margin-inline-start:var(--swiper-centered-offset-before)}.swiper-centered.swiper-horizontal>.swiper-wrapper::before{height:100%;width:var(--swiper-centered-offset-after)}.swiper-centered.swiper-vertical>.swiper-wrapper>.swiper-slide:first-child{-webkit-margin-before:var(--swiper-centered-offset-before);margin-block-start:var(--swiper-centered-offset-before)}.swiper-centered.swiper-vertical>.swiper-wrapper::before{width:100%;height:var(--swiper-centered-offset-after)}.swiper-centered>.swiper-wrapper>.swiper-slide{scroll-snap-align:center center}',
          '',
          {
            version: 3,
            sources: ['webpack://./node_modules/swiper/swiper.scss'],
            names: [],
            mappings:
              'AAcE,WACE,0BAAA,CACA,2sEAAA,CAEA,eAAA,CACA,iBAAA,CAIF,MACE,6BAAA,CAGJ,QACE,gBAAA,CACA,iBAAA,CACA,iBAAA,CACA,eAAA,CACA,eAAA,CACA,SAAA,CAEA,SAAA,CAEF,iCACE,qBAAA,CAEF,gBACE,iBAAA,CACA,UAAA,CACA,WAAA,CACA,SAAA,CACA,YAAA,CACA,6BAAA,CACA,sBAAA,CAEF,8CAEE,gCAAA,CAEF,uBACE,kBAAA,CACA,uCACE,kBAAA,CAGJ,cACE,aAAA,CACA,UAAA,CACA,WAAA,CACA,iBAAA,CACA,6BAAA,CAEF,8BACE,iBAAA,CAIA,oDAEE,WAAA,CAGF,mCACE,sBAAA,CACA,oCAAA,CAGJ,sCACE,uBAAA,CACA,kCAAA,CAAA,0BAAA,CAIA,sDAEE,kBAAA,CAEF,yQAQE,2BAAA,CAEF,sLAKE,iBAAA,CACA,MAAA,CACA,KAAA,CACA,UAAA,CACA,WAAA,CACA,mBAAA,CACA,UAAA,CAEF,gCACE,0BAAA,CAEF,qCACE,+EAAA,CAEF,sCACE,gFAAA,CAEF,oCACE,8EAAA,CAEF,uCACE,iFAAA,CAMF,iCACE,aAAA,CACA,oBAAA,CACA,uBAAA,CACA,oDACE,YAAA,CAGJ,+CACE,6BAAA,CAIF,mDACE,4BAAA,CAIF,iDACE,4BAAA,CAIF,yCACE,UAAA,CACA,aAAA,CACA,UAAA,CAGA,6EACE,yDAAA,CAAA,wDAAA,CAEF,2DACE,WAAA,CACA,yCAAA,CAIF,2EACE,0DAAA,CAAA,uDAAA,CAEF,yDACE,UAAA,CACA,0CAAA,CAIJ,+CACE,+BAAA',
            sourcesContent: [
              "/**\n * Swiper 8.4.5\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2022 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: November 21, 2022\n */\n\n@import 'swiper-vars.scss';\n@at-root {\n  @font-face {\n    font-family: 'swiper-icons';\n    src: url('data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA')\n      format('woff');\n    font-weight: 400;\n    font-style: normal;\n  }\n}\n@at-root {\n  :root {\n    --swiper-theme-color: #{$themeColor};\n  }\n}\n.swiper {\n  margin-left: auto;\n  margin-right: auto;\n  position: relative;\n  overflow: hidden;\n  list-style: none;\n  padding: 0;\n  /* Fix of Webkit flickering */\n  z-index: 1;\n}\n.swiper-vertical > .swiper-wrapper {\n  flex-direction: column;\n}\n.swiper-wrapper {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  z-index: 1;\n  display: flex;\n  transition-property: transform;\n  box-sizing: content-box;\n}\n.swiper-android .swiper-slide,\n.swiper-wrapper {\n  transform: translate3d(0px, 0, 0);\n}\n.swiper-pointer-events {\n  touch-action: pan-y;\n  &.swiper-vertical {\n    touch-action: pan-x;\n  }\n}\n.swiper-slide {\n  flex-shrink: 0;\n  width: 100%;\n  height: 100%;\n  position: relative;\n  transition-property: transform;\n}\n.swiper-slide-invisible-blank {\n  visibility: hidden;\n}\n/* Auto Height */\n.swiper-autoheight {\n  &,\n  .swiper-slide {\n    height: auto;\n  }\n\n  .swiper-wrapper {\n    align-items: flex-start;\n    transition-property: transform, height;\n  }\n}\n.swiper-backface-hidden .swiper-slide {\n  transform: translateZ(0);\n  backface-visibility: hidden;\n}\n/* 3D Effects */\n.swiper-3d {\n  &,\n  &.swiper-css-mode .swiper-wrapper {\n    perspective: 1200px;\n  }\n  .swiper-wrapper,\n  .swiper-slide,\n  .swiper-slide-shadow,\n  .swiper-slide-shadow-left,\n  .swiper-slide-shadow-right,\n  .swiper-slide-shadow-top,\n  .swiper-slide-shadow-bottom,\n  .swiper-cube-shadow {\n    transform-style: preserve-3d;\n  }\n  .swiper-slide-shadow,\n  .swiper-slide-shadow-left,\n  .swiper-slide-shadow-right,\n  .swiper-slide-shadow-top,\n  .swiper-slide-shadow-bottom {\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n    z-index: 10;\n  }\n  .swiper-slide-shadow {\n    background: rgba(0, 0, 0, 0.15);\n  }\n  .swiper-slide-shadow-left {\n    background-image: linear-gradient(to left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n  }\n  .swiper-slide-shadow-right {\n    background-image: linear-gradient(to right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n  }\n  .swiper-slide-shadow-top {\n    background-image: linear-gradient(to top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n  }\n  .swiper-slide-shadow-bottom {\n    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n  }\n}\n\n/* CSS Mode */\n.swiper-css-mode {\n  > .swiper-wrapper {\n    overflow: auto;\n    scrollbar-width: none; /* For Firefox */\n    -ms-overflow-style: none; /* For Internet Explorer and Edge */\n    &::-webkit-scrollbar {\n      display: none;\n    }\n  }\n  > .swiper-wrapper > .swiper-slide {\n    scroll-snap-align: start start;\n  }\n}\n.swiper-horizontal.swiper-css-mode {\n  > .swiper-wrapper {\n    scroll-snap-type: x mandatory;\n  }\n}\n.swiper-vertical.swiper-css-mode {\n  > .swiper-wrapper {\n    scroll-snap-type: y mandatory;\n  }\n}\n.swiper-centered {\n  > .swiper-wrapper::before {\n    content: '';\n    flex-shrink: 0;\n    order: 9999;\n  }\n  &.swiper-horizontal {\n    > .swiper-wrapper > .swiper-slide:first-child {\n      margin-inline-start: var(--swiper-centered-offset-before);\n    }\n    > .swiper-wrapper::before {\n      height: 100%;\n      width: var(--swiper-centered-offset-after);\n    }\n  }\n  &.swiper-vertical {\n    > .swiper-wrapper > .swiper-slide:first-child {\n      margin-block-start: var(--swiper-centered-offset-before);\n    }\n    > .swiper-wrapper::before {\n      width: 100%;\n      height: var(--swiper-centered-offset-after);\n    }\n  }\n\n  > .swiper-wrapper > .swiper-slide {\n    scroll-snap-align: center center;\n  }\n}\n\n\n\n",
            ],
            sourceRoot: '',
          },
        ]);
        const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
      },
    './node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js': (
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) => {
      'use strict';
      function buildFormatLongFn(args) {
        return function () {
          var options =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {},
            width = options.width ? String(options.width) : args.defaultWidth;
          return args.formats[width] || args.formats[args.defaultWidth];
        };
      }
      __webpack_require__.d(__webpack_exports__, {
        Z: () => buildFormatLongFn,
      });
    },
    './node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js': (
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) => {
      'use strict';
      function buildLocalizeFn(args) {
        return function (dirtyIndex, options) {
          var valuesArray;
          if (
            'formatting' ===
              (null != options && options.context
                ? String(options.context)
                : 'standalone') &&
            args.formattingValues
          ) {
            var defaultWidth = args.defaultFormattingWidth || args.defaultWidth,
              width =
                null != options && options.width
                  ? String(options.width)
                  : defaultWidth;
            valuesArray =
              args.formattingValues[width] ||
              args.formattingValues[defaultWidth];
          } else {
            var _defaultWidth = args.defaultWidth,
              _width =
                null != options && options.width
                  ? String(options.width)
                  : args.defaultWidth;
            valuesArray = args.values[_width] || args.values[_defaultWidth];
          }
          return valuesArray[
            args.argumentCallback
              ? args.argumentCallback(dirtyIndex)
              : dirtyIndex
          ];
        };
      }
      __webpack_require__.d(__webpack_exports__, { Z: () => buildLocalizeFn });
    },
    './node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js': (
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) => {
      'use strict';
      function buildMatchFn(args) {
        return function (string) {
          var options =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {},
            width = options.width,
            matchPattern =
              (width && args.matchPatterns[width]) ||
              args.matchPatterns[args.defaultMatchWidth],
            matchResult = string.match(matchPattern);
          if (!matchResult) return null;
          var value,
            matchedString = matchResult[0],
            parsePatterns =
              (width && args.parsePatterns[width]) ||
              args.parsePatterns[args.defaultParseWidth],
            key = Array.isArray(parsePatterns)
              ? (function findIndex(array, predicate) {
                  for (var key = 0; key < array.length; key++)
                    if (predicate(array[key])) return key;
                  return;
                })(parsePatterns, function (pattern) {
                  return pattern.test(matchedString);
                })
              : (function findKey(object, predicate) {
                  for (var key in object)
                    if (object.hasOwnProperty(key) && predicate(object[key]))
                      return key;
                  return;
                })(parsePatterns, function (pattern) {
                  return pattern.test(matchedString);
                });
          return (
            (value = args.valueCallback ? args.valueCallback(key) : key),
            {
              value: (value = options.valueCallback
                ? options.valueCallback(value)
                : value),
              rest: string.slice(matchedString.length),
            }
          );
        };
      }
      __webpack_require__.d(__webpack_exports__, { Z: () => buildMatchFn });
    },
    './node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js': (
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) => {
      'use strict';
      function buildMatchPatternFn(args) {
        return function (string) {
          var options =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {},
            matchResult = string.match(args.matchPattern);
          if (!matchResult) return null;
          var matchedString = matchResult[0],
            parseResult = string.match(args.parsePattern);
          if (!parseResult) return null;
          var value = args.valueCallback
            ? args.valueCallback(parseResult[0])
            : parseResult[0];
          return {
            value: (value = options.valueCallback
              ? options.valueCallback(value)
              : value),
            rest: string.slice(matchedString.length),
          };
        };
      }
      __webpack_require__.d(__webpack_exports__, {
        Z: () => buildMatchPatternFn,
      });
    },
    './node_modules/date-fns/esm/locale/de/index.js': (
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) => {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { Z: () => de });
      var formatDistanceLocale = {
        lessThanXSeconds: {
          standalone: {
            one: 'weniger als 1 Sekunde',
            other: 'weniger als {{count}} Sekunden',
          },
          withPreposition: {
            one: 'weniger als 1 Sekunde',
            other: 'weniger als {{count}} Sekunden',
          },
        },
        xSeconds: {
          standalone: { one: '1 Sekunde', other: '{{count}} Sekunden' },
          withPreposition: { one: '1 Sekunde', other: '{{count}} Sekunden' },
        },
        halfAMinute: {
          standalone: 'halbe Minute',
          withPreposition: 'halben Minute',
        },
        lessThanXMinutes: {
          standalone: {
            one: 'weniger als 1 Minute',
            other: 'weniger als {{count}} Minuten',
          },
          withPreposition: {
            one: 'weniger als 1 Minute',
            other: 'weniger als {{count}} Minuten',
          },
        },
        xMinutes: {
          standalone: { one: '1 Minute', other: '{{count}} Minuten' },
          withPreposition: { one: '1 Minute', other: '{{count}} Minuten' },
        },
        aboutXHours: {
          standalone: { one: 'etwa 1 Stunde', other: 'etwa {{count}} Stunden' },
          withPreposition: {
            one: 'etwa 1 Stunde',
            other: 'etwa {{count}} Stunden',
          },
        },
        xHours: {
          standalone: { one: '1 Stunde', other: '{{count}} Stunden' },
          withPreposition: { one: '1 Stunde', other: '{{count}} Stunden' },
        },
        xDays: {
          standalone: { one: '1 Tag', other: '{{count}} Tage' },
          withPreposition: { one: '1 Tag', other: '{{count}} Tagen' },
        },
        aboutXWeeks: {
          standalone: { one: 'etwa 1 Woche', other: 'etwa {{count}} Wochen' },
          withPreposition: {
            one: 'etwa 1 Woche',
            other: 'etwa {{count}} Wochen',
          },
        },
        xWeeks: {
          standalone: { one: '1 Woche', other: '{{count}} Wochen' },
          withPreposition: { one: '1 Woche', other: '{{count}} Wochen' },
        },
        aboutXMonths: {
          standalone: { one: 'etwa 1 Monat', other: 'etwa {{count}} Monate' },
          withPreposition: {
            one: 'etwa 1 Monat',
            other: 'etwa {{count}} Monaten',
          },
        },
        xMonths: {
          standalone: { one: '1 Monat', other: '{{count}} Monate' },
          withPreposition: { one: '1 Monat', other: '{{count}} Monaten' },
        },
        aboutXYears: {
          standalone: { one: 'etwa 1 Jahr', other: 'etwa {{count}} Jahre' },
          withPreposition: {
            one: 'etwa 1 Jahr',
            other: 'etwa {{count}} Jahren',
          },
        },
        xYears: {
          standalone: { one: '1 Jahr', other: '{{count}} Jahre' },
          withPreposition: { one: '1 Jahr', other: '{{count}} Jahren' },
        },
        overXYears: {
          standalone: {
            one: 'mehr als 1 Jahr',
            other: 'mehr als {{count}} Jahre',
          },
          withPreposition: {
            one: 'mehr als 1 Jahr',
            other: 'mehr als {{count}} Jahren',
          },
        },
        almostXYears: {
          standalone: { one: 'fast 1 Jahr', other: 'fast {{count}} Jahre' },
          withPreposition: {
            one: 'fast 1 Jahr',
            other: 'fast {{count}} Jahren',
          },
        },
      };
      const _lib_formatDistance = function formatDistance(
        token,
        count,
        options
      ) {
        var result,
          tokenValue =
            null != options && options.addSuffix
              ? formatDistanceLocale[token].withPreposition
              : formatDistanceLocale[token].standalone;
        return (
          (result =
            'string' == typeof tokenValue
              ? tokenValue
              : 1 === count
              ? tokenValue.one
              : tokenValue.other.replace('{{count}}', String(count))),
          null != options && options.addSuffix
            ? options.comparison && options.comparison > 0
              ? 'in ' + result
              : 'vor ' + result
            : result
        );
      };
      var buildFormatLongFn = __webpack_require__(
        './node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js'
      );
      const _lib_formatLong = {
        date: (0, buildFormatLongFn.Z)({
          formats: {
            full: 'EEEE, do MMMM y',
            long: 'do MMMM y',
            medium: 'do MMM y',
            short: 'dd.MM.y',
          },
          defaultWidth: 'full',
        }),
        time: (0, buildFormatLongFn.Z)({
          formats: {
            full: 'HH:mm:ss zzzz',
            long: 'HH:mm:ss z',
            medium: 'HH:mm:ss',
            short: 'HH:mm',
          },
          defaultWidth: 'full',
        }),
        dateTime: (0, buildFormatLongFn.Z)({
          formats: {
            full: "{{date}} 'um' {{time}}",
            long: "{{date}} 'um' {{time}}",
            medium: '{{date}} {{time}}',
            short: '{{date}} {{time}}',
          },
          defaultWidth: 'full',
        }),
      };
      var formatRelativeLocale = {
        lastWeek: "'letzten' eeee 'um' p",
        yesterday: "'gestern um' p",
        today: "'heute um' p",
        tomorrow: "'morgen um' p",
        nextWeek: "eeee 'um' p",
        other: 'P',
      };
      const _lib_formatRelative = function formatRelative(
        token,
        _date,
        _baseDate,
        _options
      ) {
        return formatRelativeLocale[token];
      };
      var buildLocalizeFn = __webpack_require__(
          './node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js'
        ),
        monthValues = {
          narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
          abbreviated: [
            'Jan',
            'Feb',
            'Mär',
            'Apr',
            'Mai',
            'Jun',
            'Jul',
            'Aug',
            'Sep',
            'Okt',
            'Nov',
            'Dez',
          ],
          wide: [
            'Januar',
            'Februar',
            'März',
            'April',
            'Mai',
            'Juni',
            'Juli',
            'August',
            'September',
            'Oktober',
            'November',
            'Dezember',
          ],
        },
        formattingMonthValues = {
          narrow: monthValues.narrow,
          abbreviated: [
            'Jan.',
            'Feb.',
            'März',
            'Apr.',
            'Mai',
            'Juni',
            'Juli',
            'Aug.',
            'Sep.',
            'Okt.',
            'Nov.',
            'Dez.',
          ],
          wide: monthValues.wide,
        };
      const _lib_localize = {
        ordinalNumber: function ordinalNumber(dirtyNumber) {
          return Number(dirtyNumber) + '.';
        },
        era: (0, buildLocalizeFn.Z)({
          values: {
            narrow: ['v.Chr.', 'n.Chr.'],
            abbreviated: ['v.Chr.', 'n.Chr.'],
            wide: ['vor Christus', 'nach Christus'],
          },
          defaultWidth: 'wide',
        }),
        quarter: (0, buildLocalizeFn.Z)({
          values: {
            narrow: ['1', '2', '3', '4'],
            abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
            wide: ['1. Quartal', '2. Quartal', '3. Quartal', '4. Quartal'],
          },
          defaultWidth: 'wide',
          argumentCallback: function argumentCallback(quarter) {
            return quarter - 1;
          },
        }),
        month: (0, buildLocalizeFn.Z)({
          values: monthValues,
          formattingValues: formattingMonthValues,
          defaultWidth: 'wide',
        }),
        day: (0, buildLocalizeFn.Z)({
          values: {
            narrow: ['S', 'M', 'D', 'M', 'D', 'F', 'S'],
            short: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
            abbreviated: ['So.', 'Mo.', 'Di.', 'Mi.', 'Do.', 'Fr.', 'Sa.'],
            wide: [
              'Sonntag',
              'Montag',
              'Dienstag',
              'Mittwoch',
              'Donnerstag',
              'Freitag',
              'Samstag',
            ],
          },
          defaultWidth: 'wide',
        }),
        dayPeriod: (0, buildLocalizeFn.Z)({
          values: {
            narrow: {
              am: 'vm.',
              pm: 'nm.',
              midnight: 'Mitternacht',
              noon: 'Mittag',
              morning: 'Morgen',
              afternoon: 'Nachm.',
              evening: 'Abend',
              night: 'Nacht',
            },
            abbreviated: {
              am: 'vorm.',
              pm: 'nachm.',
              midnight: 'Mitternacht',
              noon: 'Mittag',
              morning: 'Morgen',
              afternoon: 'Nachmittag',
              evening: 'Abend',
              night: 'Nacht',
            },
            wide: {
              am: 'vormittags',
              pm: 'nachmittags',
              midnight: 'Mitternacht',
              noon: 'Mittag',
              morning: 'Morgen',
              afternoon: 'Nachmittag',
              evening: 'Abend',
              night: 'Nacht',
            },
          },
          defaultWidth: 'wide',
          formattingValues: {
            narrow: {
              am: 'vm.',
              pm: 'nm.',
              midnight: 'Mitternacht',
              noon: 'Mittag',
              morning: 'morgens',
              afternoon: 'nachm.',
              evening: 'abends',
              night: 'nachts',
            },
            abbreviated: {
              am: 'vorm.',
              pm: 'nachm.',
              midnight: 'Mitternacht',
              noon: 'Mittag',
              morning: 'morgens',
              afternoon: 'nachmittags',
              evening: 'abends',
              night: 'nachts',
            },
            wide: {
              am: 'vormittags',
              pm: 'nachmittags',
              midnight: 'Mitternacht',
              noon: 'Mittag',
              morning: 'morgens',
              afternoon: 'nachmittags',
              evening: 'abends',
              night: 'nachts',
            },
          },
          defaultFormattingWidth: 'wide',
        }),
      };
      var buildMatchFn = __webpack_require__(
        './node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js'
      );
      const de = {
        code: 'de',
        formatDistance: _lib_formatDistance,
        formatLong: _lib_formatLong,
        formatRelative: _lib_formatRelative,
        localize: _lib_localize,
        match: {
          ordinalNumber: (0,
          __webpack_require__(
            './node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js'
          ).Z)({
            matchPattern: /^(\d+)(\.)?/i,
            parsePattern: /\d+/i,
            valueCallback: function valueCallback(value) {
              return parseInt(value);
            },
          }),
          era: (0, buildMatchFn.Z)({
            matchPatterns: {
              narrow: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
              abbreviated: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
              wide: /^(vor Christus|vor unserer Zeitrechnung|nach Christus|unserer Zeitrechnung)/i,
            },
            defaultMatchWidth: 'wide',
            parsePatterns: { any: [/^v/i, /^n/i] },
            defaultParseWidth: 'any',
          }),
          quarter: (0, buildMatchFn.Z)({
            matchPatterns: {
              narrow: /^[1234]/i,
              abbreviated: /^q[1234]/i,
              wide: /^[1234](\.)? Quartal/i,
            },
            defaultMatchWidth: 'wide',
            parsePatterns: { any: [/1/i, /2/i, /3/i, /4/i] },
            defaultParseWidth: 'any',
            valueCallback: function valueCallback(index) {
              return index + 1;
            },
          }),
          month: (0, buildMatchFn.Z)({
            matchPatterns: {
              narrow: /^[jfmasond]/i,
              abbreviated:
                /^(j[aä]n|feb|mär[z]?|apr|mai|jun[i]?|jul[i]?|aug|sep|okt|nov|dez)\.?/i,
              wide: /^(januar|februar|märz|april|mai|juni|juli|august|september|oktober|november|dezember)/i,
            },
            defaultMatchWidth: 'wide',
            parsePatterns: {
              narrow: [
                /^j/i,
                /^f/i,
                /^m/i,
                /^a/i,
                /^m/i,
                /^j/i,
                /^j/i,
                /^a/i,
                /^s/i,
                /^o/i,
                /^n/i,
                /^d/i,
              ],
              any: [
                /^j[aä]/i,
                /^f/i,
                /^mär/i,
                /^ap/i,
                /^mai/i,
                /^jun/i,
                /^jul/i,
                /^au/i,
                /^s/i,
                /^o/i,
                /^n/i,
                /^d/i,
              ],
            },
            defaultParseWidth: 'any',
          }),
          day: (0, buildMatchFn.Z)({
            matchPatterns: {
              narrow: /^[smdmf]/i,
              short: /^(so|mo|di|mi|do|fr|sa)/i,
              abbreviated: /^(son?|mon?|die?|mit?|don?|fre?|sam?)\.?/i,
              wide: /^(sonntag|montag|dienstag|mittwoch|donnerstag|freitag|samstag)/i,
            },
            defaultMatchWidth: 'wide',
            parsePatterns: {
              any: [/^so/i, /^mo/i, /^di/i, /^mi/i, /^do/i, /^f/i, /^sa/i],
            },
            defaultParseWidth: 'any',
          }),
          dayPeriod: (0, buildMatchFn.Z)({
            matchPatterns: {
              narrow:
                /^(vm\.?|nm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
              abbreviated:
                /^(vorm\.?|nachm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
              wide: /^(vormittags|nachmittags|Mitternacht|Mittag|morgens|nachmittags|abends|nachts)/i,
            },
            defaultMatchWidth: 'wide',
            parsePatterns: {
              any: {
                am: /^v/i,
                pm: /^n/i,
                midnight: /^Mitte/i,
                noon: /^Mitta/i,
                morning: /morgens/i,
                afternoon: /nachmittags/i,
                evening: /abends/i,
                night: /nachts/i,
              },
            },
            defaultParseWidth: 'any',
          }),
        },
        options: { weekStartsOn: 1, firstWeekContainsDate: 4 },
      };
    },
    './node_modules/next/dist/client/add-base-path.js': (
      module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      var process = __webpack_require__('./node_modules/process/browser.js');
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.addBasePath = function addBasePath(path, required) {
          if (process.env.__NEXT_MANUAL_CLIENT_BASE_PATH && !required)
            return path;
          return _normalizeTrailingSlash.normalizePathTrailingSlash(
            _addPathPrefix.addPathPrefix(path, basePath)
          );
        });
      var _addPathPrefix = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js'
        ),
        _normalizeTrailingSlash = __webpack_require__(
          './node_modules/next/dist/client/normalize-trailing-slash.js'
        );
      const basePath = process.env.__NEXT_ROUTER_BASEPATH || '';
      ('function' == typeof exports.default ||
        ('object' == typeof exports.default && null !== exports.default)) &&
        void 0 === exports.default.__esModule &&
        (Object.defineProperty(exports.default, '__esModule', { value: !0 }),
        Object.assign(exports.default, exports),
        (module.exports = exports.default));
    },
    './node_modules/next/dist/client/add-locale.js': (
      module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      var process = __webpack_require__('./node_modules/process/browser.js');
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.addLocale = void 0);
      var _normalizeTrailingSlash = __webpack_require__(
        './node_modules/next/dist/client/normalize-trailing-slash.js'
      );
      (exports.addLocale = (path, ...args) =>
        process.env.__NEXT_I18N_SUPPORT
          ? _normalizeTrailingSlash.normalizePathTrailingSlash(
              __webpack_require__(
                './node_modules/next/dist/shared/lib/router/utils/add-locale.js'
              ).addLocale(path, ...args)
            )
          : path),
        ('function' == typeof exports.default ||
          ('object' == typeof exports.default && null !== exports.default)) &&
          void 0 === exports.default.__esModule &&
          (Object.defineProperty(exports.default, '__esModule', { value: !0 }),
          Object.assign(exports.default, exports),
          (module.exports = exports.default));
    },
    './node_modules/next/dist/client/detect-domain-locale.js': (
      module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      var process = __webpack_require__('./node_modules/process/browser.js');
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.detectDomainLocale = void 0);
      (exports.detectDomainLocale = (...args) => {
        if (process.env.__NEXT_I18N_SUPPORT)
          return __webpack_require__(
            './node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js'
          ).D(...args);
      }),
        ('function' == typeof exports.default ||
          ('object' == typeof exports.default && null !== exports.default)) &&
          void 0 === exports.default.__esModule &&
          (Object.defineProperty(exports.default, '__esModule', { value: !0 }),
          Object.assign(exports.default, exports),
          (module.exports = exports.default));
    },
    './node_modules/next/dist/client/get-domain-locale.js': (
      module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      var process = __webpack_require__('./node_modules/process/browser.js');
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.getDomainLocale = function getDomainLocale(
          path,
          locale,
          locales,
          domainLocales
        ) {
          if (process.env.__NEXT_I18N_SUPPORT) {
            const normalizeLocalePath = __webpack_require__(
                './node_modules/next/dist/client/normalize-locale-path.js'
              ).normalizeLocalePath,
              detectDomainLocale = __webpack_require__(
                './node_modules/next/dist/client/detect-domain-locale.js'
              ).detectDomainLocale,
              target =
                locale || normalizeLocalePath(path, locales).detectedLocale,
              domain = detectDomainLocale(domainLocales, void 0, target);
            if (domain) {
              const proto = `http${domain.http ? '' : 's'}://`,
                finalLocale =
                  target === domain.defaultLocale ? '' : `/${target}`;
              return `${proto}${domain.domain}${basePath}${finalLocale}${path}`;
            }
            return !1;
          }
          return !1;
        });
      const basePath = process.env.__NEXT_ROUTER_BASEPATH || '';
      ('function' == typeof exports.default ||
        ('object' == typeof exports.default && null !== exports.default)) &&
        void 0 === exports.default.__esModule &&
        (Object.defineProperty(exports.default, '__esModule', { value: !0 }),
        Object.assign(exports.default, exports),
        (module.exports = exports.default));
    },
    './node_modules/next/dist/client/has-base-path.js': (
      module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      var process = __webpack_require__('./node_modules/process/browser.js');
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.hasBasePath = function hasBasePath(path) {
          return _pathHasPrefix.pathHasPrefix(path, basePath);
        });
      var _pathHasPrefix = __webpack_require__(
        './node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js'
      );
      const basePath = process.env.__NEXT_ROUTER_BASEPATH || '';
      ('function' == typeof exports.default ||
        ('object' == typeof exports.default && null !== exports.default)) &&
        void 0 === exports.default.__esModule &&
        (Object.defineProperty(exports.default, '__esModule', { value: !0 }),
        Object.assign(exports.default, exports),
        (module.exports = exports.default));
    },
    './node_modules/next/dist/client/link.js': (
      module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.default = void 0);
      var _interop_require_default = __webpack_require__(
          './node_modules/@swc/helpers/lib/_interop_require_default.js'
        ).Z,
        _object_without_properties_loose = __webpack_require__(
          './node_modules/@swc/helpers/lib/_object_without_properties_loose.js'
        ).Z,
        _react = _interop_require_default(
          __webpack_require__('./node_modules/react/index.js')
        ),
        _router = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/router.js'
        ),
        _formatUrl = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/format-url.js'
        ),
        _addLocale = __webpack_require__(
          './node_modules/next/dist/client/add-locale.js'
        ),
        _routerContext = __webpack_require__(
          './node_modules/next/dist/shared/lib/router-context.js'
        ),
        _appRouterContext = __webpack_require__(
          './node_modules/next/dist/shared/lib/app-router-context.js'
        ),
        _useIntersection = __webpack_require__(
          './node_modules/next/dist/client/use-intersection.js'
        ),
        _getDomainLocale = __webpack_require__(
          './node_modules/next/dist/client/get-domain-locale.js'
        ),
        _addBasePath = __webpack_require__(
          './node_modules/next/dist/client/add-base-path.js'
        );
      const prefetched = new Set();
      function prefetch(router, href, as, options) {
        if ('undefined' != typeof window && _router.isLocalURL(href)) {
          if (!options.bypassPrefetchedCheck) {
            const prefetchedKey =
              href +
              '%' +
              as +
              '%' +
              (void 0 !== options.locale
                ? options.locale
                : 'locale' in router
                ? router.locale
                : void 0);
            if (prefetched.has(prefetchedKey)) return;
            prefetched.add(prefetchedKey);
          }
          Promise.resolve(router.prefetch(href, as, options)).catch((err) => {
            0;
          });
        }
      }
      function formatStringOrUrl(urlObjOrString) {
        return 'string' == typeof urlObjOrString
          ? urlObjOrString
          : _formatUrl.formatUrl(urlObjOrString);
      }
      var _default = _react.default.forwardRef(function LinkComponent(
        props,
        forwardedRef
      ) {
        let children;
        const {
            href: hrefProp,
            as: asProp,
            children: childrenProp,
            prefetch: prefetchProp,
            passHref,
            replace,
            shallow,
            scroll,
            locale,
            onClick,
            onMouseEnter: onMouseEnterProp,
            onTouchStart: onTouchStartProp,
            legacyBehavior = !1,
          } = props,
          restProps = _object_without_properties_loose(props, [
            'href',
            'as',
            'children',
            'prefetch',
            'passHref',
            'replace',
            'shallow',
            'scroll',
            'locale',
            'onClick',
            'onMouseEnter',
            'onTouchStart',
            'legacyBehavior',
          ]);
        (children = childrenProp),
          !legacyBehavior ||
            ('string' != typeof children && 'number' != typeof children) ||
            (children = _react.default.createElement('a', null, children));
        const prefetchEnabled = !1 !== prefetchProp,
          pagesRouter = _react.default.useContext(_routerContext.RouterContext),
          appRouter = _react.default.useContext(
            _appRouterContext.AppRouterContext
          ),
          router = null != pagesRouter ? pagesRouter : appRouter,
          isAppRouter = !pagesRouter;
        const { href, as } = _react.default.useMemo(() => {
            if (!pagesRouter) {
              const resolvedHref = formatStringOrUrl(hrefProp);
              return {
                href: resolvedHref,
                as: asProp ? formatStringOrUrl(asProp) : resolvedHref,
              };
            }
            const [resolvedHref, resolvedAs] = _router.resolveHref(
              pagesRouter,
              hrefProp,
              !0
            );
            return {
              href: resolvedHref,
              as: asProp
                ? _router.resolveHref(pagesRouter, asProp)
                : resolvedAs || resolvedHref,
            };
          }, [pagesRouter, hrefProp, asProp]),
          previousHref = _react.default.useRef(href),
          previousAs = _react.default.useRef(as);
        let child;
        if (legacyBehavior) child = _react.default.Children.only(children);
        else;
        const childRef = legacyBehavior
            ? child && 'object' == typeof child && child.ref
            : forwardedRef,
          [setIntersectionRef, isVisible, resetVisible] =
            _useIntersection.useIntersection({ rootMargin: '200px' }),
          setRef = _react.default.useCallback(
            (el) => {
              (previousAs.current === as && previousHref.current === href) ||
                (resetVisible(),
                (previousAs.current = as),
                (previousHref.current = href)),
                setIntersectionRef(el),
                childRef &&
                  ('function' == typeof childRef
                    ? childRef(el)
                    : 'object' == typeof childRef && (childRef.current = el));
            },
            [as, childRef, href, resetVisible, setIntersectionRef]
          );
        _react.default.useEffect(() => {
          router &&
            isVisible &&
            prefetchEnabled &&
            prefetch(router, href, as, { locale });
        }, [
          as,
          href,
          isVisible,
          locale,
          prefetchEnabled,
          null == pagesRouter ? void 0 : pagesRouter.locale,
          router,
        ]);
        const childProps = {
          ref: setRef,
          onClick(e) {
            legacyBehavior || 'function' != typeof onClick || onClick(e),
              legacyBehavior &&
                child.props &&
                'function' == typeof child.props.onClick &&
                child.props.onClick(e),
              router &&
                (e.defaultPrevented ||
                  (function linkClicked(
                    e,
                    router,
                    href,
                    as,
                    replace,
                    shallow,
                    scroll,
                    locale,
                    isAppRouter,
                    prefetchEnabled
                  ) {
                    const { nodeName } = e.currentTarget;
                    if (
                      'A' === nodeName.toUpperCase() &&
                      ((function isModifiedEvent(event) {
                        const { target } = event.currentTarget;
                        return (
                          (target && '_self' !== target) ||
                          event.metaKey ||
                          event.ctrlKey ||
                          event.shiftKey ||
                          event.altKey ||
                          (event.nativeEvent && 2 === event.nativeEvent.which)
                        );
                      })(e) ||
                        !_router.isLocalURL(href))
                    )
                      return;
                    e.preventDefault();
                    const navigate = () => {
                      'beforePopState' in router
                        ? router[replace ? 'replace' : 'push'](href, as, {
                            shallow,
                            locale,
                            scroll,
                          })
                        : router[replace ? 'replace' : 'push'](as || href, {
                            forceOptimisticNavigation: !prefetchEnabled,
                          });
                    };
                    isAppRouter
                      ? _react.default.startTransition(navigate)
                      : navigate();
                  })(
                    e,
                    router,
                    href,
                    as,
                    replace,
                    shallow,
                    scroll,
                    locale,
                    isAppRouter,
                    prefetchEnabled
                  ));
          },
          onMouseEnter(e) {
            legacyBehavior ||
              'function' != typeof onMouseEnterProp ||
              onMouseEnterProp(e),
              legacyBehavior &&
                child.props &&
                'function' == typeof child.props.onMouseEnter &&
                child.props.onMouseEnter(e),
              router &&
                ((!prefetchEnabled && isAppRouter) ||
                  prefetch(router, href, as, {
                    locale,
                    priority: !0,
                    bypassPrefetchedCheck: !0,
                  }));
          },
          onTouchStart(e) {
            legacyBehavior ||
              'function' != typeof onTouchStartProp ||
              onTouchStartProp(e),
              legacyBehavior &&
                child.props &&
                'function' == typeof child.props.onTouchStart &&
                child.props.onTouchStart(e),
              router &&
                ((!prefetchEnabled && isAppRouter) ||
                  prefetch(router, href, as, {
                    locale,
                    priority: !0,
                    bypassPrefetchedCheck: !0,
                  }));
          },
        };
        if (
          !legacyBehavior ||
          passHref ||
          ('a' === child.type && !('href' in child.props))
        ) {
          const curLocale =
              void 0 !== locale
                ? locale
                : null == pagesRouter
                ? void 0
                : pagesRouter.locale,
            localeDomain =
              (null == pagesRouter ? void 0 : pagesRouter.isLocaleDomain) &&
              _getDomainLocale.getDomainLocale(
                as,
                curLocale,
                null == pagesRouter ? void 0 : pagesRouter.locales,
                null == pagesRouter ? void 0 : pagesRouter.domainLocales
              );
          childProps.href =
            localeDomain ||
            _addBasePath.addBasePath(
              _addLocale.addLocale(
                as,
                curLocale,
                null == pagesRouter ? void 0 : pagesRouter.defaultLocale
              )
            );
        }
        return legacyBehavior
          ? _react.default.cloneElement(child, childProps)
          : _react.default.createElement(
              'a',
              Object.assign({}, restProps, childProps),
              children
            );
      });
      (exports.default = _default),
        ('function' == typeof exports.default ||
          ('object' == typeof exports.default && null !== exports.default)) &&
          void 0 === exports.default.__esModule &&
          (Object.defineProperty(exports.default, '__esModule', { value: !0 }),
          Object.assign(exports.default, exports),
          (module.exports = exports.default));
    },
    './node_modules/next/dist/client/normalize-locale-path.js': (
      module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      var process = __webpack_require__('./node_modules/process/browser.js');
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.normalizeLocalePath = void 0);
      (exports.normalizeLocalePath = (pathname, locales) =>
        process.env.__NEXT_I18N_SUPPORT
          ? __webpack_require__(
              './node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js'
            ).normalizeLocalePath(pathname, locales)
          : { pathname, detectedLocale: void 0 }),
        ('function' == typeof exports.default ||
          ('object' == typeof exports.default && null !== exports.default)) &&
          void 0 === exports.default.__esModule &&
          (Object.defineProperty(exports.default, '__esModule', { value: !0 }),
          Object.assign(exports.default, exports),
          (module.exports = exports.default));
    },
    './node_modules/next/dist/client/remove-base-path.js': (
      module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      var process = __webpack_require__('./node_modules/process/browser.js');
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.removeBasePath = function removeBasePath(path) {
          if (
            process.env.__NEXT_MANUAL_CLIENT_BASE_PATH &&
            !_hasBasePath.hasBasePath(path)
          )
            return path;
          (path = path.slice(basePath.length)).startsWith('/') ||
            (path = `/${path}`);
          return path;
        });
      var _hasBasePath = __webpack_require__(
        './node_modules/next/dist/client/has-base-path.js'
      );
      const basePath = process.env.__NEXT_ROUTER_BASEPATH || '';
      ('function' == typeof exports.default ||
        ('object' == typeof exports.default && null !== exports.default)) &&
        void 0 === exports.default.__esModule &&
        (Object.defineProperty(exports.default, '__esModule', { value: !0 }),
        Object.assign(exports.default, exports),
        (module.exports = exports.default));
    },
    './node_modules/next/dist/client/remove-locale.js': (
      module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      var process = __webpack_require__('./node_modules/process/browser.js');
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.removeLocale = function removeLocale(path, locale) {
          if (process.env.__NEXT_I18N_SUPPORT) {
            const { pathname } = _parsePath.parsePath(path),
              pathLower = pathname.toLowerCase(),
              localeLower = null == locale ? void 0 : locale.toLowerCase();
            return locale &&
              (pathLower.startsWith(`/${localeLower}/`) ||
                pathLower === `/${localeLower}`)
              ? `${
                  pathname.length === locale.length + 1 ? '/' : ''
                }${path.slice(locale.length + 1)}`
              : path;
          }
          return path;
        });
      var _parsePath = __webpack_require__(
        './node_modules/next/dist/shared/lib/router/utils/parse-path.js'
      );
      ('function' == typeof exports.default ||
        ('object' == typeof exports.default && null !== exports.default)) &&
        void 0 === exports.default.__esModule &&
        (Object.defineProperty(exports.default, '__esModule', { value: !0 }),
        Object.assign(exports.default, exports),
        (module.exports = exports.default));
    },
    './node_modules/next/dist/client/route-loader.js': (
      module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      var process = __webpack_require__('./node_modules/process/browser.js');
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.markAssetError = markAssetError),
        (exports.isAssetError = function isAssetError(err) {
          return err && ASSET_LOAD_ERROR in err;
        }),
        (exports.getClientBuildManifest = getClientBuildManifest),
        (exports.createRouteLoader = function createRouteLoader(assetPrefix) {
          const entrypoints = new Map(),
            loadedScripts = new Map(),
            styleSheets = new Map(),
            routes = new Map();
          function maybeExecuteScript(src) {
            {
              let prom = loadedScripts.get(src.toString());
              return (
                prom ||
                (document.querySelector(`script[src^="${src}"]`)
                  ? Promise.resolve()
                  : (loadedScripts.set(
                      src.toString(),
                      (prom = (function appendScript(src, script) {
                        return new Promise((resolve, reject) => {
                          ((script = document.createElement('script')).onload =
                            resolve),
                            (script.onerror = () =>
                              reject(
                                markAssetError(
                                  new Error(`Failed to load script: ${src}`)
                                )
                              )),
                            (script.crossOrigin =
                              process.env.__NEXT_CROSS_ORIGIN),
                            (script.src = src),
                            document.body.appendChild(script);
                        });
                      })(src))
                    ),
                    prom))
              );
            }
          }
          function fetchStyleSheet(href) {
            let prom = styleSheets.get(href);
            return (
              prom ||
              (styleSheets.set(
                href,
                (prom = fetch(href)
                  .then((res) => {
                    if (!res.ok)
                      throw new Error(`Failed to load stylesheet: ${href}`);
                    return res.text().then((text) => ({ href, content: text }));
                  })
                  .catch((err) => {
                    throw markAssetError(err);
                  }))
              ),
              prom)
            );
          }
          return {
            whenEntrypoint: (route) => withFuture(route, entrypoints),
            onEntrypoint(route, execute) {
              (execute
                ? Promise.resolve()
                    .then(() => execute())
                    .then(
                      (exports) => ({
                        component: (exports && exports.default) || exports,
                        exports,
                      }),
                      (err) => ({ error: err })
                    )
                : Promise.resolve(void 0)
              ).then((input) => {
                const old = entrypoints.get(route);
                old && 'resolve' in old
                  ? input && (entrypoints.set(route, input), old.resolve(input))
                  : (input
                      ? entrypoints.set(route, input)
                      : entrypoints.delete(route),
                    routes.delete(route));
              });
            },
            loadRoute(route, prefetch) {
              return withFuture(route, routes, () =>
                resolvePromiseWithTimeout(
                  getFilesForRoute(assetPrefix, route)
                    .then(({ scripts, css }) =>
                      Promise.all([
                        entrypoints.has(route)
                          ? []
                          : Promise.all(scripts.map(maybeExecuteScript)),
                        Promise.all(css.map(fetchStyleSheet)),
                      ])
                    )
                    .then((res) =>
                      this.whenEntrypoint(route).then((entrypoint) => ({
                        entrypoint,
                        styles: res[1],
                      }))
                    ),
                  MS_MAX_IDLE_DELAY,
                  markAssetError(
                    new Error(`Route did not complete loading: ${route}`)
                  )
                )
                  .then(({ entrypoint, styles }) => {
                    const res = Object.assign({ styles }, entrypoint);
                    return 'error' in entrypoint ? entrypoint : res;
                  })
                  .catch((err) => {
                    if (prefetch) throw err;
                    return { error: err };
                  })
                  .finally(() => {})
              );
            },
            prefetch(route) {
              let cn;
              return (cn = navigator.connection) &&
                (cn.saveData || /2g/.test(cn.effectiveType))
                ? Promise.resolve()
                : getFilesForRoute(assetPrefix, route)
                    .then((output) =>
                      Promise.all(
                        canPrefetch
                          ? output.scripts.map((script) =>
                              (function prefetchViaDom(href, as, link) {
                                return new Promise((resolve, reject) => {
                                  const selector = `\n      link[rel="prefetch"][href^="${href}"],\n      link[rel="preload"][href^="${href}"],\n      script[src^="${href}"]`;
                                  if (document.querySelector(selector))
                                    return resolve();
                                  (link = document.createElement('link')),
                                    as && (link.as = as),
                                    (link.rel = 'prefetch'),
                                    (link.crossOrigin =
                                      process.env.__NEXT_CROSS_ORIGIN),
                                    (link.onload = resolve),
                                    (link.onerror = () =>
                                      reject(
                                        markAssetError(
                                          new Error(
                                            `Failed to prefetch: ${href}`
                                          )
                                        )
                                      )),
                                    (link.href = href),
                                    document.head.appendChild(link);
                                });
                              })(script.toString(), 'script')
                            )
                          : []
                      )
                    )
                    .then(() => {
                      _requestIdleCallback.requestIdleCallback(() =>
                        this.loadRoute(route, !0).catch(() => {})
                      );
                    })
                    .catch(() => {});
            },
          };
        });
      (0,
      __webpack_require__(
        './node_modules/@swc/helpers/lib/_interop_require_default.js'
      ).Z)(
        __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js'
        )
      );
      var _trustedTypes = __webpack_require__(
          './node_modules/next/dist/client/trusted-types.js'
        ),
        _requestIdleCallback = __webpack_require__(
          './node_modules/next/dist/client/request-idle-callback.js'
        );
      const MS_MAX_IDLE_DELAY = 3800;
      function withFuture(key, map, generator) {
        let resolver,
          entry = map.get(key);
        if (entry)
          return 'future' in entry ? entry.future : Promise.resolve(entry);
        const prom = new Promise((resolve) => {
          resolver = resolve;
        });
        return (
          map.set(key, (entry = { resolve: resolver, future: prom })),
          generator
            ? generator()
                .then((value) => (resolver(value), value))
                .catch((err) => {
                  throw (map.delete(key), err);
                })
            : prom
        );
      }
      const ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR');
      function markAssetError(err) {
        return Object.defineProperty(err, ASSET_LOAD_ERROR, {});
      }
      const canPrefetch = (function hasPrefetch(link) {
        try {
          return (
            (link = document.createElement('link')),
            (!!window.MSInputMethodContext && !!document.documentMode) ||
              link.relList.supports('prefetch')
          );
        } catch (e) {
          return !1;
        }
      })();
      function resolvePromiseWithTimeout(p, ms, err) {
        return new Promise((resolve, reject) => {
          let cancelled = !1;
          p
            .then((r) => {
              (cancelled = !0), resolve(r);
            })
            .catch(reject),
            _requestIdleCallback.requestIdleCallback(() =>
              setTimeout(() => {
                cancelled || reject(err);
              }, ms)
            );
        });
      }
      function getClientBuildManifest() {
        if (self.__BUILD_MANIFEST)
          return Promise.resolve(self.__BUILD_MANIFEST);
        return resolvePromiseWithTimeout(
          new Promise((resolve) => {
            const cb = self.__BUILD_MANIFEST_CB;
            self.__BUILD_MANIFEST_CB = () => {
              resolve(self.__BUILD_MANIFEST), cb && cb();
            };
          }),
          MS_MAX_IDLE_DELAY,
          markAssetError(new Error('Failed to load client build manifest'))
        );
      }
      function getFilesForRoute(assetPrefix, route) {
        return getClientBuildManifest().then((manifest) => {
          if (!(route in manifest))
            throw markAssetError(new Error(`Failed to lookup route: ${route}`));
          const allFiles = manifest[route].map(
            (entry) => assetPrefix + '/_next/' + encodeURI(entry)
          );
          return {
            scripts: allFiles
              .filter((v) => v.endsWith('.js'))
              .map((v) => _trustedTypes.__unsafeCreateTrustedScriptURL(v)),
            css: allFiles.filter((v) => v.endsWith('.css')),
          };
        });
      }
      ('function' == typeof exports.default ||
        ('object' == typeof exports.default && null !== exports.default)) &&
        void 0 === exports.default.__esModule &&
        (Object.defineProperty(exports.default, '__esModule', { value: !0 }),
        Object.assign(exports.default, exports),
        (module.exports = exports.default));
    },
    './node_modules/next/dist/client/script.js': (
      module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.handleClientScriptLoad = handleClientScriptLoad),
        (exports.initScriptLoader = function initScriptLoader(
          scriptLoaderItems
        ) {
          scriptLoaderItems.forEach(handleClientScriptLoad),
            (function addBeforeInteractiveToCache() {
              [
                ...document.querySelectorAll(
                  '[data-nscript="beforeInteractive"]'
                ),
                ...document.querySelectorAll(
                  '[data-nscript="beforePageRender"]'
                ),
              ].forEach((script) => {
                const cacheKey = script.id || script.getAttribute('src');
                LoadCache.add(cacheKey);
              });
            })();
        }),
        (exports.default = void 0);
      var _extends = __webpack_require__(
          './node_modules/@swc/helpers/lib/_extends.js'
        ).Z,
        _interop_require_default = __webpack_require__(
          './node_modules/@swc/helpers/lib/_interop_require_default.js'
        ).Z,
        _interop_require_wildcard = __webpack_require__(
          './node_modules/@swc/helpers/lib/_interop_require_wildcard.js'
        ).Z,
        _object_without_properties_loose = __webpack_require__(
          './node_modules/@swc/helpers/lib/_object_without_properties_loose.js'
        ).Z,
        _reactDom = _interop_require_default(
          __webpack_require__('./node_modules/react-dom/index.js')
        ),
        _react = _interop_require_wildcard(
          __webpack_require__('./node_modules/react/index.js')
        ),
        _headManagerContext = __webpack_require__(
          './node_modules/next/dist/shared/lib/head-manager-context.js'
        ),
        _headManager = __webpack_require__(
          './node_modules/next/dist/client/head-manager.js'
        ),
        _requestIdleCallback = __webpack_require__(
          './node_modules/next/dist/client/request-idle-callback.js'
        );
      const ScriptCache = new Map(),
        LoadCache = new Set(),
        ignoreProps = [
          'onLoad',
          'onReady',
          'dangerouslySetInnerHTML',
          'children',
          'onError',
          'strategy',
        ],
        loadScript = (props) => {
          const {
              src,
              id,
              onLoad = () => {},
              onReady = null,
              dangerouslySetInnerHTML,
              children = '',
              strategy = 'afterInteractive',
              onError,
            } = props,
            cacheKey = id || src;
          if (cacheKey && LoadCache.has(cacheKey)) return;
          if (ScriptCache.has(src))
            return (
              LoadCache.add(cacheKey),
              void ScriptCache.get(src).then(onLoad, onError)
            );
          const afterLoad = () => {
              onReady && onReady(), LoadCache.add(cacheKey);
            },
            el = document.createElement('script'),
            loadPromise = new Promise((resolve, reject) => {
              el.addEventListener('load', function (e) {
                resolve(), onLoad && onLoad.call(this, e), afterLoad();
              }),
                el.addEventListener('error', function (e) {
                  reject(e);
                });
            }).catch(function (e) {
              onError && onError(e);
            });
          dangerouslySetInnerHTML
            ? ((el.innerHTML = dangerouslySetInnerHTML.__html || ''),
              afterLoad())
            : children
            ? ((el.textContent =
                'string' == typeof children
                  ? children
                  : Array.isArray(children)
                  ? children.join('')
                  : ''),
              afterLoad())
            : src && ((el.src = src), ScriptCache.set(src, loadPromise));
          for (const [k, value] of Object.entries(props)) {
            if (void 0 === value || ignoreProps.includes(k)) continue;
            const attr = _headManager.DOMAttributeNames[k] || k.toLowerCase();
            el.setAttribute(attr, value);
          }
          'worker' === strategy && el.setAttribute('type', 'text/partytown'),
            el.setAttribute('data-nscript', strategy),
            document.body.appendChild(el);
        };
      function handleClientScriptLoad(props) {
        const { strategy = 'afterInteractive' } = props;
        'lazyOnload' === strategy
          ? window.addEventListener('load', () => {
              _requestIdleCallback.requestIdleCallback(() => loadScript(props));
            })
          : loadScript(props);
      }
      function Script(props) {
        const {
            id,
            src = '',
            onLoad = () => {},
            onReady = null,
            strategy = 'afterInteractive',
            onError,
          } = props,
          restProps = _object_without_properties_loose(props, [
            'id',
            'src',
            'onLoad',
            'onReady',
            'strategy',
            'onError',
          ]),
          { updateScripts, scripts, getIsSsr, appDir, nonce } =
            _react.useContext(_headManagerContext.HeadManagerContext),
          hasOnReadyEffectCalled = _react.useRef(!1);
        _react.useEffect(() => {
          const cacheKey = id || src;
          hasOnReadyEffectCalled.current ||
            (onReady && cacheKey && LoadCache.has(cacheKey) && onReady(),
            (hasOnReadyEffectCalled.current = !0));
        }, [onReady, id, src]);
        const hasLoadScriptEffectCalled = _react.useRef(!1);
        if (
          (_react.useEffect(() => {
            hasLoadScriptEffectCalled.current ||
              ('afterInteractive' === strategy
                ? loadScript(props)
                : 'lazyOnload' === strategy &&
                  (function loadLazyScript(props) {
                    'complete' === document.readyState
                      ? _requestIdleCallback.requestIdleCallback(() =>
                          loadScript(props)
                        )
                      : window.addEventListener('load', () => {
                          _requestIdleCallback.requestIdleCallback(() =>
                            loadScript(props)
                          );
                        });
                  })(props),
              (hasLoadScriptEffectCalled.current = !0));
          }, [props, strategy]),
          ('beforeInteractive' !== strategy && 'worker' !== strategy) ||
            (updateScripts
              ? ((scripts[strategy] = (scripts[strategy] || []).concat([
                  _extends({ id, src, onLoad, onReady, onError }, restProps),
                ])),
                updateScripts(scripts))
              : getIsSsr && getIsSsr()
              ? LoadCache.add(id || src)
              : getIsSsr && !getIsSsr() && loadScript(props)),
          appDir)
        ) {
          if ('beforeInteractive' === strategy)
            return src
              ? (_reactDom.default.preload(
                  src,
                  restProps.integrity
                    ? { as: 'script', integrity: restProps.integrity }
                    : { as: 'script' }
                ),
                _react.default.createElement('script', {
                  nonce,
                  dangerouslySetInnerHTML: {
                    __html: `(self.__next_s=self.__next_s||[]).push(${JSON.stringify(
                      [src]
                    )})`,
                  },
                }))
              : (restProps.dangerouslySetInnerHTML &&
                  ((restProps.children =
                    restProps.dangerouslySetInnerHTML.__html),
                  delete restProps.dangerouslySetInnerHTML),
                _react.default.createElement('script', {
                  nonce,
                  dangerouslySetInnerHTML: {
                    __html: `(self.__next_s=self.__next_s||[]).push(${JSON.stringify(
                      [0, _extends({}, restProps)]
                    )})`,
                  },
                }));
          'afterInteractive' === strategy &&
            src &&
            _reactDom.default.preload(
              src,
              restProps.integrity
                ? { as: 'script', integrity: restProps.integrity }
                : { as: 'script' }
            );
        }
        return null;
      }
      Object.defineProperty(Script, '__nextScript', { value: !0 });
      var _default = Script;
      (exports.default = _default),
        ('function' == typeof exports.default ||
          ('object' == typeof exports.default && null !== exports.default)) &&
          void 0 === exports.default.__esModule &&
          (Object.defineProperty(exports.default, '__esModule', { value: !0 }),
          Object.assign(exports.default, exports),
          (module.exports = exports.default));
    },
    './node_modules/next/dist/client/trusted-types.js': (module, exports) => {
      'use strict';
      let policy;
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.__unsafeCreateTrustedScriptURL =
          function __unsafeCreateTrustedScriptURL(url) {
            var ref;
            return (
              (null ==
              (ref = (function getPolicy() {
                var ref;
                void 0 === policy &&
                  'undefined' != typeof window &&
                  (policy =
                    (null == (ref = window.trustedTypes)
                      ? void 0
                      : ref.createPolicy('nextjs', {
                          createHTML: (input) => input,
                          createScript: (input) => input,
                          createScriptURL: (input) => input,
                        })) || null);
                return policy;
              })())
                ? void 0
                : ref.createScriptURL(url)) || url
            );
          }),
        ('function' == typeof exports.default ||
          ('object' == typeof exports.default && null !== exports.default)) &&
          void 0 === exports.default.__esModule &&
          (Object.defineProperty(exports.default, '__esModule', { value: !0 }),
          Object.assign(exports.default, exports),
          (module.exports = exports.default));
    },
    './node_modules/next/dist/compiled/path-to-regexp/index.js': (
      __unused_webpack_module,
      exports
    ) => {
      'use strict';
      function parse(str, options) {
        void 0 === options && (options = {});
        for (
          var tokens = (function lexer(str) {
              for (var tokens = [], i = 0; i < str.length; ) {
                var char = str[i];
                if ('*' !== char && '+' !== char && '?' !== char)
                  if ('\\' !== char)
                    if ('{' !== char)
                      if ('}' !== char)
                        if (':' !== char)
                          if ('(' !== char)
                            tokens.push({
                              type: 'CHAR',
                              index: i,
                              value: str[i++],
                            });
                          else {
                            var count = 1,
                              pattern = '';
                            if ('?' === str[(j = i + 1)])
                              throw new TypeError(
                                'Pattern cannot start with "?" at ' + j
                              );
                            for (; j < str.length; )
                              if ('\\' !== str[j]) {
                                if (')' === str[j]) {
                                  if (0 == --count) {
                                    j++;
                                    break;
                                  }
                                } else if (
                                  '(' === str[j] &&
                                  (count++, '?' !== str[j + 1])
                                )
                                  throw new TypeError(
                                    'Capturing groups are not allowed at ' + j
                                  );
                                pattern += str[j++];
                              } else pattern += str[j++] + str[j++];
                            if (count)
                              throw new TypeError('Unbalanced pattern at ' + i);
                            if (!pattern)
                              throw new TypeError('Missing pattern at ' + i);
                            tokens.push({
                              type: 'PATTERN',
                              index: i,
                              value: pattern,
                            }),
                              (i = j);
                          }
                        else {
                          for (var name = '', j = i + 1; j < str.length; ) {
                            var code = str.charCodeAt(j);
                            if (
                              !(
                                (code >= 48 && code <= 57) ||
                                (code >= 65 && code <= 90) ||
                                (code >= 97 && code <= 122) ||
                                95 === code
                              )
                            )
                              break;
                            name += str[j++];
                          }
                          if (!name)
                            throw new TypeError(
                              'Missing parameter name at ' + i
                            );
                          tokens.push({ type: 'NAME', index: i, value: name }),
                            (i = j);
                        }
                      else
                        tokens.push({
                          type: 'CLOSE',
                          index: i,
                          value: str[i++],
                        });
                    else
                      tokens.push({ type: 'OPEN', index: i, value: str[i++] });
                  else
                    tokens.push({
                      type: 'ESCAPED_CHAR',
                      index: i++,
                      value: str[i++],
                    });
                else
                  tokens.push({ type: 'MODIFIER', index: i, value: str[i++] });
              }
              return tokens.push({ type: 'END', index: i, value: '' }), tokens;
            })(str),
            _a = options.prefixes,
            prefixes = void 0 === _a ? './' : _a,
            defaultPattern =
              '[^' + escapeString(options.delimiter || '/#?') + ']+?',
            result = [],
            key = 0,
            i = 0,
            path = '',
            tryConsume = function (type) {
              if (i < tokens.length && tokens[i].type === type)
                return tokens[i++].value;
            },
            mustConsume = function (type) {
              var value = tryConsume(type);
              if (void 0 !== value) return value;
              var _a = tokens[i],
                nextType = _a.type,
                index = _a.index;
              throw new TypeError(
                'Unexpected ' + nextType + ' at ' + index + ', expected ' + type
              );
            },
            consumeText = function () {
              for (
                var value, result = '';
                (value = tryConsume('CHAR') || tryConsume('ESCAPED_CHAR'));

              )
                result += value;
              return result;
            };
          i < tokens.length;

        ) {
          var char = tryConsume('CHAR'),
            name = tryConsume('NAME'),
            pattern = tryConsume('PATTERN');
          if (name || pattern) {
            var prefix = char || '';
            -1 === prefixes.indexOf(prefix) &&
              ((path += prefix), (prefix = '')),
              path && (result.push(path), (path = '')),
              result.push({
                name: name || key++,
                prefix,
                suffix: '',
                pattern: pattern || defaultPattern,
                modifier: tryConsume('MODIFIER') || '',
              });
          } else {
            var value = char || tryConsume('ESCAPED_CHAR');
            if (value) path += value;
            else if (
              (path && (result.push(path), (path = '')), tryConsume('OPEN'))
            ) {
              prefix = consumeText();
              var name_1 = tryConsume('NAME') || '',
                pattern_1 = tryConsume('PATTERN') || '',
                suffix = consumeText();
              mustConsume('CLOSE'),
                result.push({
                  name: name_1 || (pattern_1 ? key++ : ''),
                  pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
                  prefix,
                  suffix,
                  modifier: tryConsume('MODIFIER') || '',
                });
            } else mustConsume('END');
          }
        }
        return result;
      }
      function tokensToFunction(tokens, options) {
        void 0 === options && (options = {});
        var reFlags = flags(options),
          _a = options.encode,
          encode =
            void 0 === _a
              ? function (x) {
                  return x;
                }
              : _a,
          _b = options.validate,
          validate = void 0 === _b || _b,
          matches = tokens.map(function (token) {
            if ('object' == typeof token)
              return new RegExp('^(?:' + token.pattern + ')$', reFlags);
          });
        return function (data) {
          for (var path = '', i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if ('string' != typeof token) {
              var value = data ? data[token.name] : void 0,
                optional = '?' === token.modifier || '*' === token.modifier,
                repeat = '*' === token.modifier || '+' === token.modifier;
              if (Array.isArray(value)) {
                if (!repeat)
                  throw new TypeError(
                    'Expected "' +
                      token.name +
                      '" to not repeat, but got an array'
                  );
                if (0 === value.length) {
                  if (optional) continue;
                  throw new TypeError(
                    'Expected "' + token.name + '" to not be empty'
                  );
                }
                for (var j = 0; j < value.length; j++) {
                  var segment = encode(value[j], token);
                  if (validate && !matches[i].test(segment))
                    throw new TypeError(
                      'Expected all "' +
                        token.name +
                        '" to match "' +
                        token.pattern +
                        '", but got "' +
                        segment +
                        '"'
                    );
                  path += token.prefix + segment + token.suffix;
                }
              } else if ('string' != typeof value && 'number' != typeof value) {
                if (!optional) {
                  var typeOfMessage = repeat ? 'an array' : 'a string';
                  throw new TypeError(
                    'Expected "' + token.name + '" to be ' + typeOfMessage
                  );
                }
              } else {
                segment = encode(String(value), token);
                if (validate && !matches[i].test(segment))
                  throw new TypeError(
                    'Expected "' +
                      token.name +
                      '" to match "' +
                      token.pattern +
                      '", but got "' +
                      segment +
                      '"'
                  );
                path += token.prefix + segment + token.suffix;
              }
            } else path += token;
          }
          return path;
        };
      }
      function regexpToFunction(re, keys, options) {
        void 0 === options && (options = {});
        var _a = options.decode,
          decode =
            void 0 === _a
              ? function (x) {
                  return x;
                }
              : _a;
        return function (pathname) {
          var m = re.exec(pathname);
          if (!m) return !1;
          for (
            var path = m[0],
              index = m.index,
              params = Object.create(null),
              _loop_1 = function (i) {
                if (void 0 === m[i]) return 'continue';
                var key = keys[i - 1];
                '*' === key.modifier || '+' === key.modifier
                  ? (params[key.name] = m[i]
                      .split(key.prefix + key.suffix)
                      .map(function (value) {
                        return decode(value, key);
                      }))
                  : (params[key.name] = decode(m[i], key));
              },
              i = 1;
            i < m.length;
            i++
          )
            _loop_1(i);
          return { path, index, params };
        };
      }
      function escapeString(str) {
        return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, '\\$1');
      }
      function flags(options) {
        return options && options.sensitive ? '' : 'i';
      }
      function tokensToRegexp(tokens, keys, options) {
        void 0 === options && (options = {});
        for (
          var _a = options.strict,
            strict = void 0 !== _a && _a,
            _b = options.start,
            start = void 0 === _b || _b,
            _c = options.end,
            end = void 0 === _c || _c,
            _d = options.encode,
            encode =
              void 0 === _d
                ? function (x) {
                    return x;
                  }
                : _d,
            endsWith = '[' + escapeString(options.endsWith || '') + ']|$',
            delimiter = '[' + escapeString(options.delimiter || '/#?') + ']',
            route = start ? '^' : '',
            _i = 0,
            tokens_1 = tokens;
          _i < tokens_1.length;
          _i++
        ) {
          var token = tokens_1[_i];
          if ('string' == typeof token) route += escapeString(encode(token));
          else {
            var prefix = escapeString(encode(token.prefix)),
              suffix = escapeString(encode(token.suffix));
            if (token.pattern)
              if ((keys && keys.push(token), prefix || suffix))
                if ('+' === token.modifier || '*' === token.modifier) {
                  var mod = '*' === token.modifier ? '?' : '';
                  route +=
                    '(?:' +
                    prefix +
                    '((?:' +
                    token.pattern +
                    ')(?:' +
                    suffix +
                    prefix +
                    '(?:' +
                    token.pattern +
                    '))*)' +
                    suffix +
                    ')' +
                    mod;
                } else
                  route +=
                    '(?:' +
                    prefix +
                    '(' +
                    token.pattern +
                    ')' +
                    suffix +
                    ')' +
                    token.modifier;
              else route += '(' + token.pattern + ')' + token.modifier;
            else route += '(?:' + prefix + suffix + ')' + token.modifier;
          }
        }
        if (end)
          strict || (route += delimiter + '?'),
            (route += options.endsWith ? '(?=' + endsWith + ')' : '$');
        else {
          var endToken = tokens[tokens.length - 1],
            isEndDelimited =
              'string' == typeof endToken
                ? delimiter.indexOf(endToken[endToken.length - 1]) > -1
                : void 0 === endToken;
          strict || (route += '(?:' + delimiter + '(?=' + endsWith + '))?'),
            isEndDelimited ||
              (route += '(?=' + delimiter + '|' + endsWith + ')');
        }
        return new RegExp(route, flags(options));
      }
      function pathToRegexp(path, keys, options) {
        return path instanceof RegExp
          ? (function regexpToRegexp(path, keys) {
              if (!keys) return path;
              var groups = path.source.match(/\((?!\?)/g);
              if (groups)
                for (var i = 0; i < groups.length; i++)
                  keys.push({
                    name: i,
                    prefix: '',
                    suffix: '',
                    modifier: '',
                    pattern: '',
                  });
              return path;
            })(path, keys)
          : Array.isArray(path)
          ? (function arrayToRegexp(paths, keys, options) {
              var parts = paths.map(function (path) {
                return pathToRegexp(path, keys, options).source;
              });
              return new RegExp('(?:' + parts.join('|') + ')', flags(options));
            })(path, keys, options)
          : (function stringToRegexp(path, keys, options) {
              return tokensToRegexp(parse(path, options), keys, options);
            })(path, keys, options);
      }
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.parse = parse),
        (exports.compile = function compile(str, options) {
          return tokensToFunction(parse(str, options), options);
        }),
        (exports.tokensToFunction = tokensToFunction),
        (exports.match = function match(str, options) {
          var keys = [];
          return regexpToFunction(
            pathToRegexp(str, keys, options),
            keys,
            options
          );
        }),
        (exports.regexpToFunction = regexpToFunction),
        (exports.tokensToRegexp = tokensToRegexp),
        (exports.pathToRegexp = pathToRegexp);
    },
    './node_modules/next/dist/lib/is-error.js': (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.default = isError),
        (exports.getProperError = function getProperError(err) {
          if (isError(err)) return err;
          0;
          return new Error(
            _isPlainObject.isPlainObject(err) ? JSON.stringify(err) : err + ''
          );
        });
      var _isPlainObject = __webpack_require__(
        './node_modules/next/dist/shared/lib/is-plain-object.js'
      );
      function isError(err) {
        return (
          'object' == typeof err &&
          null !== err &&
          'name' in err &&
          'message' in err
        );
      }
    },
    './node_modules/next/dist/shared/lib/escape-regexp.js': (
      __unused_webpack_module,
      exports
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.escapeStringRegexp = function escapeStringRegexp(str) {
          if (reHasRegExp.test(str))
            return str.replace(reReplaceRegExp, '\\$&');
          return str;
        });
      const reHasRegExp = /[|\\{}()[\]^$+*?.-]/,
        reReplaceRegExp = /[|\\{}()[\]^$+*?.-]/g;
    },
    './node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js': (
      __unused_webpack_module,
      exports
    ) => {
      'use strict';
      exports.D = function detectDomainLocale(
        domainItems,
        hostname,
        detectedLocale
      ) {
        let domainItem;
        if (domainItems) {
          detectedLocale && (detectedLocale = detectedLocale.toLowerCase());
          for (const item of domainItems) {
            var ref, ref1;
            if (
              hostname ===
                (null == (ref = item.domain)
                  ? void 0
                  : ref.split(':')[0].toLowerCase()) ||
              detectedLocale === item.defaultLocale.toLowerCase() ||
              (null == (ref1 = item.locales)
                ? void 0
                : ref1.some(
                    (locale) => locale.toLowerCase() === detectedLocale
                  ))
            ) {
              domainItem = item;
              break;
            }
          }
        }
        return domainItem;
      };
    },
    './node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js': (
      __unused_webpack_module,
      exports
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.normalizeLocalePath = function normalizeLocalePath(
          pathname,
          locales
        ) {
          let detectedLocale;
          const pathnameParts = pathname.split('/');
          return (
            (locales || []).some(
              (locale) =>
                !(
                  !pathnameParts[1] ||
                  pathnameParts[1].toLowerCase() !== locale.toLowerCase()
                ) &&
                ((detectedLocale = locale),
                pathnameParts.splice(1, 1),
                (pathname = pathnameParts.join('/') || '/'),
                !0)
            ),
            { pathname, detectedLocale }
          );
        });
    },
    './node_modules/next/dist/shared/lib/is-plain-object.js': (
      __unused_webpack_module,
      exports
    ) => {
      'use strict';
      function getObjectClassLabel(value) {
        return Object.prototype.toString.call(value);
      }
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.getObjectClassLabel = getObjectClassLabel),
        (exports.isPlainObject = function isPlainObject(value) {
          if ('[object Object]' !== getObjectClassLabel(value)) return !1;
          const prototype = Object.getPrototypeOf(value);
          return (
            null === prototype || prototype.hasOwnProperty('isPrototypeOf')
          );
        });
    },
    './node_modules/next/dist/shared/lib/mitt.js': (
      __unused_webpack_module,
      exports
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.default = function mitt() {
          const all = Object.create(null);
          return {
            on(type, handler) {
              (all[type] || (all[type] = [])).push(handler);
            },
            off(type, handler) {
              all[type] &&
                all[type].splice(all[type].indexOf(handler) >>> 0, 1);
            },
            emit(type, ...evts) {
              (all[type] || []).slice().map((handler) => {
                handler(...evts);
              });
            },
          };
        });
    },
    './node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js': (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.denormalizePagePath = function denormalizePagePath(page) {
          let _page = _normalizePathSep.normalizePathSep(page);
          return _page.startsWith('/index/') && !_utils.isDynamicRoute(_page)
            ? _page.slice(6)
            : '/index' !== _page
            ? _page
            : '/';
        });
      var _utils = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/index.js'
        ),
        _normalizePathSep = __webpack_require__(
          './node_modules/next/dist/shared/lib/page-path/normalize-path-sep.js'
        );
    },
    './node_modules/next/dist/shared/lib/page-path/normalize-path-sep.js': (
      __unused_webpack_module,
      exports
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.normalizePathSep = function normalizePathSep(path) {
          return path.replace(/\\/g, '/');
        });
    },
    './node_modules/next/dist/shared/lib/router/router.js': (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      var process = __webpack_require__('./node_modules/process/browser.js');
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.matchesMiddleware = matchesMiddleware),
        (exports.isLocalURL = isLocalURL),
        (exports.interpolateAs = interpolateAs),
        (exports.resolveHref = resolveHref),
        (exports.createKey = createKey),
        (exports.default = void 0);
      var _async_to_generator = __webpack_require__(
          './node_modules/@swc/helpers/lib/_async_to_generator.js'
        ).Z,
        _extends = __webpack_require__(
          './node_modules/@swc/helpers/lib/_extends.js'
        ).Z,
        _interop_require_default = __webpack_require__(
          './node_modules/@swc/helpers/lib/_interop_require_default.js'
        ).Z,
        _interop_require_wildcard = __webpack_require__(
          './node_modules/@swc/helpers/lib/_interop_require_wildcard.js'
        ).Z,
        _normalizeTrailingSlash = __webpack_require__(
          './node_modules/next/dist/client/normalize-trailing-slash.js'
        ),
        _removeTrailingSlash = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js'
        ),
        _routeLoader = __webpack_require__(
          './node_modules/next/dist/client/route-loader.js'
        ),
        _script = __webpack_require__(
          './node_modules/next/dist/client/script.js'
        ),
        _isError = _interop_require_wildcard(
          __webpack_require__('./node_modules/next/dist/lib/is-error.js')
        ),
        _denormalizePagePath = __webpack_require__(
          './node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js'
        ),
        _normalizeLocalePath = __webpack_require__(
          './node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js'
        ),
        _mitt = _interop_require_default(
          __webpack_require__('./node_modules/next/dist/shared/lib/mitt.js')
        ),
        _utils = __webpack_require__(
          './node_modules/next/dist/shared/lib/utils.js'
        ),
        _isDynamic = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/is-dynamic.js'
        ),
        _parseRelativeUrl = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js'
        ),
        _querystring = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/querystring.js'
        ),
        _resolveRewrites = _interop_require_default(
          __webpack_require__(
            './node_modules/next/dist/shared/lib/router/utils/resolve-rewrites.js'
          )
        ),
        _routeMatcher = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/route-matcher.js'
        ),
        _routeRegex = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/route-regex.js'
        ),
        _formatUrl = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/format-url.js'
        ),
        _detectDomainLocale = __webpack_require__(
          './node_modules/next/dist/client/detect-domain-locale.js'
        ),
        _parsePath = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/parse-path.js'
        ),
        _addLocale = __webpack_require__(
          './node_modules/next/dist/client/add-locale.js'
        ),
        _removeLocale = __webpack_require__(
          './node_modules/next/dist/client/remove-locale.js'
        ),
        _removeBasePath = __webpack_require__(
          './node_modules/next/dist/client/remove-base-path.js'
        ),
        _addBasePath = __webpack_require__(
          './node_modules/next/dist/client/add-base-path.js'
        ),
        _hasBasePath = __webpack_require__(
          './node_modules/next/dist/client/has-base-path.js'
        ),
        _getNextPathnameInfo = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js'
        ),
        _formatNextPathnameInfo = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js'
        ),
        _compareStates = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/compare-states.js'
        ),
        _isBot = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/is-bot.js'
        );
      function buildCancellationError() {
        return Object.assign(new Error('Route Cancelled'), { cancelled: !0 });
      }
      function matchesMiddleware(options) {
        return _matchesMiddleware.apply(this, arguments);
      }
      function _matchesMiddleware() {
        return (_matchesMiddleware = _async_to_generator(function* (options) {
          const matchers = yield Promise.resolve(
            options.router.pageLoader.getMiddleware()
          );
          if (!matchers) return !1;
          const { pathname: asPathname } = _parsePath.parsePath(options.asPath),
            cleanedAs = _hasBasePath.hasBasePath(asPathname)
              ? _removeBasePath.removeBasePath(asPathname)
              : asPathname,
            asWithBasePathAndLocale = _addBasePath.addBasePath(
              _addLocale.addLocale(cleanedAs, options.locale)
            );
          return matchers.some((m) =>
            new RegExp(m.regexp).test(asWithBasePathAndLocale)
          );
        })).apply(this, arguments);
      }
      function stripOrigin(url) {
        const origin = _utils.getLocationOrigin();
        return url.startsWith(origin) ? url.substring(origin.length) : url;
      }
      function omit(object, keys) {
        const omitted = {};
        return (
          Object.keys(object).forEach((key) => {
            keys.includes(key) || (omitted[key] = object[key]);
          }),
          omitted
        );
      }
      function isLocalURL(url) {
        if (!_utils.isAbsoluteUrl(url)) return !0;
        try {
          const locationOrigin = _utils.getLocationOrigin(),
            resolved = new URL(url, locationOrigin);
          return (
            resolved.origin === locationOrigin &&
            _hasBasePath.hasBasePath(resolved.pathname)
          );
        } catch (_) {
          return !1;
        }
      }
      function interpolateAs(route, asPathname, query) {
        let interpolatedRoute = '';
        const dynamicRegex = _routeRegex.getRouteRegex(route),
          dynamicGroups = dynamicRegex.groups,
          dynamicMatches =
            (asPathname !== route
              ? _routeMatcher.getRouteMatcher(dynamicRegex)(asPathname)
              : '') || query;
        interpolatedRoute = route;
        const params = Object.keys(dynamicGroups);
        return (
          params.every((param) => {
            let value = dynamicMatches[param] || '';
            const { repeat, optional } = dynamicGroups[param];
            let replaced = `[${repeat ? '...' : ''}${param}]`;
            return (
              optional && (replaced = `${value ? '' : '/'}[${replaced}]`),
              repeat && !Array.isArray(value) && (value = [value]),
              (optional || param in dynamicMatches) &&
                (interpolatedRoute =
                  interpolatedRoute.replace(
                    replaced,
                    repeat
                      ? value
                          .map((segment) => encodeURIComponent(segment))
                          .join('/')
                      : encodeURIComponent(value)
                  ) || '/')
            );
          }) || (interpolatedRoute = ''),
          { params, result: interpolatedRoute }
        );
      }
      function resolveHref(router, href, resolveAs) {
        let base,
          urlAsString =
            'string' == typeof href
              ? href
              : _formatUrl.formatWithValidation(href);
        const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\/\//),
          urlAsStringNoProto = urlProtoMatch
            ? urlAsString.slice(urlProtoMatch[0].length)
            : urlAsString;
        if ((urlAsStringNoProto.split('?')[0] || '').match(/(\/\/|\\)/)) {
          console.error(
            `Invalid href passed to next/router: ${urlAsString}, repeated forward-slashes (//) or backslashes \\ are not valid in the href`
          );
          const normalizedUrl =
            _utils.normalizeRepeatedSlashes(urlAsStringNoProto);
          urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl;
        }
        if (!isLocalURL(urlAsString))
          return resolveAs ? [urlAsString] : urlAsString;
        try {
          base = new URL(
            urlAsString.startsWith('#') ? router.asPath : router.pathname,
            'http://n'
          );
        } catch (_) {
          base = new URL('/', 'http://n');
        }
        try {
          const finalUrl = new URL(urlAsString, base);
          finalUrl.pathname =
            _normalizeTrailingSlash.normalizePathTrailingSlash(
              finalUrl.pathname
            );
          let interpolatedAs = '';
          if (
            _isDynamic.isDynamicRoute(finalUrl.pathname) &&
            finalUrl.searchParams &&
            resolveAs
          ) {
            const query = _querystring.searchParamsToUrlQuery(
                finalUrl.searchParams
              ),
              { result, params } = interpolateAs(
                finalUrl.pathname,
                finalUrl.pathname,
                query
              );
            result &&
              (interpolatedAs = _formatUrl.formatWithValidation({
                pathname: result,
                hash: finalUrl.hash,
                query: omit(query, params),
              }));
          }
          const resolvedHref =
            finalUrl.origin === base.origin
              ? finalUrl.href.slice(finalUrl.origin.length)
              : finalUrl.href;
          return resolveAs
            ? [resolvedHref, interpolatedAs || resolvedHref]
            : resolvedHref;
        } catch (_1) {
          return resolveAs ? [urlAsString] : urlAsString;
        }
      }
      function prepareUrlAs(router, url, as) {
        let [resolvedHref, resolvedAs] = resolveHref(router, url, !0);
        const origin = _utils.getLocationOrigin(),
          hrefHadOrigin = resolvedHref.startsWith(origin),
          asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);
        (resolvedHref = stripOrigin(resolvedHref)),
          (resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs);
        const preparedUrl = hrefHadOrigin
            ? resolvedHref
            : _addBasePath.addBasePath(resolvedHref),
          preparedAs = as
            ? stripOrigin(resolveHref(router, as))
            : resolvedAs || resolvedHref;
        return {
          url: preparedUrl,
          as: asHadOrigin ? preparedAs : _addBasePath.addBasePath(preparedAs),
        };
      }
      function resolveDynamicRoute(pathname, pages) {
        const cleanPathname = _removeTrailingSlash.removeTrailingSlash(
          _denormalizePagePath.denormalizePagePath(pathname)
        );
        return '/404' === cleanPathname || '/_error' === cleanPathname
          ? pathname
          : (pages.includes(cleanPathname) ||
              pages.some((page) => {
                if (
                  _isDynamic.isDynamicRoute(page) &&
                  _routeRegex.getRouteRegex(page).re.test(cleanPathname)
                )
                  return (pathname = page), !0;
              }),
            _removeTrailingSlash.removeTrailingSlash(pathname));
      }
      function withMiddlewareEffects(options) {
        return matchesMiddleware(options).then((matches) =>
          matches && options.fetchData
            ? options
                .fetchData()
                .then((data) =>
                  (function getMiddlewareData(source, response, options) {
                    const nextConfig = {
                        basePath: options.router.basePath,
                        i18n: { locales: options.router.locales },
                        trailingSlash: Boolean(
                          process.env.__NEXT_TRAILING_SLASH
                        ),
                      },
                      rewriteHeader = response.headers.get('x-nextjs-rewrite');
                    let rewriteTarget =
                      rewriteHeader ||
                      response.headers.get('x-nextjs-matched-path');
                    const matchedPath = response.headers.get('x-matched-path');
                    if (
                      (!matchedPath ||
                        rewriteTarget ||
                        matchedPath.includes('__next_data_catchall') ||
                        matchedPath.includes('/_error') ||
                        matchedPath.includes('/404') ||
                        (rewriteTarget = matchedPath),
                      rewriteTarget)
                    ) {
                      if (rewriteTarget.startsWith('/')) {
                        const parsedRewriteTarget =
                            _parseRelativeUrl.parseRelativeUrl(rewriteTarget),
                          pathnameInfo =
                            _getNextPathnameInfo.getNextPathnameInfo(
                              parsedRewriteTarget.pathname,
                              { nextConfig, parseData: !0 }
                            );
                        let fsPathname =
                          _removeTrailingSlash.removeTrailingSlash(
                            pathnameInfo.pathname
                          );
                        return Promise.all([
                          options.router.pageLoader.getPageList(),
                          _routeLoader.getClientBuildManifest(),
                        ]).then(([pages, { __rewrites: rewrites }]) => {
                          let as = _addLocale.addLocale(
                            pathnameInfo.pathname,
                            pathnameInfo.locale
                          );
                          if (
                            _isDynamic.isDynamicRoute(as) ||
                            (!rewriteHeader &&
                              pages.includes(
                                _normalizeLocalePath.normalizeLocalePath(
                                  _removeBasePath.removeBasePath(as),
                                  options.router.locales
                                ).pathname
                              ))
                          ) {
                            const parsedSource =
                              _getNextPathnameInfo.getNextPathnameInfo(
                                _parseRelativeUrl.parseRelativeUrl(source)
                                  .pathname,
                                { parseData: !0 }
                              );
                            (as = _addBasePath.addBasePath(
                              parsedSource.pathname
                            )),
                              (parsedRewriteTarget.pathname = as);
                          }
                          if (process.env.__NEXT_HAS_REWRITES) {
                            const result = _resolveRewrites.default(
                              as,
                              pages,
                              rewrites,
                              parsedRewriteTarget.query,
                              (path) => resolveDynamicRoute(path, pages),
                              options.router.locales
                            );
                            result.matchedPage &&
                              ((parsedRewriteTarget.pathname =
                                result.parsedAs.pathname),
                              (as = parsedRewriteTarget.pathname),
                              Object.assign(
                                parsedRewriteTarget.query,
                                result.parsedAs.query
                              ));
                          } else if (!pages.includes(fsPathname)) {
                            const resolvedPathname = resolveDynamicRoute(
                              fsPathname,
                              pages
                            );
                            resolvedPathname !== fsPathname &&
                              (fsPathname = resolvedPathname);
                          }
                          const resolvedHref = pages.includes(fsPathname)
                            ? fsPathname
                            : resolveDynamicRoute(
                                _normalizeLocalePath.normalizeLocalePath(
                                  _removeBasePath.removeBasePath(
                                    parsedRewriteTarget.pathname
                                  ),
                                  options.router.locales
                                ).pathname,
                                pages
                              );
                          if (_isDynamic.isDynamicRoute(resolvedHref)) {
                            const matches = _routeMatcher.getRouteMatcher(
                              _routeRegex.getRouteRegex(resolvedHref)
                            )(as);
                            Object.assign(
                              parsedRewriteTarget.query,
                              matches || {}
                            );
                          }
                          return {
                            type: 'rewrite',
                            parsedAs: parsedRewriteTarget,
                            resolvedHref,
                          };
                        });
                      }
                      const src = _parsePath.parsePath(source),
                        pathname =
                          _formatNextPathnameInfo.formatNextPathnameInfo(
                            _extends(
                              {},
                              _getNextPathnameInfo.getNextPathnameInfo(
                                src.pathname,
                                { nextConfig, parseData: !0 }
                              ),
                              {
                                defaultLocale: options.router.defaultLocale,
                                buildId: '',
                              }
                            )
                          );
                      return Promise.resolve({
                        type: 'redirect-external',
                        destination: `${pathname}${src.query}${src.hash}`,
                      });
                    }
                    const redirectTarget =
                      response.headers.get('x-nextjs-redirect');
                    if (redirectTarget) {
                      if (redirectTarget.startsWith('/')) {
                        const src = _parsePath.parsePath(redirectTarget),
                          pathname =
                            _formatNextPathnameInfo.formatNextPathnameInfo(
                              _extends(
                                {},
                                _getNextPathnameInfo.getNextPathnameInfo(
                                  src.pathname,
                                  { nextConfig, parseData: !0 }
                                ),
                                {
                                  defaultLocale: options.router.defaultLocale,
                                  buildId: '',
                                }
                              )
                            );
                        return Promise.resolve({
                          type: 'redirect-internal',
                          newAs: `${pathname}${src.query}${src.hash}`,
                          newUrl: `${pathname}${src.query}${src.hash}`,
                        });
                      }
                      return Promise.resolve({
                        type: 'redirect-external',
                        destination: redirectTarget,
                      });
                    }
                    return Promise.resolve({ type: 'next' });
                  })(data.dataHref, data.response, options).then((effect) => ({
                    dataHref: data.dataHref,
                    cacheKey: data.cacheKey,
                    json: data.json,
                    response: data.response,
                    text: data.text,
                    effect,
                  }))
                )
                .catch((_err) => null)
            : null
        );
      }
      const manualScrollRestoration =
          process.env.__NEXT_SCROLL_RESTORATION &&
          'undefined' != typeof window &&
          'scrollRestoration' in window.history &&
          !!(function () {
            try {
              let v = '__next';
              return (
                sessionStorage.setItem(v, v), sessionStorage.removeItem(v), !0
              );
            } catch (n) {}
          })(),
        SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');
      function fetchRetry(url, attempts, options) {
        return fetch(url, {
          credentials: 'same-origin',
          method: options.method || 'GET',
          headers: Object.assign({}, options.headers, { 'x-nextjs-data': '1' }),
        }).then((response) =>
          !response.ok && attempts > 1 && response.status >= 500
            ? fetchRetry(url, attempts - 1, options)
            : response
        );
      }
      function handleSmoothScroll(fn) {
        const htmlElement = document.documentElement,
          existing = htmlElement.style.scrollBehavior;
        (htmlElement.style.scrollBehavior = 'auto'),
          fn(),
          (htmlElement.style.scrollBehavior = existing);
      }
      function tryToParseAsJSON(text) {
        try {
          return JSON.parse(text);
        } catch (error) {
          return null;
        }
      }
      function fetchNextData({
        dataHref,
        inflightCache,
        isPrefetch,
        hasMiddleware,
        isServerRender,
        parseJSON,
        persistCache,
        isBackground,
        unstable_skipClientCache,
      }) {
        const { href: cacheKey } = new URL(dataHref, window.location.href);
        var ref1;
        const getData = (params) =>
          fetchRetry(dataHref, isServerRender ? 3 : 1, {
            headers: Object.assign(
              {},
              isPrefetch ? { purpose: 'prefetch' } : {},
              isPrefetch && hasMiddleware
                ? { 'x-middleware-prefetch': '1' }
                : {}
            ),
            method:
              null != (ref1 = null == params ? void 0 : params.method)
                ? ref1
                : 'GET',
          })
            .then((response) =>
              response.ok &&
              'HEAD' === (null == params ? void 0 : params.method)
                ? { dataHref, response, text: '', json: {}, cacheKey }
                : response.text().then((text) => {
                    if (!response.ok) {
                      if (
                        hasMiddleware &&
                        [301, 302, 307, 308].includes(response.status)
                      )
                        return { dataHref, response, text, json: {}, cacheKey };
                      var ref;
                      if (!hasMiddleware && 404 === response.status)
                        if (
                          null == (ref = tryToParseAsJSON(text))
                            ? void 0
                            : ref.notFound
                        )
                          return {
                            dataHref,
                            json: { notFound: SSG_DATA_NOT_FOUND },
                            response,
                            text,
                            cacheKey,
                          };
                      const error = new Error('Failed to load static props');
                      throw (
                        (isServerRender || _routeLoader.markAssetError(error),
                        error)
                      );
                    }
                    return {
                      dataHref,
                      json: parseJSON ? tryToParseAsJSON(text) : null,
                      response,
                      text,
                      cacheKey,
                    };
                  })
            )
            .then(
              (data) => (
                (persistCache &&
                  'no-cache' !==
                    data.response.headers.get('x-middleware-cache')) ||
                  delete inflightCache[cacheKey],
                data
              )
            )
            .catch((err) => {
              throw (
                (unstable_skipClientCache || delete inflightCache[cacheKey],
                'Failed to fetch' === err.message &&
                  _routeLoader.markAssetError(err),
                err)
              );
            });
        return unstable_skipClientCache && persistCache
          ? getData({}).then(
              (data) => (
                (inflightCache[cacheKey] = Promise.resolve(data)), data
              )
            )
          : void 0 !== inflightCache[cacheKey]
          ? inflightCache[cacheKey]
          : (inflightCache[cacheKey] = getData(
              isBackground ? { method: 'HEAD' } : {}
            ));
      }
      function createKey() {
        return Math.random().toString(36).slice(2, 10);
      }
      function handleHardNavigation({ url, router }) {
        if (
          url ===
          _addBasePath.addBasePath(
            _addLocale.addLocale(router.asPath, router.locale)
          )
        )
          throw new Error(
            `Invariant: attempted to hard navigate to the same URL ${url} ${location.href}`
          );
        window.location.href = url;
      }
      const getCancelledHandler = ({ route, router }) => {
        let cancelled = !1;
        const cancel = (router.clc = () => {
          cancelled = !0;
        });
        return () => {
          if (cancelled) {
            const error = new Error(
              `Abort fetching component for route: "${route}"`
            );
            throw ((error.cancelled = !0), error);
          }
          cancel === router.clc && (router.clc = null);
        };
      };
      class Router {
        reload() {
          window.location.reload();
        }
        back() {
          window.history.back();
        }
        forward() {
          window.history.forward();
        }
        push(url, as, options = {}) {
          if (process.env.__NEXT_SCROLL_RESTORATION && manualScrollRestoration)
            try {
              sessionStorage.setItem(
                '__next_scroll_' + this._key,
                JSON.stringify({ x: self.pageXOffset, y: self.pageYOffset })
              );
            } catch (e) {}
          return (
            ({ url, as } = prepareUrlAs(this, url, as)),
            this.change('pushState', url, as, options)
          );
        }
        replace(url, as, options = {}) {
          return (
            ({ url, as } = prepareUrlAs(this, url, as)),
            this.change('replaceState', url, as, options)
          );
        }
        change(method, url, as, options, forcedScroll) {
          var _this = this;
          return _async_to_generator(function* () {
            if (!isLocalURL(url))
              return handleHardNavigation({ url, router: _this }), !1;
            const isQueryUpdating = options._h;
            let shouldResolveHref =
              isQueryUpdating ||
              options._shouldResolveHref ||
              _parsePath.parsePath(url).pathname ===
                _parsePath.parsePath(as).pathname;
            const nextState = _extends({}, _this.state),
              readyStateChange = !0 !== _this.isReady;
            _this.isReady = !0;
            const isSsr = _this.isSsr;
            if (
              (isQueryUpdating || (_this.isSsr = !1),
              isQueryUpdating && _this.clc)
            )
              return !1;
            const prevLocale = nextState.locale;
            if (process.env.__NEXT_I18N_SUPPORT) {
              (nextState.locale =
                !1 === options.locale
                  ? _this.defaultLocale
                  : options.locale || nextState.locale),
                void 0 === options.locale &&
                  (options.locale = nextState.locale);
              const parsedAs = _parseRelativeUrl.parseRelativeUrl(
                  _hasBasePath.hasBasePath(as)
                    ? _removeBasePath.removeBasePath(as)
                    : as
                ),
                localePathResult = _normalizeLocalePath.normalizeLocalePath(
                  parsedAs.pathname,
                  _this.locales
                );
              localePathResult.detectedLocale &&
                ((nextState.locale = localePathResult.detectedLocale),
                (parsedAs.pathname = _addBasePath.addBasePath(
                  parsedAs.pathname
                )),
                (as = _formatUrl.formatWithValidation(parsedAs)),
                (url = _addBasePath.addBasePath(
                  _normalizeLocalePath.normalizeLocalePath(
                    _hasBasePath.hasBasePath(url)
                      ? _removeBasePath.removeBasePath(url)
                      : url,
                    _this.locales
                  ).pathname
                )));
              let didNavigate = !1;
              var ref;
              if (process.env.__NEXT_I18N_SUPPORT)
                (null == (ref = _this.locales)
                  ? void 0
                  : ref.includes(nextState.locale)) ||
                  ((parsedAs.pathname = _addLocale.addLocale(
                    parsedAs.pathname,
                    nextState.locale
                  )),
                  handleHardNavigation({
                    url: _formatUrl.formatWithValidation(parsedAs),
                    router: _this,
                  }),
                  (didNavigate = !0));
              const detectedDomain = _detectDomainLocale.detectDomainLocale(
                _this.domainLocales,
                void 0,
                nextState.locale
              );
              if (
                process.env.__NEXT_I18N_SUPPORT &&
                !didNavigate &&
                detectedDomain &&
                _this.isLocaleDomain &&
                self.location.hostname !== detectedDomain.domain
              ) {
                const asNoBasePath = _removeBasePath.removeBasePath(as);
                handleHardNavigation({
                  url: `http${detectedDomain.http ? '' : 's'}://${
                    detectedDomain.domain
                  }${_addBasePath.addBasePath(
                    `${
                      nextState.locale === detectedDomain.defaultLocale
                        ? ''
                        : `/${nextState.locale}`
                    }${'/' === asNoBasePath ? '' : asNoBasePath}` || '/'
                  )}`,
                  router: _this,
                }),
                  (didNavigate = !0);
              }
              if (didNavigate) return new Promise(() => {});
            }
            _utils.ST && performance.mark('routeChange');
            const { shallow = !1, scroll = !0 } = options,
              routeProps = { shallow };
            _this._inFlightRoute &&
              _this.clc &&
              (isSsr ||
                Router.events.emit(
                  'routeChangeError',
                  buildCancellationError(),
                  _this._inFlightRoute,
                  routeProps
                ),
              _this.clc(),
              (_this.clc = null)),
              (as = _addBasePath.addBasePath(
                _addLocale.addLocale(
                  _hasBasePath.hasBasePath(as)
                    ? _removeBasePath.removeBasePath(as)
                    : as,
                  options.locale,
                  _this.defaultLocale
                )
              ));
            const cleanedAs = _removeLocale.removeLocale(
              _hasBasePath.hasBasePath(as)
                ? _removeBasePath.removeBasePath(as)
                : as,
              nextState.locale
            );
            _this._inFlightRoute = as;
            const localeChange = prevLocale !== nextState.locale;
            if (
              !isQueryUpdating &&
              _this.onlyAHashChange(cleanedAs) &&
              !localeChange
            ) {
              (nextState.asPath = cleanedAs),
                Router.events.emit('hashChangeStart', as, routeProps),
                _this.changeState(
                  method,
                  url,
                  as,
                  _extends({}, options, { scroll: !1 })
                ),
                scroll && _this.scrollToHash(cleanedAs);
              try {
                yield _this.set(
                  nextState,
                  _this.components[nextState.route],
                  null
                );
              } catch (err) {
                throw (
                  (_isError.default(err) &&
                    err.cancelled &&
                    Router.events.emit(
                      'routeChangeError',
                      err,
                      cleanedAs,
                      routeProps
                    ),
                  err)
                );
              }
              return (
                Router.events.emit('hashChangeComplete', as, routeProps), !0
              );
            }
            let pages,
              rewrites,
              parsed = _parseRelativeUrl.parseRelativeUrl(url),
              { pathname, query } = parsed;
            try {
              [pages, { __rewrites: rewrites }] = yield Promise.all([
                _this.pageLoader.getPageList(),
                _routeLoader.getClientBuildManifest(),
                _this.pageLoader.getMiddleware(),
              ]);
            } catch (err) {
              return handleHardNavigation({ url: as, router: _this }), !1;
            }
            _this.urlIsNew(cleanedAs) ||
              localeChange ||
              (method = 'replaceState');
            let resolvedAs = as;
            pathname = pathname
              ? _removeTrailingSlash.removeTrailingSlash(
                  _removeBasePath.removeBasePath(pathname)
                )
              : pathname;
            let route = _removeTrailingSlash.removeTrailingSlash(pathname);
            const parsedAsPathname =
                as.startsWith('/') &&
                _parseRelativeUrl.parseRelativeUrl(as).pathname,
              isMiddlewareRewrite = !(
                !parsedAsPathname ||
                route === parsedAsPathname ||
                (_isDynamic.isDynamicRoute(route) &&
                  _routeMatcher.getRouteMatcher(
                    _routeRegex.getRouteRegex(route)
                  )(parsedAsPathname))
              ),
              isMiddlewareMatch = yield matchesMiddleware({
                asPath: as,
                locale: nextState.locale,
                router: _this,
              });
            if (
              (options.shallow &&
                isMiddlewareMatch &&
                (pathname = _this.pathname),
              isQueryUpdating && isMiddlewareMatch && (shouldResolveHref = !1),
              shouldResolveHref && '/_error' !== pathname)
            )
              if (
                ((options._shouldResolveHref = !0),
                process.env.__NEXT_HAS_REWRITES && as.startsWith('/'))
              ) {
                const rewritesResult = _resolveRewrites.default(
                  _addBasePath.addBasePath(
                    _addLocale.addLocale(cleanedAs, nextState.locale),
                    !0
                  ),
                  pages,
                  rewrites,
                  query,
                  (p) => resolveDynamicRoute(p, pages),
                  _this.locales
                );
                if (rewritesResult.externalDest)
                  return handleHardNavigation({ url: as, router: _this }), !0;
                isMiddlewareMatch || (resolvedAs = rewritesResult.asPath),
                  rewritesResult.matchedPage &&
                    rewritesResult.resolvedHref &&
                    ((pathname = rewritesResult.resolvedHref),
                    (parsed.pathname = _addBasePath.addBasePath(pathname)),
                    isMiddlewareMatch ||
                      (url = _formatUrl.formatWithValidation(parsed)));
              } else
                (parsed.pathname = resolveDynamicRoute(pathname, pages)),
                  parsed.pathname !== pathname &&
                    ((pathname = parsed.pathname),
                    (parsed.pathname = _addBasePath.addBasePath(pathname)),
                    isMiddlewareMatch ||
                      (url = _formatUrl.formatWithValidation(parsed)));
            if (!isLocalURL(as))
              return handleHardNavigation({ url: as, router: _this }), !1;
            (resolvedAs = _removeLocale.removeLocale(
              _removeBasePath.removeBasePath(resolvedAs),
              nextState.locale
            )),
              (route = _removeTrailingSlash.removeTrailingSlash(pathname));
            let routeMatch = !1;
            if (_isDynamic.isDynamicRoute(route)) {
              const parsedAs = _parseRelativeUrl.parseRelativeUrl(resolvedAs),
                asPathname = parsedAs.pathname,
                routeRegex = _routeRegex.getRouteRegex(route);
              routeMatch =
                _routeMatcher.getRouteMatcher(routeRegex)(asPathname);
              const shouldInterpolate = route === asPathname,
                interpolatedAs = shouldInterpolate
                  ? interpolateAs(route, asPathname, query)
                  : {};
              if (
                !routeMatch ||
                (shouldInterpolate && !interpolatedAs.result)
              ) {
                const missingParams = Object.keys(routeRegex.groups).filter(
                  (param) => !query[param] && !routeRegex.groups[param].optional
                );
                if (missingParams.length > 0 && !isMiddlewareMatch)
                  throw new Error(
                    (shouldInterpolate
                      ? `The provided \`href\` (${url}) value is missing query values (${missingParams.join(
                          ', '
                        )}) to be interpolated properly. `
                      : `The provided \`as\` value (${asPathname}) is incompatible with the \`href\` value (${route}). `) +
                      'Read more: https://nextjs.org/docs/messages/' +
                      (shouldInterpolate
                        ? 'href-interpolation-failed'
                        : 'incompatible-href-as')
                  );
              } else
                shouldInterpolate
                  ? (as = _formatUrl.formatWithValidation(
                      Object.assign({}, parsedAs, {
                        pathname: interpolatedAs.result,
                        query: omit(query, interpolatedAs.params),
                      })
                    ))
                  : Object.assign(query, routeMatch);
            }
            isQueryUpdating ||
              Router.events.emit('routeChangeStart', as, routeProps);
            try {
              var ref2, ref3;
              let routeInfo = yield _this.getRouteInfo({
                route,
                pathname,
                query,
                as,
                resolvedAs,
                routeProps,
                locale: nextState.locale,
                isPreview: nextState.isPreview,
                hasMiddleware: isMiddlewareMatch,
                unstable_skipClientCache: options.unstable_skipClientCache,
                isQueryUpdating: isQueryUpdating && !_this.isFallback,
                isMiddlewareRewrite,
              });
              if ('route' in routeInfo && isMiddlewareMatch) {
                (pathname = routeInfo.route || route),
                  (route = pathname),
                  routeProps.shallow ||
                    (query = Object.assign({}, routeInfo.query || {}, query));
                const cleanedParsedPathname = _hasBasePath.hasBasePath(
                  parsed.pathname
                )
                  ? _removeBasePath.removeBasePath(parsed.pathname)
                  : parsed.pathname;
                if (
                  (routeMatch &&
                    pathname !== cleanedParsedPathname &&
                    Object.keys(routeMatch).forEach((key) => {
                      routeMatch &&
                        query[key] === routeMatch[key] &&
                        delete query[key];
                    }),
                  _isDynamic.isDynamicRoute(pathname))
                ) {
                  let rewriteAs =
                    !routeProps.shallow && routeInfo.resolvedAs
                      ? routeInfo.resolvedAs
                      : _addBasePath.addBasePath(
                          _addLocale.addLocale(
                            new URL(as, location.href).pathname,
                            nextState.locale
                          ),
                          !0
                        );
                  if (
                    (_hasBasePath.hasBasePath(rewriteAs) &&
                      (rewriteAs = _removeBasePath.removeBasePath(rewriteAs)),
                    process.env.__NEXT_I18N_SUPPORT)
                  ) {
                    const localeResult =
                      _normalizeLocalePath.normalizeLocalePath(
                        rewriteAs,
                        _this.locales
                      );
                    (nextState.locale =
                      localeResult.detectedLocale || nextState.locale),
                      (rewriteAs = localeResult.pathname);
                  }
                  const routeRegex = _routeRegex.getRouteRegex(pathname),
                    curRouteMatch = _routeMatcher.getRouteMatcher(routeRegex)(
                      new URL(rewriteAs, location.href).pathname
                    );
                  curRouteMatch && Object.assign(query, curRouteMatch);
                }
              }
              if ('type' in routeInfo)
                return 'redirect-internal' === routeInfo.type
                  ? _this.change(
                      method,
                      routeInfo.newUrl,
                      routeInfo.newAs,
                      options
                    )
                  : (handleHardNavigation({
                      url: routeInfo.destination,
                      router: _this,
                    }),
                    new Promise(() => {}));
              let { error, props, __N_SSG, __N_SSP } = routeInfo;
              const component = routeInfo.Component;
              if (component && component.unstable_scriptLoader) {
                []
                  .concat(component.unstable_scriptLoader())
                  .forEach((script) => {
                    _script.handleClientScriptLoad(script.props);
                  });
              }
              if ((__N_SSG || __N_SSP) && props) {
                if (props.pageProps && props.pageProps.__N_REDIRECT) {
                  options.locale = !1;
                  const destination = props.pageProps.__N_REDIRECT;
                  if (
                    destination.startsWith('/') &&
                    !1 !== props.pageProps.__N_REDIRECT_BASE_PATH
                  ) {
                    const parsedHref =
                      _parseRelativeUrl.parseRelativeUrl(destination);
                    parsedHref.pathname = resolveDynamicRoute(
                      parsedHref.pathname,
                      pages
                    );
                    const { url: newUrl, as: newAs } = prepareUrlAs(
                      _this,
                      destination,
                      destination
                    );
                    return _this.change(method, newUrl, newAs, options);
                  }
                  return (
                    handleHardNavigation({ url: destination, router: _this }),
                    new Promise(() => {})
                  );
                }
                if (
                  ((nextState.isPreview = !!props.__N_PREVIEW),
                  props.notFound === SSG_DATA_NOT_FOUND)
                ) {
                  let notFoundRoute;
                  try {
                    yield _this.fetchComponent('/404'),
                      (notFoundRoute = '/404');
                  } catch (_) {
                    notFoundRoute = '/_error';
                  }
                  if (
                    ((routeInfo = yield _this.getRouteInfo({
                      route: notFoundRoute,
                      pathname: notFoundRoute,
                      query,
                      as,
                      resolvedAs,
                      routeProps: { shallow: !1 },
                      locale: nextState.locale,
                      isPreview: nextState.isPreview,
                    })),
                    'type' in routeInfo)
                  )
                    throw new Error('Unexpected middleware effect on /404');
                }
              }
              var _route;
              Router.events.emit('beforeHistoryChange', as, routeProps),
                _this.changeState(method, url, as, options),
                isQueryUpdating &&
                  '/_error' === pathname &&
                  500 ===
                    (null == (ref2 = self.__NEXT_DATA__.props) ||
                    null == (ref3 = ref2.pageProps)
                      ? void 0
                      : ref3.statusCode) &&
                  (null == props ? void 0 : props.pageProps) &&
                  (props.pageProps.statusCode = 500);
              const isValidShallowRoute =
                options.shallow &&
                nextState.route ===
                  (null != (_route = routeInfo.route) ? _route : route);
              var _scroll;
              const shouldScroll =
                  null != (_scroll = options.scroll)
                    ? _scroll
                    : !options._h && !isValidShallowRoute,
                resetScroll = shouldScroll ? { x: 0, y: 0 } : null,
                upcomingRouterState = _extends({}, nextState, {
                  route,
                  pathname,
                  query,
                  asPath: cleanedAs,
                  isFallback: !1,
                }),
                upcomingScrollState =
                  null != forcedScroll ? forcedScroll : resetScroll;
              if (
                !(
                  options._h &&
                  !upcomingScrollState &&
                  !readyStateChange &&
                  !localeChange &&
                  _compareStates.compareRouterStates(
                    upcomingRouterState,
                    _this.state
                  )
                )
              ) {
                if (
                  (yield _this
                    .set(upcomingRouterState, routeInfo, upcomingScrollState)
                    .catch((e) => {
                      if (!e.cancelled) throw e;
                      error = error || e;
                    }),
                  error)
                )
                  throw (
                    (isQueryUpdating ||
                      Router.events.emit(
                        'routeChangeError',
                        error,
                        cleanedAs,
                        routeProps
                      ),
                    error)
                  );
                process.env.__NEXT_I18N_SUPPORT &&
                  nextState.locale &&
                  (document.documentElement.lang = nextState.locale),
                  isQueryUpdating ||
                    Router.events.emit('routeChangeComplete', as, routeProps);
                shouldScroll && /#.+$/.test(as) && _this.scrollToHash(as);
              }
              return !0;
            } catch (err1) {
              if (_isError.default(err1) && err1.cancelled) return !1;
              throw err1;
            }
          })();
        }
        changeState(method, url, as, options = {}) {
          ('pushState' === method && _utils.getURL() === as) ||
            ((this._shallow = options.shallow),
            window.history[method](
              {
                url,
                as,
                options,
                __N: !0,
                key: (this._key =
                  'pushState' !== method ? this._key : createKey()),
              },
              '',
              as
            ));
        }
        handleRouteInfoError(
          err,
          pathname,
          query,
          as,
          routeProps,
          loadErrorFail
        ) {
          var _this = this;
          return _async_to_generator(function* () {
            if ((console.error(err), err.cancelled)) throw err;
            if (_routeLoader.isAssetError(err) || loadErrorFail)
              throw (
                (Router.events.emit('routeChangeError', err, as, routeProps),
                handleHardNavigation({ url: as, router: _this }),
                buildCancellationError())
              );
            try {
              let props;
              const { page: Component, styleSheets } =
                  yield _this.fetchComponent('/_error'),
                routeInfo = { props, Component, styleSheets, err, error: err };
              if (!routeInfo.props)
                try {
                  routeInfo.props = yield _this.getInitialProps(Component, {
                    err,
                    pathname,
                    query,
                  });
                } catch (gipErr) {
                  console.error(
                    'Error in error page `getInitialProps`: ',
                    gipErr
                  ),
                    (routeInfo.props = {});
                }
              return routeInfo;
            } catch (routeInfoErr) {
              return _this.handleRouteInfoError(
                _isError.default(routeInfoErr)
                  ? routeInfoErr
                  : new Error(routeInfoErr + ''),
                pathname,
                query,
                as,
                routeProps,
                !0
              );
            }
          })();
        }
        getRouteInfo({
          route: requestedRoute,
          pathname,
          query,
          as,
          resolvedAs,
          routeProps,
          locale,
          hasMiddleware,
          isPreview,
          unstable_skipClientCache,
          isQueryUpdating,
          isMiddlewareRewrite,
        }) {
          var _this = this;
          return _async_to_generator(function* () {
            let route = requestedRoute;
            try {
              var ref, ref4, ref5, ref6;
              const handleCancelled = getCancelledHandler({
                route,
                router: _this,
              });
              let existingInfo = _this.components[route];
              if (routeProps.shallow && existingInfo && _this.route === route)
                return existingInfo;
              hasMiddleware && (existingInfo = void 0);
              let cachedRouteInfo =
                existingInfo && !('initial' in existingInfo)
                  ? existingInfo
                  : void 0;
              const isBackground = isQueryUpdating,
                fetchNextDataParams = {
                  dataHref: _this.pageLoader.getDataHref({
                    href: _formatUrl.formatWithValidation({ pathname, query }),
                    skipInterpolation: !0,
                    asPath: resolvedAs,
                    locale,
                  }),
                  hasMiddleware: !0,
                  isServerRender: _this.isSsr,
                  parseJSON: !0,
                  inflightCache: isBackground ? _this.sbc : _this.sdc,
                  persistCache: !isPreview,
                  isPrefetch: !1,
                  unstable_skipClientCache,
                  isBackground,
                },
                data =
                  isQueryUpdating && !isMiddlewareRewrite
                    ? {}
                    : yield withMiddlewareEffects({
                        fetchData: () => fetchNextData(fetchNextDataParams),
                        asPath: resolvedAs,
                        locale,
                        router: _this,
                      }).catch((err) => {
                        if (isQueryUpdating) return {};
                        throw err;
                      });
              if (
                (isQueryUpdating && (data.json = self.__NEXT_DATA__.props),
                handleCancelled(),
                'redirect-internal' ===
                  (null == data || null == (ref = data.effect)
                    ? void 0
                    : ref.type) ||
                  'redirect-external' ===
                    (null == data || null == (ref4 = data.effect)
                      ? void 0
                      : ref4.type))
              )
                return data.effect;
              if (
                'rewrite' ===
                (null == data || null == (ref5 = data.effect)
                  ? void 0
                  : ref5.type)
              ) {
                const resolvedRoute = _removeTrailingSlash.removeTrailingSlash(
                    data.effect.resolvedHref
                  ),
                  pages = yield _this.pageLoader.getPageList();
                if (
                  (!isQueryUpdating || pages.includes(resolvedRoute)) &&
                  ((route = resolvedRoute),
                  (pathname = data.effect.resolvedHref),
                  (query = _extends({}, query, data.effect.parsedAs.query)),
                  (resolvedAs = _removeBasePath.removeBasePath(
                    _normalizeLocalePath.normalizeLocalePath(
                      data.effect.parsedAs.pathname,
                      _this.locales
                    ).pathname
                  )),
                  (existingInfo = _this.components[route]),
                  routeProps.shallow &&
                    existingInfo &&
                    _this.route === route &&
                    !hasMiddleware)
                )
                  return _extends({}, existingInfo, { route });
              }
              if ('/api' === route || route.startsWith('/api/'))
                return (
                  handleHardNavigation({ url: as, router: _this }),
                  new Promise(() => {})
                );
              const routeInfo =
                cachedRouteInfo ||
                (yield _this.fetchComponent(route).then((res) => ({
                  Component: res.page,
                  styleSheets: res.styleSheets,
                  __N_SSG: res.mod.__N_SSG,
                  __N_SSP: res.mod.__N_SSP,
                })));
              0;
              const wasBailedPrefetch =
                  null == data || null == (ref6 = data.response)
                    ? void 0
                    : ref6.headers.get('x-middleware-skip'),
                shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;
              wasBailedPrefetch &&
                delete _this.sdc[null == data ? void 0 : data.dataHref];
              const { props, cacheKey } = yield _this._getData(
                _async_to_generator(function* () {
                  if (shouldFetchData) {
                    const { json, cacheKey: _cacheKey } =
                      (null == data ? void 0 : data.json) && !wasBailedPrefetch
                        ? data
                        : yield fetchNextData({
                            dataHref: (null == data ? void 0 : data.json)
                              ? null == data
                                ? void 0
                                : data.dataHref
                              : _this.pageLoader.getDataHref({
                                  href: _formatUrl.formatWithValidation({
                                    pathname,
                                    query,
                                  }),
                                  asPath: resolvedAs,
                                  locale,
                                }),
                            isServerRender: _this.isSsr,
                            parseJSON: !0,
                            inflightCache: wasBailedPrefetch ? {} : _this.sdc,
                            persistCache: !isPreview,
                            isPrefetch: !1,
                            unstable_skipClientCache,
                          });
                    return { cacheKey: _cacheKey, props: json || {} };
                  }
                  return {
                    headers: {},
                    cacheKey: '',
                    props: yield _this.getInitialProps(routeInfo.Component, {
                      pathname,
                      query,
                      asPath: as,
                      locale,
                      locales: _this.locales,
                      defaultLocale: _this.defaultLocale,
                    }),
                  };
                })
              );
              return (
                routeInfo.__N_SSP &&
                  fetchNextDataParams.dataHref &&
                  delete _this.sdc[cacheKey],
                _this.isPreview ||
                  !routeInfo.__N_SSG ||
                  isQueryUpdating ||
                  fetchNextData(
                    Object.assign({}, fetchNextDataParams, {
                      isBackground: !0,
                      persistCache: !1,
                      inflightCache: _this.sbc,
                    })
                  ).catch(() => {}),
                (props.pageProps = Object.assign({}, props.pageProps)),
                (routeInfo.props = props),
                (routeInfo.route = route),
                (routeInfo.query = query),
                (routeInfo.resolvedAs = resolvedAs),
                (_this.components[route] = routeInfo),
                routeInfo
              );
            } catch (err) {
              return _this.handleRouteInfoError(
                _isError.getProperError(err),
                pathname,
                query,
                as,
                routeProps
              );
            }
          })();
        }
        set(state, data, resetScroll) {
          return (
            (this.state = state),
            this.sub(data, this.components['/_app'].Component, resetScroll)
          );
        }
        beforePopState(cb) {
          this._bps = cb;
        }
        onlyAHashChange(as) {
          if (!this.asPath) return !1;
          const [oldUrlNoHash, oldHash] = this.asPath.split('#'),
            [newUrlNoHash, newHash] = as.split('#');
          return (
            !(
              !newHash ||
              oldUrlNoHash !== newUrlNoHash ||
              oldHash !== newHash
            ) ||
            (oldUrlNoHash === newUrlNoHash && oldHash !== newHash)
          );
        }
        scrollToHash(as) {
          const [, hash = ''] = as.split('#');
          if ('' === hash || 'top' === hash)
            return void handleSmoothScroll(() => window.scrollTo(0, 0));
          const rawHash = decodeURIComponent(hash),
            idEl = document.getElementById(rawHash);
          if (idEl) return void handleSmoothScroll(() => idEl.scrollIntoView());
          const nameEl = document.getElementsByName(rawHash)[0];
          nameEl && handleSmoothScroll(() => nameEl.scrollIntoView());
        }
        urlIsNew(asPath) {
          return this.asPath !== asPath;
        }
        prefetch(url, asPath = url, options = {}) {
          var _this = this;
          return _async_to_generator(function* () {
            if (
              'undefined' != typeof window &&
              _isBot.isBot(window.navigator.userAgent)
            )
              return;
            let parsed = _parseRelativeUrl.parseRelativeUrl(url),
              { pathname, query } = parsed;
            const originalPathname = pathname;
            if (process.env.__NEXT_I18N_SUPPORT && !1 === options.locale) {
              (pathname = _normalizeLocalePath.normalizeLocalePath(
                pathname,
                _this.locales
              ).pathname),
                (parsed.pathname = pathname),
                (url = _formatUrl.formatWithValidation(parsed));
              let parsedAs = _parseRelativeUrl.parseRelativeUrl(asPath);
              const localePathResult = _normalizeLocalePath.normalizeLocalePath(
                parsedAs.pathname,
                _this.locales
              );
              (parsedAs.pathname = localePathResult.pathname),
                (options.locale =
                  localePathResult.detectedLocale || _this.defaultLocale),
                (asPath = _formatUrl.formatWithValidation(parsedAs));
            }
            const pages = yield _this.pageLoader.getPageList();
            let resolvedAs = asPath;
            const locale =
                void 0 !== options.locale
                  ? options.locale || void 0
                  : _this.locale,
              isMiddlewareMatch = yield matchesMiddleware({
                asPath,
                locale,
                router: _this,
              });
            if (process.env.__NEXT_HAS_REWRITES && asPath.startsWith('/')) {
              let rewrites;
              ({ __rewrites: rewrites } =
                yield _routeLoader.getClientBuildManifest());
              const rewritesResult = _resolveRewrites.default(
                _addBasePath.addBasePath(
                  _addLocale.addLocale(asPath, _this.locale),
                  !0
                ),
                pages,
                rewrites,
                parsed.query,
                (p) => resolveDynamicRoute(p, pages),
                _this.locales
              );
              if (rewritesResult.externalDest) return;
              isMiddlewareMatch ||
                (resolvedAs = _removeLocale.removeLocale(
                  _removeBasePath.removeBasePath(rewritesResult.asPath),
                  _this.locale
                )),
                rewritesResult.matchedPage &&
                  rewritesResult.resolvedHref &&
                  ((pathname = rewritesResult.resolvedHref),
                  (parsed.pathname = pathname),
                  isMiddlewareMatch ||
                    (url = _formatUrl.formatWithValidation(parsed)));
            }
            (parsed.pathname = resolveDynamicRoute(parsed.pathname, pages)),
              _isDynamic.isDynamicRoute(parsed.pathname) &&
                ((pathname = parsed.pathname),
                (parsed.pathname = pathname),
                Object.assign(
                  query,
                  _routeMatcher.getRouteMatcher(
                    _routeRegex.getRouteRegex(parsed.pathname)
                  )(_parsePath.parsePath(asPath).pathname) || {}
                ),
                isMiddlewareMatch ||
                  (url = _formatUrl.formatWithValidation(parsed)));
            const data =
              'strict' === process.env.__NEXT_MIDDLEWARE_PREFETCH
                ? {}
                : yield withMiddlewareEffects({
                    fetchData: () =>
                      fetchNextData({
                        dataHref: _this.pageLoader.getDataHref({
                          href: _formatUrl.formatWithValidation({
                            pathname: originalPathname,
                            query,
                          }),
                          skipInterpolation: !0,
                          asPath: resolvedAs,
                          locale,
                        }),
                        hasMiddleware: !0,
                        isServerRender: _this.isSsr,
                        parseJSON: !0,
                        inflightCache: _this.sdc,
                        persistCache: !_this.isPreview,
                        isPrefetch: !0,
                      }),
                    asPath,
                    locale,
                    router: _this,
                  });
            if (
              ('rewrite' === (null == data ? void 0 : data.effect.type) &&
                ((parsed.pathname = data.effect.resolvedHref),
                (pathname = data.effect.resolvedHref),
                (query = _extends({}, query, data.effect.parsedAs.query)),
                (resolvedAs = data.effect.parsedAs.pathname),
                (url = _formatUrl.formatWithValidation(parsed))),
              'redirect-external' ===
                (null == data ? void 0 : data.effect.type))
            )
              return;
            const route = _removeTrailingSlash.removeTrailingSlash(pathname);
            yield Promise.all([
              _this.pageLoader._isSsg(route).then(
                (isSsg) =>
                  !!isSsg &&
                  fetchNextData({
                    dataHref: (null == data ? void 0 : data.json)
                      ? null == data
                        ? void 0
                        : data.dataHref
                      : _this.pageLoader.getDataHref({
                          href: url,
                          asPath: resolvedAs,
                          locale,
                        }),
                    isServerRender: !1,
                    parseJSON: !0,
                    inflightCache: _this.sdc,
                    persistCache: !_this.isPreview,
                    isPrefetch: !0,
                    unstable_skipClientCache:
                      options.unstable_skipClientCache ||
                      (options.priority &&
                        !!process.env.__NEXT_OPTIMISTIC_CLIENT_CACHE),
                  }).then(() => !1)
              ),
              _this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](
                route
              ),
            ]);
          })();
        }
        fetchComponent(route) {
          var _this = this;
          return _async_to_generator(function* () {
            const handleCancelled = getCancelledHandler({
              route,
              router: _this,
            });
            try {
              const componentResult = yield _this.pageLoader.loadPage(route);
              return handleCancelled(), componentResult;
            } catch (err) {
              throw (handleCancelled(), err);
            }
          })();
        }
        _getData(fn) {
          let cancelled = !1;
          const cancel = () => {
            cancelled = !0;
          };
          return (
            (this.clc = cancel),
            fn().then((data) => {
              if ((cancel === this.clc && (this.clc = null), cancelled)) {
                const err = new Error('Loading initial props cancelled');
                throw ((err.cancelled = !0), err);
              }
              return data;
            })
          );
        }
        _getFlightData(dataHref) {
          return fetchNextData({
            dataHref,
            isServerRender: !0,
            parseJSON: !1,
            inflightCache: this.sdc,
            persistCache: !1,
            isPrefetch: !1,
          }).then(({ text }) => ({ data: text }));
        }
        getInitialProps(Component, ctx) {
          const { Component: App } = this.components['/_app'],
            AppTree = this._wrapApp(App);
          return (
            (ctx.AppTree = AppTree),
            _utils.loadGetInitialProps(App, {
              AppTree,
              Component,
              router: this,
              ctx,
            })
          );
        }
        get route() {
          return this.state.route;
        }
        get pathname() {
          return this.state.pathname;
        }
        get query() {
          return this.state.query;
        }
        get asPath() {
          return this.state.asPath;
        }
        get locale() {
          return this.state.locale;
        }
        get isFallback() {
          return this.state.isFallback;
        }
        get isPreview() {
          return this.state.isPreview;
        }
        constructor(
          pathname1,
          query1,
          as1,
          {
            initialProps,
            pageLoader,
            App,
            wrapApp,
            Component,
            err,
            subscription,
            isFallback,
            locale,
            locales,
            defaultLocale,
            domainLocales,
            isPreview,
          }
        ) {
          (this.sdc = {}),
            (this.sbc = {}),
            (this.isFirstPopStateEvent = !0),
            (this._key = createKey()),
            (this.onPopState = (e) => {
              const { isFirstPopStateEvent } = this;
              this.isFirstPopStateEvent = !1;
              const state = e.state;
              if (!state) {
                const { pathname, query } = this;
                return void this.changeState(
                  'replaceState',
                  _formatUrl.formatWithValidation({
                    pathname: _addBasePath.addBasePath(pathname),
                    query,
                  }),
                  _utils.getURL()
                );
              }
              if (state.__NA) return void window.location.reload();
              if (!state.__N) return;
              if (
                isFirstPopStateEvent &&
                this.locale === state.options.locale &&
                state.as === this.asPath
              )
                return;
              let forcedScroll;
              const { url, as, options, key } = state;
              if (
                process.env.__NEXT_SCROLL_RESTORATION &&
                manualScrollRestoration &&
                this._key !== key
              ) {
                try {
                  sessionStorage.setItem(
                    '__next_scroll_' + this._key,
                    JSON.stringify({ x: self.pageXOffset, y: self.pageYOffset })
                  );
                } catch (e) {}
                try {
                  const v = sessionStorage.getItem('__next_scroll_' + key);
                  forcedScroll = JSON.parse(v);
                } catch (e1) {
                  forcedScroll = { x: 0, y: 0 };
                }
              }
              this._key = key;
              const { pathname } = _parseRelativeUrl.parseRelativeUrl(url);
              (this.isSsr &&
                as === _addBasePath.addBasePath(this.asPath) &&
                pathname === _addBasePath.addBasePath(this.pathname)) ||
                (this._bps && !this._bps(state)) ||
                this.change(
                  'replaceState',
                  url,
                  as,
                  Object.assign({}, options, {
                    shallow: options.shallow && this._shallow,
                    locale: options.locale || this.defaultLocale,
                    _h: 0,
                  }),
                  forcedScroll
                );
            });
          const route = _removeTrailingSlash.removeTrailingSlash(pathname1);
          (this.components = {}),
            '/_error' !== pathname1 &&
              (this.components[route] = {
                Component,
                initial: !0,
                props: initialProps,
                err,
                __N_SSG: initialProps && initialProps.__N_SSG,
                __N_SSP: initialProps && initialProps.__N_SSP,
              }),
            (this.components['/_app'] = { Component: App, styleSheets: [] }),
            (this.events = Router.events),
            (this.pageLoader = pageLoader);
          const autoExportDynamic =
            _isDynamic.isDynamicRoute(pathname1) &&
            self.__NEXT_DATA__.autoExport;
          if (
            ((this.basePath = process.env.__NEXT_ROUTER_BASEPATH || ''),
            (this.sub = subscription),
            (this.clc = null),
            (this._wrapApp = wrapApp),
            (this.isSsr = !0),
            (this.isLocaleDomain = !1),
            (this.isReady = !(
              !(
                self.__NEXT_DATA__.gssp ||
                self.__NEXT_DATA__.gip ||
                (self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp)
              ) &&
              (autoExportDynamic ||
                self.location.search ||
                process.env.__NEXT_HAS_REWRITES)
            )),
            process.env.__NEXT_I18N_SUPPORT &&
              ((this.locales = locales),
              (this.defaultLocale = defaultLocale),
              (this.domainLocales = domainLocales),
              (this.isLocaleDomain = !!_detectDomainLocale.detectDomainLocale(
                domainLocales,
                self.location.hostname
              ))),
            (this.state = {
              route,
              pathname: pathname1,
              query: query1,
              asPath: autoExportDynamic ? pathname1 : as1,
              isPreview: !!isPreview,
              locale: process.env.__NEXT_I18N_SUPPORT ? locale : void 0,
              isFallback,
            }),
            (this._initialMatchesMiddlewarePromise = Promise.resolve(!1)),
            'undefined' != typeof window)
          ) {
            if (!as1.startsWith('//')) {
              const options = { locale },
                asPath = _utils.getURL();
              this._initialMatchesMiddlewarePromise = matchesMiddleware({
                router: this,
                locale,
                asPath,
              }).then(
                (matches) => (
                  (options._shouldResolveHref = as1 !== pathname1),
                  this.changeState(
                    'replaceState',
                    matches
                      ? asPath
                      : _formatUrl.formatWithValidation({
                          pathname: _addBasePath.addBasePath(pathname1),
                          query: query1,
                        }),
                    asPath,
                    options
                  ),
                  matches
                )
              );
            }
            window.addEventListener('popstate', this.onPopState),
              process.env.__NEXT_SCROLL_RESTORATION &&
                manualScrollRestoration &&
                (window.history.scrollRestoration = 'manual');
          }
        }
      }
      (Router.events = _mitt.default()), (exports.default = Router);
    },
    './node_modules/next/dist/shared/lib/router/utils/add-locale.js': (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.addLocale = function addLocale(
          path,
          locale,
          defaultLocale,
          ignorePrefix
        ) {
          if (
            locale &&
            locale !== defaultLocale &&
            (ignorePrefix ||
              (!_pathHasPrefix.pathHasPrefix(
                path.toLowerCase(),
                `/${locale.toLowerCase()}`
              ) &&
                !_pathHasPrefix.pathHasPrefix(path.toLowerCase(), '/api')))
          )
            return _addPathPrefix.addPathPrefix(path, `/${locale}`);
          return path;
        });
      var _addPathPrefix = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js'
        ),
        _pathHasPrefix = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js'
        );
    },
    './node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js': (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.addPathPrefix = function addPathPrefix(path, prefix) {
          if (!path.startsWith('/') || !prefix) return path;
          const { pathname, query, hash } = _parsePath.parsePath(path);
          return `${prefix}${pathname}${query}${hash}`;
        });
      var _parsePath = __webpack_require__(
        './node_modules/next/dist/shared/lib/router/utils/parse-path.js'
      );
    },
    './node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js': (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.addPathSuffix = function addPathSuffix(path, suffix) {
          if (!path.startsWith('/') || !suffix) return path;
          const { pathname, query, hash } = _parsePath.parsePath(path);
          return `${pathname}${suffix}${query}${hash}`;
        });
      var _parsePath = __webpack_require__(
        './node_modules/next/dist/shared/lib/router/utils/parse-path.js'
      );
    },
    './node_modules/next/dist/shared/lib/router/utils/compare-states.js': (
      __unused_webpack_module,
      exports
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.compareRouterStates = function compareRouterStates(a, b) {
          const stateKeys = Object.keys(a);
          if (stateKeys.length !== Object.keys(b).length) return !1;
          for (let i = stateKeys.length; i--; ) {
            const key = stateKeys[i];
            if ('query' === key) {
              const queryKeys = Object.keys(a.query);
              if (queryKeys.length !== Object.keys(b.query).length) return !1;
              for (let j = queryKeys.length; j--; ) {
                const queryKey = queryKeys[j];
                if (
                  !b.query.hasOwnProperty(queryKey) ||
                  a.query[queryKey] !== b.query[queryKey]
                )
                  return !1;
              }
            } else if (!b.hasOwnProperty(key) || a[key] !== b[key]) return !1;
          }
          return !0;
        });
    },
    './node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js':
      (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: !0 }),
          (exports.formatNextPathnameInfo = function formatNextPathnameInfo(
            info
          ) {
            let pathname = _addLocale.addLocale(
              info.pathname,
              info.locale,
              info.buildId ? void 0 : info.defaultLocale,
              info.ignorePrefix
            );
            (!info.buildId && info.trailingSlash) ||
              (pathname = _removeTrailingSlash.removeTrailingSlash(pathname));
            info.buildId &&
              (pathname = _addPathSuffix.addPathSuffix(
                _addPathPrefix.addPathPrefix(
                  pathname,
                  `/_next/data/${info.buildId}`
                ),
                '/' === info.pathname ? 'index.json' : '.json'
              ));
            return (
              (pathname = _addPathPrefix.addPathPrefix(
                pathname,
                info.basePath
              )),
              !info.buildId && info.trailingSlash
                ? pathname.endsWith('/')
                  ? pathname
                  : _addPathSuffix.addPathSuffix(pathname, '/')
                : _removeTrailingSlash.removeTrailingSlash(pathname)
            );
          });
        var _removeTrailingSlash = __webpack_require__(
            './node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js'
          ),
          _addPathPrefix = __webpack_require__(
            './node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js'
          ),
          _addPathSuffix = __webpack_require__(
            './node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js'
          ),
          _addLocale = __webpack_require__(
            './node_modules/next/dist/shared/lib/router/utils/add-locale.js'
          );
      },
    './node_modules/next/dist/shared/lib/router/utils/format-url.js': (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.formatUrl = formatUrl),
        (exports.formatWithValidation = function formatWithValidation(url) {
          0;
          return formatUrl(url);
        }),
        (exports.urlObjectKeys = void 0);
      var querystring = (0,
      __webpack_require__(
        './node_modules/@swc/helpers/lib/_interop_require_wildcard.js'
      ).Z)(
        __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/querystring.js'
        )
      );
      const slashedProtocols = /https?|ftp|gopher|file/;
      function formatUrl(urlObj) {
        let { auth, hostname } = urlObj,
          protocol = urlObj.protocol || '',
          pathname = urlObj.pathname || '',
          hash = urlObj.hash || '',
          query = urlObj.query || '',
          host = !1;
        (auth = auth
          ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@'
          : ''),
          urlObj.host
            ? (host = auth + urlObj.host)
            : hostname &&
              ((host =
                auth + (~hostname.indexOf(':') ? `[${hostname}]` : hostname)),
              urlObj.port && (host += ':' + urlObj.port)),
          query &&
            'object' == typeof query &&
            (query = String(querystring.urlQueryToSearchParams(query)));
        let search = urlObj.search || (query && `?${query}`) || '';
        return (
          protocol && !protocol.endsWith(':') && (protocol += ':'),
          urlObj.slashes ||
          ((!protocol || slashedProtocols.test(protocol)) && !1 !== host)
            ? ((host = '//' + (host || '')),
              pathname && '/' !== pathname[0] && (pathname = '/' + pathname))
            : host || (host = ''),
          hash && '#' !== hash[0] && (hash = '#' + hash),
          search && '?' !== search[0] && (search = '?' + search),
          (pathname = pathname.replace(/[?#]/g, encodeURIComponent)),
          (search = search.replace('#', '%23')),
          `${protocol}${host}${pathname}${search}${hash}`
        );
      }
      exports.urlObjectKeys = [
        'auth',
        'hash',
        'host',
        'hostname',
        'href',
        'path',
        'pathname',
        'port',
        'protocol',
        'query',
        'search',
        'slashes',
      ];
    },
    './node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js':
      (__unused_webpack_module, exports) => {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: !0 }),
          (exports.default = function getAssetPathFromRoute(route, ext = '') {
            return (
              ('/' === route
                ? '/index'
                : /^\/index(\/|$)/.test(route)
                ? `/index${route}`
                : `${route}`) + ext
            );
          });
      },
    './node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js':
      (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: !0 }),
          (exports.getNextPathnameInfo = function getNextPathnameInfo(
            pathname,
            options
          ) {
            var _nextConfig;
            const { basePath, i18n, trailingSlash } =
                null != (_nextConfig = options.nextConfig) ? _nextConfig : {},
              info = {
                pathname,
                trailingSlash:
                  '/' !== pathname ? pathname.endsWith('/') : trailingSlash,
              };
            basePath &&
              _pathHasPrefix.pathHasPrefix(info.pathname, basePath) &&
              ((info.pathname = _removePathPrefix.removePathPrefix(
                info.pathname,
                basePath
              )),
              (info.basePath = basePath));
            if (
              !0 === options.parseData &&
              info.pathname.startsWith('/_next/data/') &&
              info.pathname.endsWith('.json')
            ) {
              const paths = info.pathname
                  .replace(/^\/_next\/data\//, '')
                  .replace(/\.json$/, '')
                  .split('/'),
                buildId = paths[0];
              (info.pathname =
                'index' !== paths[1] ? `/${paths.slice(1).join('/')}` : '/'),
                (info.buildId = buildId);
            }
            if (i18n) {
              const pathLocale = _normalizeLocalePath.normalizeLocalePath(
                info.pathname,
                i18n.locales
              );
              (info.locale =
                null == pathLocale ? void 0 : pathLocale.detectedLocale),
                (info.pathname =
                  (null == pathLocale ? void 0 : pathLocale.pathname) ||
                  info.pathname);
            }
            return info;
          });
        var _normalizeLocalePath = __webpack_require__(
            './node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js'
          ),
          _removePathPrefix = __webpack_require__(
            './node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js'
          ),
          _pathHasPrefix = __webpack_require__(
            './node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js'
          );
      },
    './node_modules/next/dist/shared/lib/router/utils/index.js': (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        Object.defineProperty(exports, 'getSortedRoutes', {
          enumerable: !0,
          get: function () {
            return _sortedRoutes.getSortedRoutes;
          },
        }),
        Object.defineProperty(exports, 'isDynamicRoute', {
          enumerable: !0,
          get: function () {
            return _isDynamic.isDynamicRoute;
          },
        });
      var _sortedRoutes = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/sorted-routes.js'
        ),
        _isDynamic = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/is-dynamic.js'
        );
    },
    './node_modules/next/dist/shared/lib/router/utils/is-bot.js': (
      __unused_webpack_module,
      exports
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.isBot = function isBot(userAgent) {
          return /Googlebot|Mediapartners-Google|AdsBot-Google|googleweblight|Storebot-Google|Google-PageRenderer|Bingbot|BingPreview|Slurp|DuckDuckBot|baiduspider|yandex|sogou|LinkedInBot|bitlybot|tumblr|vkShare|quora link preview|facebookexternalhit|facebookcatalog|Twitterbot|applebot|redditbot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|ia_archiver/i.test(
            userAgent
          );
        });
    },
    './node_modules/next/dist/shared/lib/router/utils/is-dynamic.js': (
      __unused_webpack_module,
      exports
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.isDynamicRoute = function isDynamicRoute(route) {
          return TEST_ROUTE.test(route);
        });
      const TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/;
    },
    './node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js': (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.parseRelativeUrl = function parseRelativeUrl(url, base) {
          const globalBase = new URL(
              'undefined' == typeof window
                ? 'http://n'
                : _utils.getLocationOrigin()
            ),
            resolvedBase = base
              ? new URL(base, globalBase)
              : url.startsWith('.')
              ? new URL(
                  'undefined' == typeof window
                    ? 'http://n'
                    : window.location.href
                )
              : globalBase,
            { pathname, searchParams, search, hash, href, origin } = new URL(
              url,
              resolvedBase
            );
          if (origin !== globalBase.origin)
            throw new Error(
              `invariant: invalid relative URL, router received ${url}`
            );
          return {
            pathname,
            query: _querystring.searchParamsToUrlQuery(searchParams),
            search,
            hash,
            href: href.slice(globalBase.origin.length),
          };
        });
      var _utils = __webpack_require__(
          './node_modules/next/dist/shared/lib/utils.js'
        ),
        _querystring = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/querystring.js'
        );
    },
    './node_modules/next/dist/shared/lib/router/utils/parse-url.js': (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.parseUrl = function parseUrl(url) {
          if (url.startsWith('/'))
            return _parseRelativeUrl.parseRelativeUrl(url);
          const parsedURL = new URL(url);
          return {
            hash: parsedURL.hash,
            hostname: parsedURL.hostname,
            href: parsedURL.href,
            pathname: parsedURL.pathname,
            port: parsedURL.port,
            protocol: parsedURL.protocol,
            query: _querystring.searchParamsToUrlQuery(parsedURL.searchParams),
            search: parsedURL.search,
          };
        });
      var _querystring = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/querystring.js'
        ),
        _parseRelativeUrl = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js'
        );
    },
    './node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js': (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.pathHasPrefix = function pathHasPrefix(path, prefix) {
          if ('string' != typeof path) return !1;
          const { pathname } = _parsePath.parsePath(path);
          return pathname === prefix || pathname.startsWith(prefix + '/');
        });
      var _parsePath = __webpack_require__(
        './node_modules/next/dist/shared/lib/router/utils/parse-path.js'
      );
    },
    './node_modules/next/dist/shared/lib/router/utils/path-match.js': (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.getPathMatch = function getPathMatch(path, options) {
          const keys = [],
            regexp = _pathToRegexp.pathToRegexp(path, keys, {
              delimiter: '/',
              sensitive: !1,
              strict: null == options ? void 0 : options.strict,
            }),
            matcher = _pathToRegexp.regexpToFunction(
              (null == options ? void 0 : options.regexModifier)
                ? new RegExp(options.regexModifier(regexp.source), regexp.flags)
                : regexp,
              keys
            );
          return (pathname, params) => {
            const res = null != pathname && matcher(pathname);
            if (!res) return !1;
            if (null == options ? void 0 : options.removeUnnamedParams)
              for (const key of keys)
                'number' == typeof key.name && delete res.params[key.name];
            return _extends({}, params, res.params);
          };
        });
      var _extends = __webpack_require__(
          './node_modules/@swc/helpers/lib/_extends.js'
        ).Z,
        _pathToRegexp = __webpack_require__(
          './node_modules/next/dist/compiled/path-to-regexp/index.js'
        );
    },
    './node_modules/next/dist/shared/lib/router/utils/prepare-destination.js': (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.matchHas = function matchHas(
          req,
          query,
          has = [],
          missing = []
        ) {
          const params = {},
            hasMatch = (hasItem) => {
              let value,
                key = hasItem.key;
              switch (hasItem.type) {
                case 'header':
                  (key = key.toLowerCase()), (value = req.headers[key]);
                  break;
                case 'cookie':
                  value = req.cookies[hasItem.key];
                  break;
                case 'query':
                  value = query[key];
                  break;
                case 'host': {
                  const { host } = (null == req ? void 0 : req.headers) || {};
                  value =
                    null == host ? void 0 : host.split(':')[0].toLowerCase();
                  break;
                }
              }
              if (!hasItem.value && value)
                return (
                  (params[
                    (function getSafeParamName(paramName) {
                      let newParamName = '';
                      for (let i = 0; i < paramName.length; i++) {
                        const charCode = paramName.charCodeAt(i);
                        ((charCode > 64 && charCode < 91) ||
                          (charCode > 96 && charCode < 123)) &&
                          (newParamName += paramName[i]);
                      }
                      return newParamName;
                    })(key)
                  ] = value),
                  !0
                );
              if (value) {
                const matcher = new RegExp(`^${hasItem.value}$`),
                  matches = Array.isArray(value)
                    ? value.slice(-1)[0].match(matcher)
                    : value.match(matcher);
                if (matches)
                  return (
                    Array.isArray(matches) &&
                      (matches.groups
                        ? Object.keys(matches.groups).forEach((groupKey) => {
                            params[groupKey] = matches.groups[groupKey];
                          })
                        : 'host' === hasItem.type &&
                          matches[0] &&
                          (params.host = matches[0])),
                    !0
                  );
              }
              return !1;
            };
          if (
            has.every((item) => hasMatch(item)) &&
            !missing.some((item) => hasMatch(item))
          )
            return params;
          return !1;
        }),
        (exports.compileNonPath = compileNonPath),
        (exports.prepareDestination = function prepareDestination(args) {
          const query = Object.assign({}, args.query);
          delete query.__nextLocale,
            delete query.__nextDefaultLocale,
            delete query.__nextDataReq;
          let escapedDestination = args.destination;
          for (const param of Object.keys(_extends({}, args.params, query)))
            (segmentName = param),
              (escapedDestination = escapedDestination.replace(
                new RegExp(
                  `:${_escapeRegexp.escapeStringRegexp(segmentName)}`,
                  'g'
                ),
                `__ESC_COLON_${segmentName}`
              ));
          var segmentName;
          const parsedDestination = _parseUrl.parseUrl(escapedDestination),
            destQuery = parsedDestination.query,
            destPath = unescapeSegments(
              `${parsedDestination.pathname}${parsedDestination.hash || ''}`
            ),
            destHostname = unescapeSegments(parsedDestination.hostname || ''),
            destPathParamKeys = [],
            destHostnameParamKeys = [];
          _pathToRegexp.pathToRegexp(destPath, destPathParamKeys),
            _pathToRegexp.pathToRegexp(destHostname, destHostnameParamKeys);
          const destParams = [];
          destPathParamKeys.forEach((key) => destParams.push(key.name)),
            destHostnameParamKeys.forEach((key) => destParams.push(key.name));
          const destPathCompiler = _pathToRegexp.compile(destPath, {
              validate: !1,
            }),
            destHostnameCompiler = _pathToRegexp.compile(destHostname, {
              validate: !1,
            });
          for (const [key1, strOrArray] of Object.entries(destQuery))
            Array.isArray(strOrArray)
              ? (destQuery[key1] = strOrArray.map((value) =>
                  compileNonPath(unescapeSegments(value), args.params)
                ))
              : 'string' == typeof strOrArray &&
                (destQuery[key1] = compileNonPath(
                  unescapeSegments(strOrArray),
                  args.params
                ));
          let newUrl,
            paramKeys = Object.keys(args.params).filter(
              (name) => 'nextInternalLocale' !== name
            );
          if (
            args.appendParamsToQuery &&
            !paramKeys.some((key) => destParams.includes(key))
          )
            for (const key of paramKeys)
              key in destQuery || (destQuery[key] = args.params[key]);
          try {
            newUrl = destPathCompiler(args.params);
            const [pathname, hash] = newUrl.split('#');
            (parsedDestination.hostname = destHostnameCompiler(args.params)),
              (parsedDestination.pathname = pathname),
              (parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`),
              delete parsedDestination.search;
          } catch (err) {
            if (
              err.message.match(/Expected .*? to not repeat, but got an array/)
            )
              throw new Error(
                'To use a multi-match in the destination you must add `*` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match'
              );
            throw err;
          }
          return (
            (parsedDestination.query = _extends(
              {},
              query,
              parsedDestination.query
            )),
            { newUrl, destQuery, parsedDestination }
          );
        });
      var _extends = __webpack_require__(
          './node_modules/@swc/helpers/lib/_extends.js'
        ).Z,
        _pathToRegexp = __webpack_require__(
          './node_modules/next/dist/compiled/path-to-regexp/index.js'
        ),
        _escapeRegexp = __webpack_require__(
          './node_modules/next/dist/shared/lib/escape-regexp.js'
        ),
        _parseUrl = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/parse-url.js'
        );
      function unescapeSegments(str) {
        return str.replace(/__ESC_COLON_/gi, ':');
      }
      function compileNonPath(value, params) {
        if (!value.includes(':')) return value;
        for (const key of Object.keys(params))
          value.includes(`:${key}`) &&
            (value = value
              .replace(
                new RegExp(`:${key}\\*`, 'g'),
                `:${key}--ESCAPED_PARAM_ASTERISKS`
              )
              .replace(
                new RegExp(`:${key}\\?`, 'g'),
                `:${key}--ESCAPED_PARAM_QUESTION`
              )
              .replace(
                new RegExp(`:${key}\\+`, 'g'),
                `:${key}--ESCAPED_PARAM_PLUS`
              )
              .replace(
                new RegExp(`:${key}(?!\\w)`, 'g'),
                `--ESCAPED_PARAM_COLON${key}`
              ));
        return (
          (value = value
            .replace(/(:|\*|\?|\+|\(|\)|\{|\})/g, '\\$1')
            .replace(/--ESCAPED_PARAM_PLUS/g, '+')
            .replace(/--ESCAPED_PARAM_COLON/g, ':')
            .replace(/--ESCAPED_PARAM_QUESTION/g, '?')
            .replace(/--ESCAPED_PARAM_ASTERISKS/g, '*')),
          _pathToRegexp.compile(`/${value}`, { validate: !1 })(params).slice(1)
        );
      }
    },
    './node_modules/next/dist/shared/lib/router/utils/querystring.js': (
      __unused_webpack_module,
      exports
    ) => {
      'use strict';
      function stringifyUrlQueryParam(param) {
        return 'string' == typeof param ||
          ('number' == typeof param && !isNaN(param)) ||
          'boolean' == typeof param
          ? String(param)
          : '';
      }
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.searchParamsToUrlQuery = function searchParamsToUrlQuery(
          searchParams
        ) {
          const query = {};
          return (
            searchParams.forEach((value, key) => {
              void 0 === query[key]
                ? (query[key] = value)
                : Array.isArray(query[key])
                ? query[key].push(value)
                : (query[key] = [query[key], value]);
            }),
            query
          );
        }),
        (exports.urlQueryToSearchParams = function urlQueryToSearchParams(
          urlQuery
        ) {
          const result = new URLSearchParams();
          return (
            Object.entries(urlQuery).forEach(([key, value]) => {
              Array.isArray(value)
                ? value.forEach((item) =>
                    result.append(key, stringifyUrlQueryParam(item))
                  )
                : result.set(key, stringifyUrlQueryParam(value));
            }),
            result
          );
        }),
        (exports.assign = function assign(target, ...searchParamsList) {
          return (
            searchParamsList.forEach((searchParams) => {
              Array.from(searchParams.keys()).forEach((key) =>
                target.delete(key)
              ),
                searchParams.forEach((value, key) => target.append(key, value));
            }),
            target
          );
        });
    },
    './node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js': (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.removePathPrefix = function removePathPrefix(path, prefix) {
          if (_pathHasPrefix.pathHasPrefix(path, prefix)) {
            const withoutPrefix = path.slice(prefix.length);
            return withoutPrefix.startsWith('/')
              ? withoutPrefix
              : `/${withoutPrefix}`;
          }
          return path;
        });
      var _pathHasPrefix = __webpack_require__(
        './node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js'
      );
    },
    './node_modules/next/dist/shared/lib/router/utils/resolve-rewrites.js': (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      var process = __webpack_require__('./node_modules/process/browser.js');
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.default = function resolveRewrites(
          asPath,
          pages,
          rewrites,
          query,
          resolveHref,
          locales
        ) {
          let resolvedHref,
            matchedPage = !1,
            externalDest = !1,
            parsedAs = _parseRelativeUrl.parseRelativeUrl(asPath),
            fsPathname = _removeTrailingSlash.removeTrailingSlash(
              _normalizeLocalePath.normalizeLocalePath(
                _removeBasePath.removeBasePath(parsedAs.pathname),
                locales
              ).pathname
            );
          const handleRewrite = (rewrite) => {
            let params = _pathMatch.getPathMatch(
              rewrite.source +
                (process.env.__NEXT_TRAILING_SLASH ? '(/)?' : ''),
              { removeUnnamedParams: !0, strict: !0 }
            )(parsedAs.pathname);
            if ((rewrite.has || rewrite.missing) && params) {
              const hasParams = _prepareDestination.matchHas(
                {
                  headers: { host: document.location.hostname },
                  cookies: document.cookie.split('; ').reduce((acc, item) => {
                    const [key, ...value] = item.split('=');
                    return (acc[key] = value.join('=')), acc;
                  }, {}),
                },
                parsedAs.query,
                rewrite.has,
                rewrite.missing
              );
              hasParams ? Object.assign(params, hasParams) : (params = !1);
            }
            if (params) {
              if (!rewrite.destination) return (externalDest = !0), !0;
              const destRes = _prepareDestination.prepareDestination({
                appendParamsToQuery: !0,
                destination: rewrite.destination,
                params,
                query,
              });
              if (
                ((parsedAs = destRes.parsedDestination),
                (asPath = destRes.newUrl),
                Object.assign(query, destRes.parsedDestination.query),
                (fsPathname = _removeTrailingSlash.removeTrailingSlash(
                  _normalizeLocalePath.normalizeLocalePath(
                    _removeBasePath.removeBasePath(asPath),
                    locales
                  ).pathname
                )),
                pages.includes(fsPathname))
              )
                return (matchedPage = !0), (resolvedHref = fsPathname), !0;
              if (
                ((resolvedHref = resolveHref(fsPathname)),
                resolvedHref !== asPath && pages.includes(resolvedHref))
              )
                return (matchedPage = !0), !0;
            }
          };
          let finished = !1;
          for (let i = 0; i < rewrites.beforeFiles.length; i++)
            handleRewrite(rewrites.beforeFiles[i]);
          if (((matchedPage = pages.includes(fsPathname)), !matchedPage)) {
            if (!finished)
              for (let i = 0; i < rewrites.afterFiles.length; i++)
                if (handleRewrite(rewrites.afterFiles[i])) {
                  finished = !0;
                  break;
                }
            if (
              (finished ||
                ((resolvedHref = resolveHref(fsPathname)),
                (matchedPage = pages.includes(resolvedHref)),
                (finished = matchedPage)),
              !finished)
            )
              for (let i = 0; i < rewrites.fallback.length; i++)
                if (handleRewrite(rewrites.fallback[i])) {
                  finished = !0;
                  break;
                }
          }
          return { asPath, parsedAs, matchedPage, resolvedHref, externalDest };
        });
      var _pathMatch = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/path-match.js'
        ),
        _prepareDestination = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/prepare-destination.js'
        ),
        _removeTrailingSlash = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js'
        ),
        _normalizeLocalePath = __webpack_require__(
          './node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js'
        ),
        _removeBasePath = __webpack_require__(
          './node_modules/next/dist/client/remove-base-path.js'
        ),
        _parseRelativeUrl = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js'
        );
    },
    './node_modules/next/dist/shared/lib/router/utils/route-matcher.js': (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.getRouteMatcher = function getRouteMatcher({ re, groups }) {
          return (pathname) => {
            const routeMatch = re.exec(pathname);
            if (!routeMatch) return !1;
            const decode = (param) => {
                try {
                  return decodeURIComponent(param);
                } catch (_) {
                  throw new _utils.DecodeError('failed to decode param');
                }
              },
              params = {};
            return (
              Object.keys(groups).forEach((slugName) => {
                const g = groups[slugName],
                  m = routeMatch[g.pos];
                void 0 !== m &&
                  (params[slugName] = ~m.indexOf('/')
                    ? m.split('/').map((entry) => decode(entry))
                    : g.repeat
                    ? [decode(m)]
                    : decode(m));
              }),
              params
            );
          };
        });
      var _utils = __webpack_require__(
        './node_modules/next/dist/shared/lib/utils.js'
      );
    },
    './node_modules/next/dist/shared/lib/router/utils/route-regex.js': (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.getRouteRegex = getRouteRegex),
        (exports.getNamedRouteRegex = function getNamedRouteRegex(
          normalizedRoute
        ) {
          const result = getNamedParametrizedRoute(normalizedRoute);
          return _extends({}, getRouteRegex(normalizedRoute), {
            namedRegex: `^${result.namedParameterizedRoute}(?:/)?$`,
            routeKeys: result.routeKeys,
          });
        }),
        (exports.getNamedMiddlewareRegex = function getNamedMiddlewareRegex(
          normalizedRoute,
          options
        ) {
          const { parameterizedRoute } = getParametrizedRoute(normalizedRoute),
            { catchAll = !0 } = options;
          if ('/' === parameterizedRoute) {
            return { namedRegex: `^/${catchAll ? '.*' : ''}$` };
          }
          const { namedParameterizedRoute } =
            getNamedParametrizedRoute(normalizedRoute);
          return {
            namedRegex: `^${namedParameterizedRoute}${
              catchAll ? '(?:(/.*)?)' : ''
            }$`,
          };
        });
      var _extends = __webpack_require__(
          './node_modules/@swc/helpers/lib/_extends.js'
        ).Z,
        _escapeRegexp = __webpack_require__(
          './node_modules/next/dist/shared/lib/escape-regexp.js'
        ),
        _removeTrailingSlash = __webpack_require__(
          './node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js'
        );
      function parseParameter(param) {
        const optional = param.startsWith('[') && param.endsWith(']');
        optional && (param = param.slice(1, -1));
        const repeat = param.startsWith('...');
        return (
          repeat && (param = param.slice(3)), { key: param, repeat, optional }
        );
      }
      function getParametrizedRoute(route) {
        const segments = _removeTrailingSlash
            .removeTrailingSlash(route)
            .slice(1)
            .split('/'),
          groups = {};
        let groupIndex = 1;
        return {
          parameterizedRoute: segments
            .map((segment) => {
              if (segment.startsWith('[') && segment.endsWith(']')) {
                const { key, optional, repeat } = parseParameter(
                  segment.slice(1, -1)
                );
                return (
                  (groups[key] = { pos: groupIndex++, repeat, optional }),
                  repeat ? (optional ? '(?:/(.+?))?' : '/(.+?)') : '/([^/]+?)'
                );
              }
              return `/${_escapeRegexp.escapeStringRegexp(segment)}`;
            })
            .join(''),
          groups,
        };
      }
      function getRouteRegex(normalizedRoute) {
        const { parameterizedRoute, groups } =
          getParametrizedRoute(normalizedRoute);
        return { re: new RegExp(`^${parameterizedRoute}(?:/)?$`), groups };
      }
      function getNamedParametrizedRoute(route) {
        const segments = _removeTrailingSlash
            .removeTrailingSlash(route)
            .slice(1)
            .split('/'),
          getSafeRouteKey = (function buildGetSafeRouteKey() {
            let routeKeyCharCode = 97,
              routeKeyCharLength = 1;
            return () => {
              let routeKey = '';
              for (let i = 0; i < routeKeyCharLength; i++)
                (routeKey += String.fromCharCode(routeKeyCharCode)),
                  routeKeyCharCode++,
                  routeKeyCharCode > 122 &&
                    (routeKeyCharLength++, (routeKeyCharCode = 97));
              return routeKey;
            };
          })(),
          routeKeys = {};
        return {
          namedParameterizedRoute: segments
            .map((segment) => {
              if (segment.startsWith('[') && segment.endsWith(']')) {
                const { key, optional, repeat } = parseParameter(
                  segment.slice(1, -1)
                );
                let cleanedKey = key.replace(/\W/g, ''),
                  invalidKey = !1;
                return (
                  (0 === cleanedKey.length || cleanedKey.length > 30) &&
                    (invalidKey = !0),
                  isNaN(parseInt(cleanedKey.slice(0, 1))) || (invalidKey = !0),
                  invalidKey && (cleanedKey = getSafeRouteKey()),
                  (routeKeys[cleanedKey] = key),
                  repeat
                    ? optional
                      ? `(?:/(?<${cleanedKey}>.+?))?`
                      : `/(?<${cleanedKey}>.+?)`
                    : `/(?<${cleanedKey}>[^/]+?)`
                );
              }
              return `/${_escapeRegexp.escapeStringRegexp(segment)}`;
            })
            .join(''),
          routeKeys,
        };
      }
    },
    './node_modules/next/dist/shared/lib/router/utils/sorted-routes.js': (
      __unused_webpack_module,
      exports
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.getSortedRoutes = function getSortedRoutes(normalizedPages) {
          const root = new UrlNode();
          return (
            normalizedPages.forEach((pagePath) => root.insert(pagePath)),
            root.smoosh()
          );
        });
      class UrlNode {
        insert(urlPath) {
          this._insert(urlPath.split('/').filter(Boolean), [], !1);
        }
        smoosh() {
          return this._smoosh();
        }
        _smoosh(prefix = '/') {
          const childrenPaths = [...this.children.keys()].sort();
          null !== this.slugName &&
            childrenPaths.splice(childrenPaths.indexOf('[]'), 1),
            null !== this.restSlugName &&
              childrenPaths.splice(childrenPaths.indexOf('[...]'), 1),
            null !== this.optionalRestSlugName &&
              childrenPaths.splice(childrenPaths.indexOf('[[...]]'), 1);
          const routes = childrenPaths
            .map((c) => this.children.get(c)._smoosh(`${prefix}${c}/`))
            .reduce((prev, curr) => [...prev, ...curr], []);
          if (
            (null !== this.slugName &&
              routes.push(
                ...this.children
                  .get('[]')
                  ._smoosh(`${prefix}[${this.slugName}]/`)
              ),
            !this.placeholder)
          ) {
            const r = '/' === prefix ? '/' : prefix.slice(0, -1);
            if (null != this.optionalRestSlugName)
              throw new Error(
                `You cannot define a route with the same specificity as a optional catch-all route ("${r}" and "${r}[[...${this.optionalRestSlugName}]]").`
              );
            routes.unshift(r);
          }
          return (
            null !== this.restSlugName &&
              routes.push(
                ...this.children
                  .get('[...]')
                  ._smoosh(`${prefix}[...${this.restSlugName}]/`)
              ),
            null !== this.optionalRestSlugName &&
              routes.push(
                ...this.children
                  .get('[[...]]')
                  ._smoosh(`${prefix}[[...${this.optionalRestSlugName}]]/`)
              ),
            routes
          );
        }
        _insert(urlPaths, slugNames, isCatchAll) {
          if (0 === urlPaths.length) return void (this.placeholder = !1);
          if (isCatchAll)
            throw new Error('Catch-all must be the last part of the URL.');
          let nextSegment = urlPaths[0];
          if (nextSegment.startsWith('[') && nextSegment.endsWith(']')) {
            let segmentName = nextSegment.slice(1, -1),
              isOptional = !1;
            if (
              (segmentName.startsWith('[') &&
                segmentName.endsWith(']') &&
                ((segmentName = segmentName.slice(1, -1)), (isOptional = !0)),
              segmentName.startsWith('...') &&
                ((segmentName = segmentName.substring(3)), (isCatchAll = !0)),
              segmentName.startsWith('[') || segmentName.endsWith(']'))
            )
              throw new Error(
                `Segment names may not start or end with extra brackets ('${segmentName}').`
              );
            if (segmentName.startsWith('.'))
              throw new Error(
                `Segment names may not start with erroneous periods ('${segmentName}').`
              );
            function handleSlug(previousSlug, nextSlug) {
              if (null !== previousSlug && previousSlug !== nextSlug)
                throw new Error(
                  `You cannot use different slug names for the same dynamic path ('${previousSlug}' !== '${nextSlug}').`
                );
              slugNames.forEach((slug) => {
                if (slug === nextSlug)
                  throw new Error(
                    `You cannot have the same slug name "${nextSlug}" repeat within a single dynamic path`
                  );
                if (slug.replace(/\W/g, '') === nextSegment.replace(/\W/g, ''))
                  throw new Error(
                    `You cannot have the slug names "${slug}" and "${nextSlug}" differ only by non-word symbols within a single dynamic path`
                  );
              }),
                slugNames.push(nextSlug);
            }
            if (isCatchAll)
              if (isOptional) {
                if (null != this.restSlugName)
                  throw new Error(
                    `You cannot use both an required and optional catch-all route at the same level ("[...${this.restSlugName}]" and "${urlPaths[0]}" ).`
                  );
                handleSlug(this.optionalRestSlugName, segmentName),
                  (this.optionalRestSlugName = segmentName),
                  (nextSegment = '[[...]]');
              } else {
                if (null != this.optionalRestSlugName)
                  throw new Error(
                    `You cannot use both an optional and required catch-all route at the same level ("[[...${this.optionalRestSlugName}]]" and "${urlPaths[0]}").`
                  );
                handleSlug(this.restSlugName, segmentName),
                  (this.restSlugName = segmentName),
                  (nextSegment = '[...]');
              }
            else {
              if (isOptional)
                throw new Error(
                  `Optional route parameters are not yet supported ("${urlPaths[0]}").`
                );
              handleSlug(this.slugName, segmentName),
                (this.slugName = segmentName),
                (nextSegment = '[]');
            }
          }
          this.children.has(nextSegment) ||
            this.children.set(nextSegment, new UrlNode()),
            this.children
              .get(nextSegment)
              ._insert(urlPaths.slice(1), slugNames, isCatchAll);
        }
        constructor() {
          (this.placeholder = !0),
            (this.children = new Map()),
            (this.slugName = null),
            (this.restSlugName = null),
            (this.optionalRestSlugName = null);
        }
      }
    },
    './node_modules/next/dist/shared/lib/utils.js': (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.execOnce = function execOnce(fn) {
          let result,
            used = !1;
          return (...args) => (
            used || ((used = !0), (result = fn(...args))), result
          );
        }),
        (exports.getLocationOrigin = getLocationOrigin),
        (exports.getURL = function getURL() {
          const { href } = window.location,
            origin = getLocationOrigin();
          return href.substring(origin.length);
        }),
        (exports.getDisplayName = getDisplayName),
        (exports.isResSent = isResSent),
        (exports.normalizeRepeatedSlashes = function normalizeRepeatedSlashes(
          url
        ) {
          const urlParts = url.split('?');
          return (
            urlParts[0].replace(/\\/g, '/').replace(/\/\/+/g, '/') +
            (urlParts[1] ? `?${urlParts.slice(1).join('?')}` : '')
          );
        }),
        (exports.loadGetInitialProps = loadGetInitialProps),
        (exports.ST =
          exports.SP =
          exports.isAbsoluteUrl =
          exports.WEB_VITALS =
            void 0);
      var _async_to_generator = __webpack_require__(
        './node_modules/@swc/helpers/lib/_async_to_generator.js'
      ).Z;
      exports.WEB_VITALS = ['CLS', 'FCP', 'FID', 'INP', 'LCP', 'TTFB'];
      const ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/;
      function getLocationOrigin() {
        const { protocol, hostname, port } = window.location;
        return `${protocol}//${hostname}${port ? ':' + port : ''}`;
      }
      function getDisplayName(Component) {
        return 'string' == typeof Component
          ? Component
          : Component.displayName || Component.name || 'Unknown';
      }
      function isResSent(res) {
        return res.finished || res.headersSent;
      }
      function loadGetInitialProps(App, ctx) {
        return _loadGetInitialProps.apply(this, arguments);
      }
      function _loadGetInitialProps() {
        return (_loadGetInitialProps = _async_to_generator(function* (
          App,
          ctx
        ) {
          const res = ctx.res || (ctx.ctx && ctx.ctx.res);
          if (!App.getInitialProps)
            return ctx.ctx && ctx.Component
              ? { pageProps: yield loadGetInitialProps(ctx.Component, ctx.ctx) }
              : {};
          const props = yield App.getInitialProps(ctx);
          if (res && isResSent(res)) return props;
          if (!props) {
            const message = `"${getDisplayName(
              App
            )}.getInitialProps()" should resolve to an object. But found "${props}" instead.`;
            throw new Error(message);
          }
          return props;
        })).apply(this, arguments);
      }
      exports.isAbsoluteUrl = (url) => ABSOLUTE_URL_REGEX.test(url);
      const SP = 'undefined' != typeof performance;
      exports.SP = SP;
      const ST =
        SP &&
        ['mark', 'measure', 'getEntriesByName'].every(
          (method) => 'function' == typeof performance[method]
        );
      exports.ST = ST;
      class DecodeError extends Error {}
      exports.DecodeError = DecodeError;
      class NormalizeError extends Error {}
      exports.NormalizeError = NormalizeError;
      class PageNotFoundError extends Error {
        constructor(page) {
          super(),
            (this.code = 'ENOENT'),
            (this.message = `Cannot find module for page: ${page}`);
        }
      }
      exports.PageNotFoundError = PageNotFoundError;
      class MissingStaticPage extends Error {
        constructor(page, message) {
          super(),
            (this.message = `Failed to load static file for page: ${page} ${message}`);
        }
      }
      exports.MissingStaticPage = MissingStaticPage;
      class MiddlewareNotFoundError extends Error {
        constructor() {
          super(),
            (this.code = 'ENOENT'),
            (this.message = 'Cannot find the middleware module');
        }
      }
      exports.MiddlewareNotFoundError = MiddlewareNotFoundError;
    },
    './node_modules/next/head.js': (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      module.exports = __webpack_require__(
        './node_modules/next/dist/shared/lib/head.js'
      );
    },
    './node_modules/next/link.js': (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      module.exports = __webpack_require__(
        './node_modules/next/dist/client/link.js'
      );
    },
    './node_modules/react-chartjs-2/dist/index.js': (
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) => {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { x1: () => Line });
      var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/react/index.js'
        ),
        chart_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/chart.js/dist/chart.js'
        );
      const defaultDatasetIdKey = 'label';
      function reforwardRef(ref, value) {
        'function' == typeof ref ? ref(value) : ref && (ref.current = value);
      }
      function setLabels(currentData, nextLabels) {
        currentData.labels = nextLabels;
      }
      function setDatasets(currentData, nextDatasets) {
        let datasetIdKey =
          arguments.length > 2 && void 0 !== arguments[2]
            ? arguments[2]
            : defaultDatasetIdKey;
        const addedDatasets = [];
        currentData.datasets = nextDatasets.map((nextDataset) => {
          const currentDataset = currentData.datasets.find(
            (dataset) => dataset[datasetIdKey] === nextDataset[datasetIdKey]
          );
          return currentDataset &&
            nextDataset.data &&
            !addedDatasets.includes(currentDataset)
            ? (addedDatasets.push(currentDataset),
              Object.assign(currentDataset, nextDataset),
              currentDataset)
            : { ...nextDataset };
        });
      }
      function cloneData(data) {
        let datasetIdKey =
          arguments.length > 1 && void 0 !== arguments[1]
            ? arguments[1]
            : defaultDatasetIdKey;
        const nextData = { labels: [], datasets: [] };
        return (
          setLabels(nextData, data.labels),
          setDatasets(nextData, data.datasets, datasetIdKey),
          nextData
        );
      }
      function ChartComponent(props, ref) {
        const {
            height = 150,
            width = 300,
            redraw = !1,
            datasetIdKey,
            type,
            data,
            options,
            plugins = [],
            fallbackContent,
            updateMode,
            ...canvasProps
          } = props,
          canvasRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),
          chartRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(),
          renderChart = () => {
            canvasRef.current &&
              ((chartRef.current = new chart_js__WEBPACK_IMPORTED_MODULE_1__.kL(
                canvasRef.current,
                {
                  type,
                  data: cloneData(data, datasetIdKey),
                  options: options && { ...options },
                  plugins,
                }
              )),
              reforwardRef(ref, chartRef.current));
          },
          destroyChart = () => {
            reforwardRef(ref, null),
              chartRef.current &&
                (chartRef.current.destroy(), (chartRef.current = null));
          };
        return (
          (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
            !redraw &&
              chartRef.current &&
              options &&
              (function setOptions(chart, nextOptions) {
                const options = chart.options;
                options && nextOptions && Object.assign(options, nextOptions);
              })(chartRef.current, options);
          }, [redraw, options]),
          (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
            !redraw &&
              chartRef.current &&
              setLabels(chartRef.current.config.data, data.labels);
          }, [redraw, data.labels]),
          (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
            !redraw &&
              chartRef.current &&
              data.datasets &&
              setDatasets(
                chartRef.current.config.data,
                data.datasets,
                datasetIdKey
              );
          }, [redraw, data.datasets]),
          (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
            chartRef.current &&
              (redraw
                ? (destroyChart(), setTimeout(renderChart))
                : chartRef.current.update(updateMode));
          }, [redraw, options, data.labels, data.datasets, updateMode]),
          (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
            chartRef.current && (destroyChart(), setTimeout(renderChart));
          }, [type]),
          (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(
            () => (renderChart(), () => destroyChart()),
            []
          ),
          react__WEBPACK_IMPORTED_MODULE_0__.createElement(
            'canvas',
            Object.assign(
              { ref: canvasRef, role: 'img', height, width },
              canvasProps
            ),
            fallbackContent
          )
        );
      }
      const Chart = (0, react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(
        ChartComponent
      );
      function createTypedChart(type, registerables) {
        return (
          chart_js__WEBPACK_IMPORTED_MODULE_1__.kL.register(registerables),
          (0, react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref) =>
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(
              Chart,
              Object.assign({}, props, { ref, type })
            )
          )
        );
      }
      const Line = createTypedChart(
        'line',
        chart_js__WEBPACK_IMPORTED_MODULE_1__.ST
      );
    },
    './node_modules/swiper/modules/navigation/navigation.scss': (
      __unused_webpack_module,
      __unused_webpack___webpack_exports__,
      __webpack_require__
    ) => {
      'use strict';
      var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            './node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js'
          ),
        _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default =
          __webpack_require__.n(
            _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__
          ),
        _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            './node_modules/style-loader/dist/runtime/styleDomAPI.js'
          ),
        _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default =
          __webpack_require__.n(
            _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__
          ),
        _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            './node_modules/style-loader/dist/runtime/insertBySelector.js'
          ),
        _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default =
          __webpack_require__.n(
            _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__
          ),
        _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ =
          __webpack_require__(
            './node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js'
          ),
        _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default =
          __webpack_require__.n(
            _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__
          ),
        _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ =
          __webpack_require__(
            './node_modules/style-loader/dist/runtime/insertStyleElement.js'
          ),
        _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default =
          __webpack_require__.n(
            _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__
          ),
        _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ =
          __webpack_require__(
            './node_modules/style-loader/dist/runtime/styleTagTransform.js'
          ),
        _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default =
          __webpack_require__.n(
            _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__
          ),
        _css_loader_dist_cjs_js_ruleSet_1_rules_14_use_1_postcss_loader_dist_cjs_js_resolve_url_loader_index_js_sass_loader_dist_cjs_js_ruleSet_1_rules_14_use_4_navigation_scss__WEBPACK_IMPORTED_MODULE_6__ =
          __webpack_require__(
            './node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[14].use[1]!./node_modules/postcss-loader/dist/cjs.js!./node_modules/resolve-url-loader/index.js!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[14].use[4]!./node_modules/swiper/modules/navigation/navigation.scss'
          ),
        options = {};
      (options.styleTagTransform =
        _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default()),
        (options.setAttributes =
          _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default()),
        (options.insert =
          _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(
            null,
            'head'
          )),
        (options.domAPI =
          _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default()),
        (options.insertStyleElement =
          _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());
      _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(
        _css_loader_dist_cjs_js_ruleSet_1_rules_14_use_1_postcss_loader_dist_cjs_js_resolve_url_loader_index_js_sass_loader_dist_cjs_js_ruleSet_1_rules_14_use_4_navigation_scss__WEBPACK_IMPORTED_MODULE_6__.Z,
        options
      ),
        _css_loader_dist_cjs_js_ruleSet_1_rules_14_use_1_postcss_loader_dist_cjs_js_resolve_url_loader_index_js_sass_loader_dist_cjs_js_ruleSet_1_rules_14_use_4_navigation_scss__WEBPACK_IMPORTED_MODULE_6__.Z &&
          _css_loader_dist_cjs_js_ruleSet_1_rules_14_use_1_postcss_loader_dist_cjs_js_resolve_url_loader_index_js_sass_loader_dist_cjs_js_ruleSet_1_rules_14_use_4_navigation_scss__WEBPACK_IMPORTED_MODULE_6__
            .Z.locals &&
          _css_loader_dist_cjs_js_ruleSet_1_rules_14_use_1_postcss_loader_dist_cjs_js_resolve_url_loader_index_js_sass_loader_dist_cjs_js_ruleSet_1_rules_14_use_4_navigation_scss__WEBPACK_IMPORTED_MODULE_6__
            .Z.locals;
    },
    './node_modules/swiper/modules/pagination/pagination.scss': (
      __unused_webpack_module,
      __unused_webpack___webpack_exports__,
      __webpack_require__
    ) => {
      'use strict';
      var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            './node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js'
          ),
        _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default =
          __webpack_require__.n(
            _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__
          ),
        _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            './node_modules/style-loader/dist/runtime/styleDomAPI.js'
          ),
        _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default =
          __webpack_require__.n(
            _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__
          ),
        _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            './node_modules/style-loader/dist/runtime/insertBySelector.js'
          ),
        _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default =
          __webpack_require__.n(
            _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__
          ),
        _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ =
          __webpack_require__(
            './node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js'
          ),
        _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default =
          __webpack_require__.n(
            _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__
          ),
        _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ =
          __webpack_require__(
            './node_modules/style-loader/dist/runtime/insertStyleElement.js'
          ),
        _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default =
          __webpack_require__.n(
            _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__
          ),
        _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ =
          __webpack_require__(
            './node_modules/style-loader/dist/runtime/styleTagTransform.js'
          ),
        _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default =
          __webpack_require__.n(
            _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__
          ),
        _css_loader_dist_cjs_js_ruleSet_1_rules_14_use_1_postcss_loader_dist_cjs_js_resolve_url_loader_index_js_sass_loader_dist_cjs_js_ruleSet_1_rules_14_use_4_pagination_scss__WEBPACK_IMPORTED_MODULE_6__ =
          __webpack_require__(
            './node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[14].use[1]!./node_modules/postcss-loader/dist/cjs.js!./node_modules/resolve-url-loader/index.js!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[14].use[4]!./node_modules/swiper/modules/pagination/pagination.scss'
          ),
        options = {};
      (options.styleTagTransform =
        _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default()),
        (options.setAttributes =
          _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default()),
        (options.insert =
          _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(
            null,
            'head'
          )),
        (options.domAPI =
          _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default()),
        (options.insertStyleElement =
          _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());
      _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(
        _css_loader_dist_cjs_js_ruleSet_1_rules_14_use_1_postcss_loader_dist_cjs_js_resolve_url_loader_index_js_sass_loader_dist_cjs_js_ruleSet_1_rules_14_use_4_pagination_scss__WEBPACK_IMPORTED_MODULE_6__.Z,
        options
      ),
        _css_loader_dist_cjs_js_ruleSet_1_rules_14_use_1_postcss_loader_dist_cjs_js_resolve_url_loader_index_js_sass_loader_dist_cjs_js_ruleSet_1_rules_14_use_4_pagination_scss__WEBPACK_IMPORTED_MODULE_6__.Z &&
          _css_loader_dist_cjs_js_ruleSet_1_rules_14_use_1_postcss_loader_dist_cjs_js_resolve_url_loader_index_js_sass_loader_dist_cjs_js_ruleSet_1_rules_14_use_4_pagination_scss__WEBPACK_IMPORTED_MODULE_6__
            .Z.locals &&
          _css_loader_dist_cjs_js_ruleSet_1_rules_14_use_1_postcss_loader_dist_cjs_js_resolve_url_loader_index_js_sass_loader_dist_cjs_js_ruleSet_1_rules_14_use_4_pagination_scss__WEBPACK_IMPORTED_MODULE_6__
            .Z.locals;
    },
    './node_modules/swiper/swiper.scss': (
      __unused_webpack_module,
      __unused_webpack___webpack_exports__,
      __webpack_require__
    ) => {
      'use strict';
      var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            './node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js'
          ),
        _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default =
          __webpack_require__.n(
            _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__
          ),
        _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            './node_modules/style-loader/dist/runtime/styleDomAPI.js'
          ),
        _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default =
          __webpack_require__.n(
            _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__
          ),
        _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            './node_modules/style-loader/dist/runtime/insertBySelector.js'
          ),
        _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default =
          __webpack_require__.n(
            _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__
          ),
        _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ =
          __webpack_require__(
            './node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js'
          ),
        _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default =
          __webpack_require__.n(
            _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__
          ),
        _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ =
          __webpack_require__(
            './node_modules/style-loader/dist/runtime/insertStyleElement.js'
          ),
        _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default =
          __webpack_require__.n(
            _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__
          ),
        _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ =
          __webpack_require__(
            './node_modules/style-loader/dist/runtime/styleTagTransform.js'
          ),
        _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default =
          __webpack_require__.n(
            _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__
          ),
        _css_loader_dist_cjs_js_ruleSet_1_rules_14_use_1_postcss_loader_dist_cjs_js_resolve_url_loader_index_js_sass_loader_dist_cjs_js_ruleSet_1_rules_14_use_4_swiper_scss__WEBPACK_IMPORTED_MODULE_6__ =
          __webpack_require__(
            './node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[14].use[1]!./node_modules/postcss-loader/dist/cjs.js!./node_modules/resolve-url-loader/index.js!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[14].use[4]!./node_modules/swiper/swiper.scss'
          ),
        options = {};
      (options.styleTagTransform =
        _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default()),
        (options.setAttributes =
          _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default()),
        (options.insert =
          _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(
            null,
            'head'
          )),
        (options.domAPI =
          _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default()),
        (options.insertStyleElement =
          _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());
      _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(
        _css_loader_dist_cjs_js_ruleSet_1_rules_14_use_1_postcss_loader_dist_cjs_js_resolve_url_loader_index_js_sass_loader_dist_cjs_js_ruleSet_1_rules_14_use_4_swiper_scss__WEBPACK_IMPORTED_MODULE_6__.Z,
        options
      ),
        _css_loader_dist_cjs_js_ruleSet_1_rules_14_use_1_postcss_loader_dist_cjs_js_resolve_url_loader_index_js_sass_loader_dist_cjs_js_ruleSet_1_rules_14_use_4_swiper_scss__WEBPACK_IMPORTED_MODULE_6__.Z &&
          _css_loader_dist_cjs_js_ruleSet_1_rules_14_use_1_postcss_loader_dist_cjs_js_resolve_url_loader_index_js_sass_loader_dist_cjs_js_ruleSet_1_rules_14_use_4_swiper_scss__WEBPACK_IMPORTED_MODULE_6__
            .Z.locals &&
          _css_loader_dist_cjs_js_ruleSet_1_rules_14_use_1_postcss_loader_dist_cjs_js_resolve_url_loader_index_js_sass_loader_dist_cjs_js_ruleSet_1_rules_14_use_4_swiper_scss__WEBPACK_IMPORTED_MODULE_6__
            .Z.locals;
    },
    './node_modules/swiper/react/swiper-react.js': (
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) => {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        tq: () => Swiper,
        o5: () => SwiperSlide,
      });
      var react = __webpack_require__('./node_modules/react/index.js'),
        swiper_esm = __webpack_require__('./node_modules/swiper/swiper.esm.js');
      function isObject(o) {
        return (
          'object' == typeof o &&
          null !== o &&
          o.constructor &&
          'Object' === Object.prototype.toString.call(o).slice(8, -1)
        );
      }
      function extend(target, src) {
        const noExtend = ['__proto__', 'constructor', 'prototype'];
        Object.keys(src)
          .filter((key) => noExtend.indexOf(key) < 0)
          .forEach((key) => {
            void 0 === target[key]
              ? (target[key] = src[key])
              : isObject(src[key]) &&
                isObject(target[key]) &&
                Object.keys(src[key]).length > 0
              ? src[key].__swiper__
                ? (target[key] = src[key])
                : extend(target[key], src[key])
              : (target[key] = src[key]);
          });
      }
      function needsNavigation(params = {}) {
        return (
          params.navigation &&
          void 0 === params.navigation.nextEl &&
          void 0 === params.navigation.prevEl
        );
      }
      function needsPagination(params = {}) {
        return params.pagination && void 0 === params.pagination.el;
      }
      function needsScrollbar(params = {}) {
        return params.scrollbar && void 0 === params.scrollbar.el;
      }
      function uniqueClasses(classNames = '') {
        const classes = classNames
            .split(' ')
            .map((c) => c.trim())
            .filter((c) => !!c),
          unique = [];
        return (
          classes.forEach((c) => {
            unique.indexOf(c) < 0 && unique.push(c);
          }),
          unique.join(' ')
        );
      }
      const paramsList = [
        'modules',
        'init',
        '_direction',
        'touchEventsTarget',
        'initialSlide',
        '_speed',
        'cssMode',
        'updateOnWindowResize',
        'resizeObserver',
        'nested',
        'focusableElements',
        '_enabled',
        '_width',
        '_height',
        'preventInteractionOnTransition',
        'userAgent',
        'url',
        '_edgeSwipeDetection',
        '_edgeSwipeThreshold',
        '_freeMode',
        '_autoHeight',
        'setWrapperSize',
        'virtualTranslate',
        '_effect',
        'breakpoints',
        '_spaceBetween',
        '_slidesPerView',
        'maxBackfaceHiddenSlides',
        '_grid',
        '_slidesPerGroup',
        '_slidesPerGroupSkip',
        '_slidesPerGroupAuto',
        '_centeredSlides',
        '_centeredSlidesBounds',
        '_slidesOffsetBefore',
        '_slidesOffsetAfter',
        'normalizeSlideIndex',
        '_centerInsufficientSlides',
        '_watchOverflow',
        'roundLengths',
        'touchRatio',
        'touchAngle',
        'simulateTouch',
        '_shortSwipes',
        '_longSwipes',
        'longSwipesRatio',
        'longSwipesMs',
        '_followFinger',
        'allowTouchMove',
        '_threshold',
        'touchMoveStopPropagation',
        'touchStartPreventDefault',
        'touchStartForcePreventDefault',
        'touchReleaseOnEdges',
        'uniqueNavElements',
        '_resistance',
        '_resistanceRatio',
        '_watchSlidesProgress',
        '_grabCursor',
        'preventClicks',
        'preventClicksPropagation',
        '_slideToClickedSlide',
        '_preloadImages',
        'updateOnImagesReady',
        '_loop',
        '_loopAdditionalSlides',
        '_loopedSlides',
        '_loopedSlidesLimit',
        '_loopFillGroupWithBlank',
        'loopPreventsSlide',
        '_rewind',
        '_allowSlidePrev',
        '_allowSlideNext',
        '_swipeHandler',
        '_noSwiping',
        'noSwipingClass',
        'noSwipingSelector',
        'passiveListeners',
        'containerModifierClass',
        'slideClass',
        'slideBlankClass',
        'slideActiveClass',
        'slideDuplicateActiveClass',
        'slideVisibleClass',
        'slideDuplicateClass',
        'slideNextClass',
        'slideDuplicateNextClass',
        'slidePrevClass',
        'slideDuplicatePrevClass',
        'wrapperClass',
        'runCallbacksOnInit',
        'observer',
        'observeParents',
        'observeSlideChildren',
        'a11y',
        '_autoplay',
        '_controller',
        'coverflowEffect',
        'cubeEffect',
        'fadeEffect',
        'flipEffect',
        'creativeEffect',
        'cardsEffect',
        'hashNavigation',
        'history',
        'keyboard',
        'lazy',
        'mousewheel',
        '_navigation',
        '_pagination',
        'parallax',
        '_scrollbar',
        '_thumbs',
        'virtual',
        'zoom',
      ];
      const calcLoopedSlides = (slides, swiperParams) => {
        let slidesPerViewParams = swiperParams.slidesPerView;
        if (swiperParams.breakpoints) {
          const breakpoint = swiper_esm.ZP.prototype.getBreakpoint(
              swiperParams.breakpoints
            ),
            breakpointOnlyParams =
              breakpoint in swiperParams.breakpoints
                ? swiperParams.breakpoints[breakpoint]
                : void 0;
          breakpointOnlyParams &&
            breakpointOnlyParams.slidesPerView &&
            (slidesPerViewParams = breakpointOnlyParams.slidesPerView);
        }
        let loopedSlides = Math.ceil(
          parseFloat(swiperParams.loopedSlides || slidesPerViewParams, 10)
        );
        return (
          (loopedSlides += swiperParams.loopAdditionalSlides),
          loopedSlides > slides.length &&
            swiperParams.loopedSlidesLimit &&
            (loopedSlides = slides.length),
          loopedSlides
        );
      };
      function isChildSwiperSlide(child) {
        return (
          child.type &&
          child.type.displayName &&
          child.type.displayName.includes('SwiperSlide')
        );
      }
      function processChildren(c) {
        const slides = [];
        return (
          react.Children.toArray(c).forEach((child) => {
            isChildSwiperSlide(child)
              ? slides.push(child)
              : child.props &&
                child.props.children &&
                processChildren(child.props.children).forEach((slide) =>
                  slides.push(slide)
                );
          }),
          slides
        );
      }
      function getChildren(c) {
        const slides = [],
          slots = {
            'container-start': [],
            'container-end': [],
            'wrapper-start': [],
            'wrapper-end': [],
          };
        return (
          react.Children.toArray(c).forEach((child) => {
            if (isChildSwiperSlide(child)) slides.push(child);
            else if (child.props && child.props.slot && slots[child.props.slot])
              slots[child.props.slot].push(child);
            else if (child.props && child.props.children) {
              const foundSlides = processChildren(child.props.children);
              foundSlides.length > 0
                ? foundSlides.forEach((slide) => slides.push(slide))
                : slots['container-end'].push(child);
            } else slots['container-end'].push(child);
          }),
          { slides, slots }
        );
      }
      function updateSwiper({
        swiper,
        slides,
        passedParams,
        changedParams,
        nextEl,
        prevEl,
        scrollbarEl,
        paginationEl,
      }) {
        const updateParams = changedParams.filter(
            (key) => 'children' !== key && 'direction' !== key
          ),
          {
            params: currentParams,
            pagination,
            navigation,
            scrollbar,
            virtual,
            thumbs,
          } = swiper;
        let needThumbsInit,
          needControllerInit,
          needPaginationInit,
          needScrollbarInit,
          needNavigationInit;
        changedParams.includes('thumbs') &&
          passedParams.thumbs &&
          passedParams.thumbs.swiper &&
          currentParams.thumbs &&
          !currentParams.thumbs.swiper &&
          (needThumbsInit = !0),
          changedParams.includes('controller') &&
            passedParams.controller &&
            passedParams.controller.control &&
            currentParams.controller &&
            !currentParams.controller.control &&
            (needControllerInit = !0),
          changedParams.includes('pagination') &&
            passedParams.pagination &&
            (passedParams.pagination.el || paginationEl) &&
            (currentParams.pagination || !1 === currentParams.pagination) &&
            pagination &&
            !pagination.el &&
            (needPaginationInit = !0),
          changedParams.includes('scrollbar') &&
            passedParams.scrollbar &&
            (passedParams.scrollbar.el || scrollbarEl) &&
            (currentParams.scrollbar || !1 === currentParams.scrollbar) &&
            scrollbar &&
            !scrollbar.el &&
            (needScrollbarInit = !0),
          changedParams.includes('navigation') &&
            passedParams.navigation &&
            (passedParams.navigation.prevEl || prevEl) &&
            (passedParams.navigation.nextEl || nextEl) &&
            (currentParams.navigation || !1 === currentParams.navigation) &&
            navigation &&
            !navigation.prevEl &&
            !navigation.nextEl &&
            (needNavigationInit = !0);
        if (
          (updateParams.forEach((key) => {
            if (isObject(currentParams[key]) && isObject(passedParams[key]))
              extend(currentParams[key], passedParams[key]);
            else {
              const newValue = passedParams[key];
              (!0 !== newValue && !1 !== newValue) ||
              ('navigation' !== key &&
                'pagination' !== key &&
                'scrollbar' !== key)
                ? (currentParams[key] = passedParams[key])
                : !1 === newValue &&
                  swiper[(mod = key)] &&
                  (swiper[mod].destroy(),
                  'navigation' === mod
                    ? ((currentParams[mod].prevEl = void 0),
                      (currentParams[mod].nextEl = void 0),
                      (swiper[mod].prevEl = void 0),
                      (swiper[mod].nextEl = void 0))
                    : ((currentParams[mod].el = void 0),
                      (swiper[mod].el = void 0)));
            }
            var mod;
          }),
          updateParams.includes('controller') &&
            !needControllerInit &&
            swiper.controller &&
            swiper.controller.control &&
            currentParams.controller &&
            currentParams.controller.control &&
            (swiper.controller.control = currentParams.controller.control),
          changedParams.includes('children') &&
          slides &&
          virtual &&
          currentParams.virtual.enabled
            ? ((virtual.slides = slides), virtual.update(!0))
            : changedParams.includes('children') &&
              swiper.lazy &&
              swiper.params.lazy.enabled &&
              swiper.lazy.load(),
          needThumbsInit)
        ) {
          thumbs.init() && thumbs.update(!0);
        }
        needControllerInit &&
          (swiper.controller.control = currentParams.controller.control),
          needPaginationInit &&
            (paginationEl && (currentParams.pagination.el = paginationEl),
            pagination.init(),
            pagination.render(),
            pagination.update()),
          needScrollbarInit &&
            (scrollbarEl && (currentParams.scrollbar.el = scrollbarEl),
            scrollbar.init(),
            scrollbar.updateSize(),
            scrollbar.setTranslate()),
          needNavigationInit &&
            (nextEl && (currentParams.navigation.nextEl = nextEl),
            prevEl && (currentParams.navigation.prevEl = prevEl),
            navigation.init(),
            navigation.update()),
          changedParams.includes('allowSlideNext') &&
            (swiper.allowSlideNext = passedParams.allowSlideNext),
          changedParams.includes('allowSlidePrev') &&
            (swiper.allowSlidePrev = passedParams.allowSlidePrev),
          changedParams.includes('direction') &&
            swiper.changeDirection(passedParams.direction, !1),
          swiper.update();
      }
      function useIsomorphicLayoutEffect(callback, deps) {
        return 'undefined' == typeof window
          ? (0, react.useEffect)(callback, deps)
          : (0, react.useLayoutEffect)(callback, deps);
      }
      const SwiperSlideContext = (0, react.createContext)(null),
        SwiperContext = (0, react.createContext)(null);
      function _extends() {
        return (
          (_extends = Object.assign
            ? Object.assign.bind()
            : function (target) {
                for (var i = 1; i < arguments.length; i++) {
                  var source = arguments[i];
                  for (var key in source)
                    Object.prototype.hasOwnProperty.call(source, key) &&
                      (target[key] = source[key]);
                }
                return target;
              }),
          _extends.apply(this, arguments)
        );
      }
      const Swiper = (0, react.forwardRef)(function (_temp, externalElRef) {
        let {
            className,
            tag: Tag = 'div',
            wrapperTag: WrapperTag = 'div',
            children,
            onSwiper,
            ...rest
          } = void 0 === _temp ? {} : _temp,
          eventsAssigned = !1;
        const [containerClasses, setContainerClasses] = (0, react.useState)(
            'swiper'
          ),
          [virtualData, setVirtualData] = (0, react.useState)(null),
          [breakpointChanged, setBreakpointChanged] = (0, react.useState)(!1),
          initializedRef = (0, react.useRef)(!1),
          swiperElRef = (0, react.useRef)(null),
          swiperRef = (0, react.useRef)(null),
          oldPassedParamsRef = (0, react.useRef)(null),
          oldSlides = (0, react.useRef)(null),
          nextElRef = (0, react.useRef)(null),
          prevElRef = (0, react.useRef)(null),
          paginationElRef = (0, react.useRef)(null),
          scrollbarElRef = (0, react.useRef)(null),
          {
            params: swiperParams,
            passedParams,
            rest: restProps,
            events,
          } = (function getParams(obj = {}, splitEvents = !0) {
            const params = { on: {} },
              events = {},
              passedParams = {};
            extend(params, swiper_esm.ZP.defaults),
              extend(params, swiper_esm.ZP.extendedDefaults),
              (params._emitClasses = !0),
              (params.init = !1);
            const rest = {},
              allowedParams = paramsList.map((key) => key.replace(/_/, '')),
              plainObj = Object.assign({}, obj);
            return (
              Object.keys(plainObj).forEach((key) => {
                void 0 !== obj[key] &&
                  (allowedParams.indexOf(key) >= 0
                    ? isObject(obj[key])
                      ? ((params[key] = {}),
                        (passedParams[key] = {}),
                        extend(params[key], obj[key]),
                        extend(passedParams[key], obj[key]))
                      : ((params[key] = obj[key]),
                        (passedParams[key] = obj[key]))
                    : 0 === key.search(/on[A-Z]/) &&
                      'function' == typeof obj[key]
                    ? splitEvents
                      ? (events[`${key[2].toLowerCase()}${key.substr(3)}`] =
                          obj[key])
                      : (params.on[`${key[2].toLowerCase()}${key.substr(3)}`] =
                          obj[key])
                    : (rest[key] = obj[key]));
              }),
              ['navigation', 'pagination', 'scrollbar'].forEach((key) => {
                !0 === params[key] && (params[key] = {}),
                  !1 === params[key] && delete params[key];
              }),
              { params, passedParams, rest, events }
            );
          })(rest),
          { slides, slots } = getChildren(children),
          onBeforeBreakpoint = () => {
            setBreakpointChanged(!breakpointChanged);
          };
        Object.assign(swiperParams.on, {
          _containerClasses(swiper, classes) {
            setContainerClasses(classes);
          },
        });
        const initSwiper = () => {
          if (
            (Object.assign(swiperParams.on, events),
            (eventsAssigned = !0),
            (swiperRef.current = new swiper_esm.ZP(swiperParams)),
            (swiperRef.current.loopCreate = () => {}),
            (swiperRef.current.loopDestroy = () => {}),
            swiperParams.loop &&
              (swiperRef.current.loopedSlides = calcLoopedSlides(
                slides,
                swiperParams
              )),
            swiperRef.current.virtual &&
              swiperRef.current.params.virtual.enabled)
          ) {
            swiperRef.current.virtual.slides = slides;
            const extendWith = {
              cache: !1,
              slides,
              renderExternal: setVirtualData,
              renderExternalUpdate: !1,
            };
            extend(swiperRef.current.params.virtual, extendWith),
              extend(swiperRef.current.originalParams.virtual, extendWith);
          }
        };
        swiperElRef.current || initSwiper(),
          swiperRef.current &&
            swiperRef.current.on('_beforeBreakpoint', onBeforeBreakpoint);
        return (
          (0, react.useEffect)(() => () => {
            swiperRef.current &&
              swiperRef.current.off('_beforeBreakpoint', onBeforeBreakpoint);
          }),
          (0, react.useEffect)(() => {
            !initializedRef.current &&
              swiperRef.current &&
              (swiperRef.current.emitSlidesClasses(),
              (initializedRef.current = !0));
          }),
          useIsomorphicLayoutEffect(() => {
            if (
              (externalElRef && (externalElRef.current = swiperElRef.current),
              swiperElRef.current)
            )
              return (
                swiperRef.current.destroyed && initSwiper(),
                (function mountSwiper(
                  { el, nextEl, prevEl, paginationEl, scrollbarEl, swiper },
                  swiperParams
                ) {
                  needsNavigation(swiperParams) &&
                    nextEl &&
                    prevEl &&
                    ((swiper.params.navigation.nextEl = nextEl),
                    (swiper.originalParams.navigation.nextEl = nextEl),
                    (swiper.params.navigation.prevEl = prevEl),
                    (swiper.originalParams.navigation.prevEl = prevEl)),
                    needsPagination(swiperParams) &&
                      paginationEl &&
                      ((swiper.params.pagination.el = paginationEl),
                      (swiper.originalParams.pagination.el = paginationEl)),
                    needsScrollbar(swiperParams) &&
                      scrollbarEl &&
                      ((swiper.params.scrollbar.el = scrollbarEl),
                      (swiper.originalParams.scrollbar.el = scrollbarEl)),
                    swiper.init(el);
                })(
                  {
                    el: swiperElRef.current,
                    nextEl: nextElRef.current,
                    prevEl: prevElRef.current,
                    paginationEl: paginationElRef.current,
                    scrollbarEl: scrollbarElRef.current,
                    swiper: swiperRef.current,
                  },
                  swiperParams
                ),
                onSwiper && onSwiper(swiperRef.current),
                () => {
                  swiperRef.current &&
                    !swiperRef.current.destroyed &&
                    swiperRef.current.destroy(!0, !1);
                }
              );
          }, []),
          useIsomorphicLayoutEffect(() => {
            !eventsAssigned &&
              events &&
              swiperRef.current &&
              Object.keys(events).forEach((eventName) => {
                swiperRef.current.on(eventName, events[eventName]);
              });
            const changedParams = (function getChangedParams(
              swiperParams,
              oldParams,
              children,
              oldChildren,
              getKey
            ) {
              const keys = [];
              if (!oldParams) return keys;
              const addKey = (key) => {
                keys.indexOf(key) < 0 && keys.push(key);
              };
              if (children && oldChildren) {
                const oldChildrenKeys = oldChildren.map(getKey),
                  childrenKeys = children.map(getKey);
                oldChildrenKeys.join('') !== childrenKeys.join('') &&
                  addKey('children'),
                  oldChildren.length !== children.length && addKey('children');
              }
              return (
                paramsList
                  .filter((key) => '_' === key[0])
                  .map((key) => key.replace(/_/, ''))
                  .forEach((key) => {
                    if (key in swiperParams && key in oldParams)
                      if (
                        isObject(swiperParams[key]) &&
                        isObject(oldParams[key])
                      ) {
                        const newKeys = Object.keys(swiperParams[key]),
                          oldKeys = Object.keys(oldParams[key]);
                        newKeys.length !== oldKeys.length
                          ? addKey(key)
                          : (newKeys.forEach((newKey) => {
                              swiperParams[key][newKey] !==
                                oldParams[key][newKey] && addKey(key);
                            }),
                            oldKeys.forEach((oldKey) => {
                              swiperParams[key][oldKey] !==
                                oldParams[key][oldKey] && addKey(key);
                            }));
                      } else
                        swiperParams[key] !== oldParams[key] && addKey(key);
                  }),
                keys
              );
            })(
              passedParams,
              oldPassedParamsRef.current,
              slides,
              oldSlides.current,
              (c) => c.key
            );
            return (
              (oldPassedParamsRef.current = passedParams),
              (oldSlides.current = slides),
              changedParams.length &&
                swiperRef.current &&
                !swiperRef.current.destroyed &&
                updateSwiper({
                  swiper: swiperRef.current,
                  slides,
                  passedParams,
                  changedParams,
                  nextEl: nextElRef.current,
                  prevEl: prevElRef.current,
                  scrollbarEl: scrollbarElRef.current,
                  paginationEl: paginationElRef.current,
                }),
              () => {
                events &&
                  swiperRef.current &&
                  Object.keys(events).forEach((eventName) => {
                    swiperRef.current.off(eventName, events[eventName]);
                  });
              }
            );
          }),
          useIsomorphicLayoutEffect(() => {
            var swiper;
            !(swiper = swiperRef.current) ||
              swiper.destroyed ||
              !swiper.params.virtual ||
              (swiper.params.virtual && !swiper.params.virtual.enabled) ||
              (swiper.updateSlides(),
              swiper.updateProgress(),
              swiper.updateSlidesClasses(),
              swiper.lazy && swiper.params.lazy.enabled && swiper.lazy.load(),
              swiper.parallax &&
                swiper.params.parallax &&
                swiper.params.parallax.enabled &&
                swiper.parallax.setTranslate());
          }, [virtualData]),
          react.createElement(
            Tag,
            _extends(
              {
                ref: swiperElRef,
                className: uniqueClasses(
                  `${containerClasses}${className ? ` ${className}` : ''}`
                ),
              },
              restProps
            ),
            react.createElement(
              SwiperContext.Provider,
              { value: swiperRef.current },
              slots['container-start'],
              react.createElement(
                WrapperTag,
                { className: 'swiper-wrapper' },
                slots['wrapper-start'],
                (function renderSlides() {
                  return swiperParams.virtual
                    ? (function renderVirtual(swiper, slides, virtualData) {
                        if (!virtualData) return null;
                        const style = swiper.isHorizontal()
                          ? {
                              [swiper.rtlTranslate
                                ? 'right'
                                : 'left']: `${virtualData.offset}px`,
                            }
                          : { top: `${virtualData.offset}px` };
                        return slides
                          .filter(
                            (child, index) =>
                              index >= virtualData.from &&
                              index <= virtualData.to
                          )
                          .map((child) =>
                            react.cloneElement(child, { swiper, style })
                          );
                      })(swiperRef.current, slides, virtualData)
                    : !swiperParams.loop ||
                      (swiperRef.current && swiperRef.current.destroyed)
                    ? slides.map((child) =>
                        react.cloneElement(child, { swiper: swiperRef.current })
                      )
                    : (function renderLoop(swiper, slides, swiperParams) {
                        const modifiedSlides = slides.map((child, index) =>
                          react.cloneElement(child, {
                            swiper,
                            'data-swiper-slide-index': index,
                          })
                        );
                        function duplicateSlide(child, index, position) {
                          return react.cloneElement(child, {
                            key: `${child.key}-duplicate-${index}-${position}`,
                            className: `${child.props.className || ''} ${
                              swiperParams.slideDuplicateClass
                            }`,
                          });
                        }
                        if (swiperParams.loopFillGroupWithBlank) {
                          const blankSlidesNum =
                            swiperParams.slidesPerGroup -
                            (modifiedSlides.length %
                              swiperParams.slidesPerGroup);
                          if (blankSlidesNum !== swiperParams.slidesPerGroup)
                            for (let i = 0; i < blankSlidesNum; i += 1) {
                              const blankSlide = react.createElement('div', {
                                className: `${swiperParams.slideClass} ${swiperParams.slideBlankClass}`,
                              });
                              modifiedSlides.push(blankSlide);
                            }
                        }
                        'auto' !== swiperParams.slidesPerView ||
                          swiperParams.loopedSlides ||
                          (swiperParams.loopedSlides = modifiedSlides.length);
                        const loopedSlides = calcLoopedSlides(
                            modifiedSlides,
                            swiperParams
                          ),
                          prependSlides = [],
                          appendSlides = [];
                        for (let i = 0; i < loopedSlides; i += 1) {
                          const index =
                            i -
                            Math.floor(i / modifiedSlides.length) *
                              modifiedSlides.length;
                          appendSlides.push(
                            duplicateSlide(modifiedSlides[index], i, 'append')
                          ),
                            prependSlides.unshift(
                              duplicateSlide(
                                modifiedSlides[
                                  modifiedSlides.length - index - 1
                                ],
                                i,
                                'prepend'
                              )
                            );
                        }
                        return (
                          swiper && (swiper.loopedSlides = loopedSlides),
                          [...prependSlides, ...modifiedSlides, ...appendSlides]
                        );
                      })(swiperRef.current, slides, swiperParams);
                })(),
                slots['wrapper-end']
              ),
              needsNavigation(swiperParams) &&
                react.createElement(
                  react.Fragment,
                  null,
                  react.createElement('div', {
                    ref: prevElRef,
                    className: 'swiper-button-prev',
                  }),
                  react.createElement('div', {
                    ref: nextElRef,
                    className: 'swiper-button-next',
                  })
                ),
              needsScrollbar(swiperParams) &&
                react.createElement('div', {
                  ref: scrollbarElRef,
                  className: 'swiper-scrollbar',
                }),
              needsPagination(swiperParams) &&
                react.createElement('div', {
                  ref: paginationElRef,
                  className: 'swiper-pagination',
                }),
              slots['container-end']
            )
          )
        );
      });
      function swiper_slide_extends() {
        return (
          (swiper_slide_extends = Object.assign
            ? Object.assign.bind()
            : function (target) {
                for (var i = 1; i < arguments.length; i++) {
                  var source = arguments[i];
                  for (var key in source)
                    Object.prototype.hasOwnProperty.call(source, key) &&
                      (target[key] = source[key]);
                }
                return target;
              }),
          swiper_slide_extends.apply(this, arguments)
        );
      }
      Swiper.displayName = 'Swiper';
      const SwiperSlide = (0, react.forwardRef)(function (_temp, externalRef) {
        let {
          tag: Tag = 'div',
          children,
          className = '',
          swiper,
          zoom,
          virtualIndex,
          ...rest
        } = void 0 === _temp ? {} : _temp;
        const slideElRef = (0, react.useRef)(null),
          [slideClasses, setSlideClasses] = (0, react.useState)('swiper-slide');
        function updateClasses(_s, el, classNames) {
          el === slideElRef.current && setSlideClasses(classNames);
        }
        useIsomorphicLayoutEffect(() => {
          if (
            (externalRef && (externalRef.current = slideElRef.current),
            slideElRef.current && swiper)
          ) {
            if (!swiper.destroyed)
              return (
                swiper.on('_slideClass', updateClasses),
                () => {
                  swiper && swiper.off('_slideClass', updateClasses);
                }
              );
            'swiper-slide' !== slideClasses && setSlideClasses('swiper-slide');
          }
        }),
          useIsomorphicLayoutEffect(() => {
            swiper &&
              slideElRef.current &&
              !swiper.destroyed &&
              setSlideClasses(swiper.getSlideClasses(slideElRef.current));
          }, [swiper]);
        const slideData = {
            isActive:
              slideClasses.indexOf('swiper-slide-active') >= 0 ||
              slideClasses.indexOf('swiper-slide-duplicate-active') >= 0,
            isVisible: slideClasses.indexOf('swiper-slide-visible') >= 0,
            isDuplicate: slideClasses.indexOf('swiper-slide-duplicate') >= 0,
            isPrev:
              slideClasses.indexOf('swiper-slide-prev') >= 0 ||
              slideClasses.indexOf('swiper-slide-duplicate-prev') >= 0,
            isNext:
              slideClasses.indexOf('swiper-slide-next') >= 0 ||
              slideClasses.indexOf('swiper-slide-duplicate-next') >= 0,
          },
          renderChildren = () =>
            'function' == typeof children ? children(slideData) : children;
        return react.createElement(
          Tag,
          swiper_slide_extends(
            {
              ref: slideElRef,
              className: uniqueClasses(
                `${slideClasses}${className ? ` ${className}` : ''}`
              ),
              'data-swiper-slide-index': virtualIndex,
            },
            rest
          ),
          react.createElement(
            SwiperSlideContext.Provider,
            { value: slideData },
            zoom
              ? react.createElement(
                  'div',
                  {
                    className: 'swiper-zoom-container',
                    'data-swiper-zoom': 'number' == typeof zoom ? zoom : void 0,
                  },
                  renderChildren()
                )
              : renderChildren()
          )
        );
      });
      SwiperSlide.displayName = 'SwiperSlide';
    },
    './node_modules/swiper/swiper.esm.js': (
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) => {
      'use strict';
      function ssr_window_esm_isObject(obj) {
        return (
          null !== obj &&
          'object' == typeof obj &&
          'constructor' in obj &&
          obj.constructor === Object
        );
      }
      function extend(target = {}, src = {}) {
        Object.keys(src).forEach((key) => {
          void 0 === target[key]
            ? (target[key] = src[key])
            : ssr_window_esm_isObject(src[key]) &&
              ssr_window_esm_isObject(target[key]) &&
              Object.keys(src[key]).length > 0 &&
              extend(target[key], src[key]);
        });
      }
      __webpack_require__.d(__webpack_exports__, {
        W_: () => Navigation,
        tl: () => Pagination,
        ZP: () => core,
      });
      const ssrDocument = {
        body: {},
        addEventListener() {},
        removeEventListener() {},
        activeElement: { blur() {}, nodeName: '' },
        querySelector: () => null,
        querySelectorAll: () => [],
        getElementById: () => null,
        createEvent: () => ({ initEvent() {} }),
        createElement: () => ({
          children: [],
          childNodes: [],
          style: {},
          setAttribute() {},
          getElementsByTagName: () => [],
        }),
        createElementNS: () => ({}),
        importNode: () => null,
        location: {
          hash: '',
          host: '',
          hostname: '',
          href: '',
          origin: '',
          pathname: '',
          protocol: '',
          search: '',
        },
      };
      function ssr_window_esm_getDocument() {
        const doc = 'undefined' != typeof document ? document : {};
        return extend(doc, ssrDocument), doc;
      }
      const ssrWindow = {
        document: ssrDocument,
        navigator: { userAgent: '' },
        location: {
          hash: '',
          host: '',
          hostname: '',
          href: '',
          origin: '',
          pathname: '',
          protocol: '',
          search: '',
        },
        history: { replaceState() {}, pushState() {}, go() {}, back() {} },
        CustomEvent: function CustomEvent() {
          return this;
        },
        addEventListener() {},
        removeEventListener() {},
        getComputedStyle: () => ({ getPropertyValue: () => '' }),
        Image() {},
        Date() {},
        screen: {},
        setTimeout() {},
        clearTimeout() {},
        matchMedia: () => ({}),
        requestAnimationFrame: (callback) =>
          'undefined' == typeof setTimeout
            ? (callback(), null)
            : setTimeout(callback, 0),
        cancelAnimationFrame(id) {
          'undefined' != typeof setTimeout && clearTimeout(id);
        },
      };
      function ssr_window_esm_getWindow() {
        const win = 'undefined' != typeof window ? window : {};
        return extend(win, ssrWindow), win;
      }
      class Dom7 extends Array {
        constructor(items) {
          'number' == typeof items
            ? super(items)
            : (super(...(items || [])),
              (function makeReactive(obj) {
                const proto = obj.__proto__;
                Object.defineProperty(obj, '__proto__', {
                  get: () => proto,
                  set(value) {
                    proto.__proto__ = value;
                  },
                });
              })(this));
        }
      }
      function arrayFlat(arr = []) {
        const res = [];
        return (
          arr.forEach((el) => {
            Array.isArray(el) ? res.push(...arrayFlat(el)) : res.push(el);
          }),
          res
        );
      }
      function arrayFilter(arr, callback) {
        return Array.prototype.filter.call(arr, callback);
      }
      function dom7_esm_$(selector, context) {
        const window = ssr_window_esm_getWindow(),
          document = ssr_window_esm_getDocument();
        let arr = [];
        if (!context && selector instanceof Dom7) return selector;
        if (!selector) return new Dom7(arr);
        if ('string' == typeof selector) {
          const html = selector.trim();
          if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
            let toCreate = 'div';
            0 === html.indexOf('<li') && (toCreate = 'ul'),
              0 === html.indexOf('<tr') && (toCreate = 'tbody'),
              (0 !== html.indexOf('<td') && 0 !== html.indexOf('<th')) ||
                (toCreate = 'tr'),
              0 === html.indexOf('<tbody') && (toCreate = 'table'),
              0 === html.indexOf('<option') && (toCreate = 'select');
            const tempParent = document.createElement(toCreate);
            tempParent.innerHTML = html;
            for (let i = 0; i < tempParent.childNodes.length; i += 1)
              arr.push(tempParent.childNodes[i]);
          } else
            arr = (function qsa(selector, context) {
              if ('string' != typeof selector) return [selector];
              const a = [],
                res = context.querySelectorAll(selector);
              for (let i = 0; i < res.length; i += 1) a.push(res[i]);
              return a;
            })(selector.trim(), context || document);
        } else if (
          selector.nodeType ||
          selector === window ||
          selector === document
        )
          arr.push(selector);
        else if (Array.isArray(selector)) {
          if (selector instanceof Dom7) return selector;
          arr = selector;
        }
        return new Dom7(
          (function arrayUnique(arr) {
            const uniqueArray = [];
            for (let i = 0; i < arr.length; i += 1)
              -1 === uniqueArray.indexOf(arr[i]) && uniqueArray.push(arr[i]);
            return uniqueArray;
          })(arr)
        );
      }
      dom7_esm_$.fn = Dom7.prototype;
      const noTrigger = 'resize scroll'.split(' ');
      function shortcut(name) {
        return function eventHandler(...args) {
          if (void 0 === args[0]) {
            for (let i = 0; i < this.length; i += 1)
              noTrigger.indexOf(name) < 0 &&
                (name in this[i]
                  ? this[i][name]()
                  : dom7_esm_$(this[i]).trigger(name));
            return this;
          }
          return this.on(name, ...args);
        };
      }
      shortcut('click'),
        shortcut('blur'),
        shortcut('focus'),
        shortcut('focusin'),
        shortcut('focusout'),
        shortcut('keyup'),
        shortcut('keydown'),
        shortcut('keypress'),
        shortcut('submit'),
        shortcut('change'),
        shortcut('mousedown'),
        shortcut('mousemove'),
        shortcut('mouseup'),
        shortcut('mouseenter'),
        shortcut('mouseleave'),
        shortcut('mouseout'),
        shortcut('mouseover'),
        shortcut('touchstart'),
        shortcut('touchend'),
        shortcut('touchmove'),
        shortcut('resize'),
        shortcut('scroll');
      const Methods = {
        addClass: function addClass(...classes) {
          const classNames = arrayFlat(classes.map((c) => c.split(' ')));
          return (
            this.forEach((el) => {
              el.classList.add(...classNames);
            }),
            this
          );
        },
        removeClass: function removeClass(...classes) {
          const classNames = arrayFlat(classes.map((c) => c.split(' ')));
          return (
            this.forEach((el) => {
              el.classList.remove(...classNames);
            }),
            this
          );
        },
        hasClass: function hasClass(...classes) {
          const classNames = arrayFlat(classes.map((c) => c.split(' ')));
          return (
            arrayFilter(
              this,
              (el) =>
                classNames.filter((className) =>
                  el.classList.contains(className)
                ).length > 0
            ).length > 0
          );
        },
        toggleClass: function toggleClass(...classes) {
          const classNames = arrayFlat(classes.map((c) => c.split(' ')));
          this.forEach((el) => {
            classNames.forEach((className) => {
              el.classList.toggle(className);
            });
          });
        },
        attr: function attr(attrs, value) {
          if (1 === arguments.length && 'string' == typeof attrs)
            return this[0] ? this[0].getAttribute(attrs) : void 0;
          for (let i = 0; i < this.length; i += 1)
            if (2 === arguments.length) this[i].setAttribute(attrs, value);
            else
              for (const attrName in attrs)
                (this[i][attrName] = attrs[attrName]),
                  this[i].setAttribute(attrName, attrs[attrName]);
          return this;
        },
        removeAttr: function removeAttr(attr) {
          for (let i = 0; i < this.length; i += 1)
            this[i].removeAttribute(attr);
          return this;
        },
        transform: function transform(transform) {
          for (let i = 0; i < this.length; i += 1)
            this[i].style.transform = transform;
          return this;
        },
        transition: function transition(duration) {
          for (let i = 0; i < this.length; i += 1)
            this[i].style.transitionDuration =
              'string' != typeof duration ? `${duration}ms` : duration;
          return this;
        },
        on: function on(...args) {
          let [eventType, targetSelector, listener, capture] = args;
          function handleLiveEvent(e) {
            const target = e.target;
            if (!target) return;
            const eventData = e.target.dom7EventData || [];
            if (
              (eventData.indexOf(e) < 0 && eventData.unshift(e),
              dom7_esm_$(target).is(targetSelector))
            )
              listener.apply(target, eventData);
            else {
              const parents = dom7_esm_$(target).parents();
              for (let k = 0; k < parents.length; k += 1)
                dom7_esm_$(parents[k]).is(targetSelector) &&
                  listener.apply(parents[k], eventData);
            }
          }
          function handleEvent(e) {
            const eventData = (e && e.target && e.target.dom7EventData) || [];
            eventData.indexOf(e) < 0 && eventData.unshift(e),
              listener.apply(this, eventData);
          }
          'function' == typeof args[1] &&
            (([eventType, listener, capture] = args),
            (targetSelector = void 0)),
            capture || (capture = !1);
          const events = eventType.split(' ');
          let j;
          for (let i = 0; i < this.length; i += 1) {
            const el = this[i];
            if (targetSelector)
              for (j = 0; j < events.length; j += 1) {
                const event = events[j];
                el.dom7LiveListeners || (el.dom7LiveListeners = {}),
                  el.dom7LiveListeners[event] ||
                    (el.dom7LiveListeners[event] = []),
                  el.dom7LiveListeners[event].push({
                    listener,
                    proxyListener: handleLiveEvent,
                  }),
                  el.addEventListener(event, handleLiveEvent, capture);
              }
            else
              for (j = 0; j < events.length; j += 1) {
                const event = events[j];
                el.dom7Listeners || (el.dom7Listeners = {}),
                  el.dom7Listeners[event] || (el.dom7Listeners[event] = []),
                  el.dom7Listeners[event].push({
                    listener,
                    proxyListener: handleEvent,
                  }),
                  el.addEventListener(event, handleEvent, capture);
              }
          }
          return this;
        },
        off: function off(...args) {
          let [eventType, targetSelector, listener, capture] = args;
          'function' == typeof args[1] &&
            (([eventType, listener, capture] = args),
            (targetSelector = void 0)),
            capture || (capture = !1);
          const events = eventType.split(' ');
          for (let i = 0; i < events.length; i += 1) {
            const event = events[i];
            for (let j = 0; j < this.length; j += 1) {
              const el = this[j];
              let handlers;
              if (
                (!targetSelector && el.dom7Listeners
                  ? (handlers = el.dom7Listeners[event])
                  : targetSelector &&
                    el.dom7LiveListeners &&
                    (handlers = el.dom7LiveListeners[event]),
                handlers && handlers.length)
              )
                for (let k = handlers.length - 1; k >= 0; k -= 1) {
                  const handler = handlers[k];
                  (listener && handler.listener === listener) ||
                  (listener &&
                    handler.listener &&
                    handler.listener.dom7proxy &&
                    handler.listener.dom7proxy === listener)
                    ? (el.removeEventListener(
                        event,
                        handler.proxyListener,
                        capture
                      ),
                      handlers.splice(k, 1))
                    : listener ||
                      (el.removeEventListener(
                        event,
                        handler.proxyListener,
                        capture
                      ),
                      handlers.splice(k, 1));
                }
            }
          }
          return this;
        },
        trigger: function trigger(...args) {
          const window = ssr_window_esm_getWindow(),
            events = args[0].split(' '),
            eventData = args[1];
          for (let i = 0; i < events.length; i += 1) {
            const event = events[i];
            for (let j = 0; j < this.length; j += 1) {
              const el = this[j];
              if (window.CustomEvent) {
                const evt = new window.CustomEvent(event, {
                  detail: eventData,
                  bubbles: !0,
                  cancelable: !0,
                });
                (el.dom7EventData = args.filter(
                  (data, dataIndex) => dataIndex > 0
                )),
                  el.dispatchEvent(evt),
                  (el.dom7EventData = []),
                  delete el.dom7EventData;
              }
            }
          }
          return this;
        },
        transitionEnd: function transitionEnd(callback) {
          const dom = this;
          return (
            callback &&
              dom.on('transitionend', function fireCallBack(e) {
                e.target === this &&
                  (callback.call(this, e),
                  dom.off('transitionend', fireCallBack));
              }),
            this
          );
        },
        outerWidth: function dom7_esm_outerWidth(includeMargins) {
          if (this.length > 0) {
            if (includeMargins) {
              const styles = this.styles();
              return (
                this[0].offsetWidth +
                parseFloat(styles.getPropertyValue('margin-right')) +
                parseFloat(styles.getPropertyValue('margin-left'))
              );
            }
            return this[0].offsetWidth;
          }
          return null;
        },
        outerHeight: function dom7_esm_outerHeight(includeMargins) {
          if (this.length > 0) {
            if (includeMargins) {
              const styles = this.styles();
              return (
                this[0].offsetHeight +
                parseFloat(styles.getPropertyValue('margin-top')) +
                parseFloat(styles.getPropertyValue('margin-bottom'))
              );
            }
            return this[0].offsetHeight;
          }
          return null;
        },
        styles: function styles() {
          const window = ssr_window_esm_getWindow();
          return this[0] ? window.getComputedStyle(this[0], null) : {};
        },
        offset: function offset() {
          if (this.length > 0) {
            const window = ssr_window_esm_getWindow(),
              document = ssr_window_esm_getDocument(),
              el = this[0],
              box = el.getBoundingClientRect(),
              body = document.body,
              clientTop = el.clientTop || body.clientTop || 0,
              clientLeft = el.clientLeft || body.clientLeft || 0,
              scrollTop = el === window ? window.scrollY : el.scrollTop,
              scrollLeft = el === window ? window.scrollX : el.scrollLeft;
            return {
              top: box.top + scrollTop - clientTop,
              left: box.left + scrollLeft - clientLeft,
            };
          }
          return null;
        },
        css: function css(props, value) {
          const window = ssr_window_esm_getWindow();
          let i;
          if (1 === arguments.length) {
            if ('string' != typeof props) {
              for (i = 0; i < this.length; i += 1)
                for (const prop in props) this[i].style[prop] = props[prop];
              return this;
            }
            if (this[0])
              return window
                .getComputedStyle(this[0], null)
                .getPropertyValue(props);
          }
          if (2 === arguments.length && 'string' == typeof props) {
            for (i = 0; i < this.length; i += 1) this[i].style[props] = value;
            return this;
          }
          return this;
        },
        each: function each(callback) {
          return callback
            ? (this.forEach((el, index) => {
                callback.apply(el, [el, index]);
              }),
              this)
            : this;
        },
        html: function html(html) {
          if (void 0 === html) return this[0] ? this[0].innerHTML : null;
          for (let i = 0; i < this.length; i += 1) this[i].innerHTML = html;
          return this;
        },
        text: function dom7_esm_text(text) {
          if (void 0 === text)
            return this[0] ? this[0].textContent.trim() : null;
          for (let i = 0; i < this.length; i += 1) this[i].textContent = text;
          return this;
        },
        is: function is(selector) {
          const window = ssr_window_esm_getWindow(),
            document = ssr_window_esm_getDocument(),
            el = this[0];
          let compareWith, i;
          if (!el || void 0 === selector) return !1;
          if ('string' == typeof selector) {
            if (el.matches) return el.matches(selector);
            if (el.webkitMatchesSelector)
              return el.webkitMatchesSelector(selector);
            if (el.msMatchesSelector) return el.msMatchesSelector(selector);
            for (
              compareWith = dom7_esm_$(selector), i = 0;
              i < compareWith.length;
              i += 1
            )
              if (compareWith[i] === el) return !0;
            return !1;
          }
          if (selector === document) return el === document;
          if (selector === window) return el === window;
          if (selector.nodeType || selector instanceof Dom7) {
            for (
              compareWith = selector.nodeType ? [selector] : selector, i = 0;
              i < compareWith.length;
              i += 1
            )
              if (compareWith[i] === el) return !0;
            return !1;
          }
          return !1;
        },
        index: function index() {
          let i,
            child = this[0];
          if (child) {
            for (i = 0; null !== (child = child.previousSibling); )
              1 === child.nodeType && (i += 1);
            return i;
          }
        },
        eq: function eq(index) {
          if (void 0 === index) return this;
          const length = this.length;
          if (index > length - 1) return dom7_esm_$([]);
          if (index < 0) {
            const returnIndex = length + index;
            return dom7_esm_$(returnIndex < 0 ? [] : [this[returnIndex]]);
          }
          return dom7_esm_$([this[index]]);
        },
        append: function append(...els) {
          let newChild;
          const document = ssr_window_esm_getDocument();
          for (let k = 0; k < els.length; k += 1) {
            newChild = els[k];
            for (let i = 0; i < this.length; i += 1)
              if ('string' == typeof newChild) {
                const tempDiv = document.createElement('div');
                for (tempDiv.innerHTML = newChild; tempDiv.firstChild; )
                  this[i].appendChild(tempDiv.firstChild);
              } else if (newChild instanceof Dom7)
                for (let j = 0; j < newChild.length; j += 1)
                  this[i].appendChild(newChild[j]);
              else this[i].appendChild(newChild);
          }
          return this;
        },
        prepend: function prepend(newChild) {
          const document = ssr_window_esm_getDocument();
          let i, j;
          for (i = 0; i < this.length; i += 1)
            if ('string' == typeof newChild) {
              const tempDiv = document.createElement('div');
              for (
                tempDiv.innerHTML = newChild, j = tempDiv.childNodes.length - 1;
                j >= 0;
                j -= 1
              )
                this[i].insertBefore(
                  tempDiv.childNodes[j],
                  this[i].childNodes[0]
                );
            } else if (newChild instanceof Dom7)
              for (j = 0; j < newChild.length; j += 1)
                this[i].insertBefore(newChild[j], this[i].childNodes[0]);
            else this[i].insertBefore(newChild, this[i].childNodes[0]);
          return this;
        },
        next: function next(selector) {
          return this.length > 0
            ? selector
              ? this[0].nextElementSibling &&
                dom7_esm_$(this[0].nextElementSibling).is(selector)
                ? dom7_esm_$([this[0].nextElementSibling])
                : dom7_esm_$([])
              : this[0].nextElementSibling
              ? dom7_esm_$([this[0].nextElementSibling])
              : dom7_esm_$([])
            : dom7_esm_$([]);
        },
        nextAll: function nextAll(selector) {
          const nextEls = [];
          let el = this[0];
          if (!el) return dom7_esm_$([]);
          for (; el.nextElementSibling; ) {
            const next = el.nextElementSibling;
            selector
              ? dom7_esm_$(next).is(selector) && nextEls.push(next)
              : nextEls.push(next),
              (el = next);
          }
          return dom7_esm_$(nextEls);
        },
        prev: function prev(selector) {
          if (this.length > 0) {
            const el = this[0];
            return selector
              ? el.previousElementSibling &&
                dom7_esm_$(el.previousElementSibling).is(selector)
                ? dom7_esm_$([el.previousElementSibling])
                : dom7_esm_$([])
              : el.previousElementSibling
              ? dom7_esm_$([el.previousElementSibling])
              : dom7_esm_$([]);
          }
          return dom7_esm_$([]);
        },
        prevAll: function prevAll(selector) {
          const prevEls = [];
          let el = this[0];
          if (!el) return dom7_esm_$([]);
          for (; el.previousElementSibling; ) {
            const prev = el.previousElementSibling;
            selector
              ? dom7_esm_$(prev).is(selector) && prevEls.push(prev)
              : prevEls.push(prev),
              (el = prev);
          }
          return dom7_esm_$(prevEls);
        },
        parent: function dom7_esm_parent(selector) {
          const parents = [];
          for (let i = 0; i < this.length; i += 1)
            null !== this[i].parentNode &&
              (selector
                ? dom7_esm_$(this[i].parentNode).is(selector) &&
                  parents.push(this[i].parentNode)
                : parents.push(this[i].parentNode));
          return dom7_esm_$(parents);
        },
        parents: function parents(selector) {
          const parents = [];
          for (let i = 0; i < this.length; i += 1) {
            let parent = this[i].parentNode;
            for (; parent; )
              selector
                ? dom7_esm_$(parent).is(selector) && parents.push(parent)
                : parents.push(parent),
                (parent = parent.parentNode);
          }
          return dom7_esm_$(parents);
        },
        closest: function closest(selector) {
          let closest = this;
          return void 0 === selector
            ? dom7_esm_$([])
            : (closest.is(selector) ||
                (closest = closest.parents(selector).eq(0)),
              closest);
        },
        find: function find(selector) {
          const foundElements = [];
          for (let i = 0; i < this.length; i += 1) {
            const found = this[i].querySelectorAll(selector);
            for (let j = 0; j < found.length; j += 1)
              foundElements.push(found[j]);
          }
          return dom7_esm_$(foundElements);
        },
        children: function children(selector) {
          const children = [];
          for (let i = 0; i < this.length; i += 1) {
            const childNodes = this[i].children;
            for (let j = 0; j < childNodes.length; j += 1)
              (selector && !dom7_esm_$(childNodes[j]).is(selector)) ||
                children.push(childNodes[j]);
          }
          return dom7_esm_$(children);
        },
        filter: function filter(callback) {
          return dom7_esm_$(arrayFilter(this, callback));
        },
        remove: function remove() {
          for (let i = 0; i < this.length; i += 1)
            this[i].parentNode && this[i].parentNode.removeChild(this[i]);
          return this;
        },
      };
      Object.keys(Methods).forEach((methodName) => {
        Object.defineProperty(dom7_esm_$.fn, methodName, {
          value: Methods[methodName],
          writable: !0,
        });
      });
      const dom = dom7_esm_$;
      function utils_nextTick(callback, delay = 0) {
        return setTimeout(callback, delay);
      }
      function utils_now() {
        return Date.now();
      }
      function utils_getTranslate(el, axis = 'x') {
        const window = ssr_window_esm_getWindow();
        let matrix, curTransform, transformMatrix;
        const curStyle = (function utils_getComputedStyle(el) {
          const window = ssr_window_esm_getWindow();
          let style;
          return (
            window.getComputedStyle &&
              (style = window.getComputedStyle(el, null)),
            !style && el.currentStyle && (style = el.currentStyle),
            style || (style = el.style),
            style
          );
        })(el);
        return (
          window.WebKitCSSMatrix
            ? ((curTransform = curStyle.transform || curStyle.webkitTransform),
              curTransform.split(',').length > 6 &&
                (curTransform = curTransform
                  .split(', ')
                  .map((a) => a.replace(',', '.'))
                  .join(', ')),
              (transformMatrix = new window.WebKitCSSMatrix(
                'none' === curTransform ? '' : curTransform
              )))
            : ((transformMatrix =
                curStyle.MozTransform ||
                curStyle.OTransform ||
                curStyle.MsTransform ||
                curStyle.msTransform ||
                curStyle.transform ||
                curStyle
                  .getPropertyValue('transform')
                  .replace('translate(', 'matrix(1, 0, 0, 1,')),
              (matrix = transformMatrix.toString().split(','))),
          'x' === axis &&
            (curTransform = window.WebKitCSSMatrix
              ? transformMatrix.m41
              : 16 === matrix.length
              ? parseFloat(matrix[12])
              : parseFloat(matrix[4])),
          'y' === axis &&
            (curTransform = window.WebKitCSSMatrix
              ? transformMatrix.m42
              : 16 === matrix.length
              ? parseFloat(matrix[13])
              : parseFloat(matrix[5])),
          curTransform || 0
        );
      }
      function utils_isObject(o) {
        return (
          'object' == typeof o &&
          null !== o &&
          o.constructor &&
          'Object' === Object.prototype.toString.call(o).slice(8, -1)
        );
      }
      function utils_extend(...args) {
        const to = Object(args[0]),
          noExtend = ['__proto__', 'constructor', 'prototype'];
        for (let i = 1; i < args.length; i += 1) {
          const nextSource = args[i];
          if (
            null != nextSource &&
            ((node = nextSource),
            !('undefined' != typeof window && void 0 !== window.HTMLElement
              ? node instanceof HTMLElement
              : node && (1 === node.nodeType || 11 === node.nodeType)))
          ) {
            const keysArray = Object.keys(Object(nextSource)).filter(
              (key) => noExtend.indexOf(key) < 0
            );
            for (
              let nextIndex = 0, len = keysArray.length;
              nextIndex < len;
              nextIndex += 1
            ) {
              const nextKey = keysArray[nextIndex],
                desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
              void 0 !== desc &&
                desc.enumerable &&
                (utils_isObject(to[nextKey]) &&
                utils_isObject(nextSource[nextKey])
                  ? nextSource[nextKey].__swiper__
                    ? (to[nextKey] = nextSource[nextKey])
                    : utils_extend(to[nextKey], nextSource[nextKey])
                  : !utils_isObject(to[nextKey]) &&
                    utils_isObject(nextSource[nextKey])
                  ? ((to[nextKey] = {}),
                    nextSource[nextKey].__swiper__
                      ? (to[nextKey] = nextSource[nextKey])
                      : utils_extend(to[nextKey], nextSource[nextKey]))
                  : (to[nextKey] = nextSource[nextKey]));
            }
          }
        }
        var node;
        return to;
      }
      function utils_setCSSProperty(el, varName, varValue) {
        el.style.setProperty(varName, varValue);
      }
      function animateCSSModeScroll({ swiper, targetPosition, side }) {
        const window = ssr_window_esm_getWindow(),
          startPosition = -swiper.translate;
        let time,
          startTime = null;
        const duration = swiper.params.speed;
        (swiper.wrapperEl.style.scrollSnapType = 'none'),
          window.cancelAnimationFrame(swiper.cssModeFrameID);
        const dir = targetPosition > startPosition ? 'next' : 'prev',
          isOutOfBound = (current, target) =>
            ('next' === dir && current >= target) ||
            ('prev' === dir && current <= target),
          animate = () => {
            (time = new Date().getTime()),
              null === startTime && (startTime = time);
            const progress = Math.max(
                Math.min((time - startTime) / duration, 1),
                0
              ),
              easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
            let currentPosition =
              startPosition + easeProgress * (targetPosition - startPosition);
            if (
              (isOutOfBound(currentPosition, targetPosition) &&
                (currentPosition = targetPosition),
              swiper.wrapperEl.scrollTo({ [side]: currentPosition }),
              isOutOfBound(currentPosition, targetPosition))
            )
              return (
                (swiper.wrapperEl.style.overflow = 'hidden'),
                (swiper.wrapperEl.style.scrollSnapType = ''),
                setTimeout(() => {
                  (swiper.wrapperEl.style.overflow = ''),
                    swiper.wrapperEl.scrollTo({ [side]: currentPosition });
                }),
                void window.cancelAnimationFrame(swiper.cssModeFrameID)
              );
            swiper.cssModeFrameID = window.requestAnimationFrame(animate);
          };
        animate();
      }
      let support, deviceCached, browser;
      function getSupport() {
        return (
          support ||
            (support = (function calcSupport() {
              const window = ssr_window_esm_getWindow(),
                document = ssr_window_esm_getDocument();
              return {
                smoothScroll:
                  document.documentElement &&
                  'scrollBehavior' in document.documentElement.style,
                touch: !!(
                  'ontouchstart' in window ||
                  (window.DocumentTouch &&
                    document instanceof window.DocumentTouch)
                ),
                passiveListener: (function checkPassiveListener() {
                  let supportsPassive = !1;
                  try {
                    const opts = Object.defineProperty({}, 'passive', {
                      get() {
                        supportsPassive = !0;
                      },
                    });
                    window.addEventListener('testPassiveListener', null, opts);
                  } catch (e) {}
                  return supportsPassive;
                })(),
                gestures: (function checkGestures() {
                  return 'ongesturestart' in window;
                })(),
              };
            })()),
          support
        );
      }
      function getDevice(overrides = {}) {
        return (
          deviceCached ||
            (deviceCached = (function calcDevice({ userAgent } = {}) {
              const support = getSupport(),
                window = ssr_window_esm_getWindow(),
                platform = window.navigator.platform,
                ua = userAgent || window.navigator.userAgent,
                device = { ios: !1, android: !1 },
                screenWidth = window.screen.width,
                screenHeight = window.screen.height,
                android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
              let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
              const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/),
                iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
                windows = 'Win32' === platform;
              let macos = 'MacIntel' === platform;
              return (
                !ipad &&
                  macos &&
                  support.touch &&
                  [
                    '1024x1366',
                    '1366x1024',
                    '834x1194',
                    '1194x834',
                    '834x1112',
                    '1112x834',
                    '768x1024',
                    '1024x768',
                    '820x1180',
                    '1180x820',
                    '810x1080',
                    '1080x810',
                  ].indexOf(`${screenWidth}x${screenHeight}`) >= 0 &&
                  ((ipad = ua.match(/(Version)\/([\d.]+)/)),
                  ipad || (ipad = [0, 1, '13_0_0']),
                  (macos = !1)),
                android &&
                  !windows &&
                  ((device.os = 'android'), (device.android = !0)),
                (ipad || iphone || ipod) &&
                  ((device.os = 'ios'), (device.ios = !0)),
                device
              );
            })(overrides)),
          deviceCached
        );
      }
      function getBrowser() {
        return (
          browser ||
            (browser = (function calcBrowser() {
              const window = ssr_window_esm_getWindow();
              return {
                isSafari: (function isSafari() {
                  const ua = window.navigator.userAgent.toLowerCase();
                  return (
                    ua.indexOf('safari') >= 0 &&
                    ua.indexOf('chrome') < 0 &&
                    ua.indexOf('android') < 0
                  );
                })(),
                isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(
                  window.navigator.userAgent
                ),
              };
            })()),
          browser
        );
      }
      const events_emitter = {
        on(events, handler, priority) {
          const self = this;
          if (!self.eventsListeners || self.destroyed) return self;
          if ('function' != typeof handler) return self;
          const method = priority ? 'unshift' : 'push';
          return (
            events.split(' ').forEach((event) => {
              self.eventsListeners[event] || (self.eventsListeners[event] = []),
                self.eventsListeners[event][method](handler);
            }),
            self
          );
        },
        once(events, handler, priority) {
          const self = this;
          if (!self.eventsListeners || self.destroyed) return self;
          if ('function' != typeof handler) return self;
          function onceHandler(...args) {
            self.off(events, onceHandler),
              onceHandler.__emitterProxy && delete onceHandler.__emitterProxy,
              handler.apply(self, args);
          }
          return (
            (onceHandler.__emitterProxy = handler),
            self.on(events, onceHandler, priority)
          );
        },
        onAny(handler, priority) {
          const self = this;
          if (!self.eventsListeners || self.destroyed) return self;
          if ('function' != typeof handler) return self;
          const method = priority ? 'unshift' : 'push';
          return (
            self.eventsAnyListeners.indexOf(handler) < 0 &&
              self.eventsAnyListeners[method](handler),
            self
          );
        },
        offAny(handler) {
          const self = this;
          if (!self.eventsListeners || self.destroyed) return self;
          if (!self.eventsAnyListeners) return self;
          const index = self.eventsAnyListeners.indexOf(handler);
          return index >= 0 && self.eventsAnyListeners.splice(index, 1), self;
        },
        off(events, handler) {
          const self = this;
          return !self.eventsListeners || self.destroyed
            ? self
            : self.eventsListeners
            ? (events.split(' ').forEach((event) => {
                void 0 === handler
                  ? (self.eventsListeners[event] = [])
                  : self.eventsListeners[event] &&
                    self.eventsListeners[event].forEach(
                      (eventHandler, index) => {
                        (eventHandler === handler ||
                          (eventHandler.__emitterProxy &&
                            eventHandler.__emitterProxy === handler)) &&
                          self.eventsListeners[event].splice(index, 1);
                      }
                    );
              }),
              self)
            : self;
        },
        emit(...args) {
          const self = this;
          if (!self.eventsListeners || self.destroyed) return self;
          if (!self.eventsListeners) return self;
          let events, data, context;
          'string' == typeof args[0] || Array.isArray(args[0])
            ? ((events = args[0]),
              (data = args.slice(1, args.length)),
              (context = self))
            : ((events = args[0].events),
              (data = args[0].data),
              (context = args[0].context || self)),
            data.unshift(context);
          return (
            (Array.isArray(events) ? events : events.split(' ')).forEach(
              (event) => {
                self.eventsAnyListeners &&
                  self.eventsAnyListeners.length &&
                  self.eventsAnyListeners.forEach((eventHandler) => {
                    eventHandler.apply(context, [event, ...data]);
                  }),
                  self.eventsListeners &&
                    self.eventsListeners[event] &&
                    self.eventsListeners[event].forEach((eventHandler) => {
                      eventHandler.apply(context, data);
                    });
              }
            ),
            self
          );
        },
      };
      const update = {
        updateSize: function updateSize() {
          const swiper = this;
          let width, height;
          const $el = swiper.$el;
          (width =
            void 0 !== swiper.params.width && null !== swiper.params.width
              ? swiper.params.width
              : $el[0].clientWidth),
            (height =
              void 0 !== swiper.params.height && null !== swiper.params.height
                ? swiper.params.height
                : $el[0].clientHeight),
            (0 === width && swiper.isHorizontal()) ||
              (0 === height && swiper.isVertical()) ||
              ((width =
                width -
                parseInt($el.css('padding-left') || 0, 10) -
                parseInt($el.css('padding-right') || 0, 10)),
              (height =
                height -
                parseInt($el.css('padding-top') || 0, 10) -
                parseInt($el.css('padding-bottom') || 0, 10)),
              Number.isNaN(width) && (width = 0),
              Number.isNaN(height) && (height = 0),
              Object.assign(swiper, {
                width,
                height,
                size: swiper.isHorizontal() ? width : height,
              }));
        },
        updateSlides: function updateSlides() {
          const swiper = this;
          function getDirectionLabel(property) {
            return swiper.isHorizontal()
              ? property
              : {
                  width: 'height',
                  'margin-top': 'margin-left',
                  'margin-bottom ': 'margin-right',
                  'margin-left': 'margin-top',
                  'margin-right': 'margin-bottom',
                  'padding-left': 'padding-top',
                  'padding-right': 'padding-bottom',
                  marginRight: 'marginBottom',
                }[property];
          }
          function getDirectionPropertyValue(node, label) {
            return parseFloat(
              node.getPropertyValue(getDirectionLabel(label)) || 0
            );
          }
          const params = swiper.params,
            {
              $wrapperEl,
              size: swiperSize,
              rtlTranslate: rtl,
              wrongRTL,
            } = swiper,
            isVirtual = swiper.virtual && params.virtual.enabled,
            previousSlidesLength = isVirtual
              ? swiper.virtual.slides.length
              : swiper.slides.length,
            slides = $wrapperEl.children(`.${swiper.params.slideClass}`),
            slidesLength = isVirtual
              ? swiper.virtual.slides.length
              : slides.length;
          let snapGrid = [];
          const slidesGrid = [],
            slidesSizesGrid = [];
          let offsetBefore = params.slidesOffsetBefore;
          'function' == typeof offsetBefore &&
            (offsetBefore = params.slidesOffsetBefore.call(swiper));
          let offsetAfter = params.slidesOffsetAfter;
          'function' == typeof offsetAfter &&
            (offsetAfter = params.slidesOffsetAfter.call(swiper));
          const previousSnapGridLength = swiper.snapGrid.length,
            previousSlidesGridLength = swiper.slidesGrid.length;
          let spaceBetween = params.spaceBetween,
            slidePosition = -offsetBefore,
            prevSlideSize = 0,
            index = 0;
          if (void 0 === swiperSize) return;
          'string' == typeof spaceBetween &&
            spaceBetween.indexOf('%') >= 0 &&
            (spaceBetween =
              (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize),
            (swiper.virtualSize = -spaceBetween),
            rtl
              ? slides.css({ marginLeft: '', marginBottom: '', marginTop: '' })
              : slides.css({
                  marginRight: '',
                  marginBottom: '',
                  marginTop: '',
                }),
            params.centeredSlides &&
              params.cssMode &&
              (utils_setCSSProperty(
                swiper.wrapperEl,
                '--swiper-centered-offset-before',
                ''
              ),
              utils_setCSSProperty(
                swiper.wrapperEl,
                '--swiper-centered-offset-after',
                ''
              ));
          const gridEnabled =
            params.grid && params.grid.rows > 1 && swiper.grid;
          let slideSize;
          gridEnabled && swiper.grid.initSlides(slidesLength);
          const shouldResetSlideSize =
            'auto' === params.slidesPerView &&
            params.breakpoints &&
            Object.keys(params.breakpoints).filter(
              (key) => void 0 !== params.breakpoints[key].slidesPerView
            ).length > 0;
          for (let i = 0; i < slidesLength; i += 1) {
            slideSize = 0;
            const slide = slides.eq(i);
            if (
              (gridEnabled &&
                swiper.grid.updateSlide(
                  i,
                  slide,
                  slidesLength,
                  getDirectionLabel
                ),
              'none' !== slide.css('display'))
            ) {
              if ('auto' === params.slidesPerView) {
                shouldResetSlideSize &&
                  (slides[i].style[getDirectionLabel('width')] = '');
                const slideStyles = getComputedStyle(slide[0]),
                  currentTransform = slide[0].style.transform,
                  currentWebKitTransform = slide[0].style.webkitTransform;
                if (
                  (currentTransform && (slide[0].style.transform = 'none'),
                  currentWebKitTransform &&
                    (slide[0].style.webkitTransform = 'none'),
                  params.roundLengths)
                )
                  slideSize = swiper.isHorizontal()
                    ? slide.outerWidth(!0)
                    : slide.outerHeight(!0);
                else {
                  const width = getDirectionPropertyValue(slideStyles, 'width'),
                    paddingLeft = getDirectionPropertyValue(
                      slideStyles,
                      'padding-left'
                    ),
                    paddingRight = getDirectionPropertyValue(
                      slideStyles,
                      'padding-right'
                    ),
                    marginLeft = getDirectionPropertyValue(
                      slideStyles,
                      'margin-left'
                    ),
                    marginRight = getDirectionPropertyValue(
                      slideStyles,
                      'margin-right'
                    ),
                    boxSizing = slideStyles.getPropertyValue('box-sizing');
                  if (boxSizing && 'border-box' === boxSizing)
                    slideSize = width + marginLeft + marginRight;
                  else {
                    const { clientWidth, offsetWidth } = slide[0];
                    slideSize =
                      width +
                      paddingLeft +
                      paddingRight +
                      marginLeft +
                      marginRight +
                      (offsetWidth - clientWidth);
                  }
                }
                currentTransform &&
                  (slide[0].style.transform = currentTransform),
                  currentWebKitTransform &&
                    (slide[0].style.webkitTransform = currentWebKitTransform),
                  params.roundLengths && (slideSize = Math.floor(slideSize));
              } else
                (slideSize =
                  (swiperSize - (params.slidesPerView - 1) * spaceBetween) /
                  params.slidesPerView),
                  params.roundLengths && (slideSize = Math.floor(slideSize)),
                  slides[i] &&
                    (slides[i].style[
                      getDirectionLabel('width')
                    ] = `${slideSize}px`);
              slides[i] && (slides[i].swiperSlideSize = slideSize),
                slidesSizesGrid.push(slideSize),
                params.centeredSlides
                  ? ((slidePosition =
                      slidePosition +
                      slideSize / 2 +
                      prevSlideSize / 2 +
                      spaceBetween),
                    0 === prevSlideSize &&
                      0 !== i &&
                      (slidePosition =
                        slidePosition - swiperSize / 2 - spaceBetween),
                    0 === i &&
                      (slidePosition =
                        slidePosition - swiperSize / 2 - spaceBetween),
                    Math.abs(slidePosition) < 0.001 && (slidePosition = 0),
                    params.roundLengths &&
                      (slidePosition = Math.floor(slidePosition)),
                    index % params.slidesPerGroup == 0 &&
                      snapGrid.push(slidePosition),
                    slidesGrid.push(slidePosition))
                  : (params.roundLengths &&
                      (slidePosition = Math.floor(slidePosition)),
                    (index -
                      Math.min(swiper.params.slidesPerGroupSkip, index)) %
                      swiper.params.slidesPerGroup ==
                      0 && snapGrid.push(slidePosition),
                    slidesGrid.push(slidePosition),
                    (slidePosition = slidePosition + slideSize + spaceBetween)),
                (swiper.virtualSize += slideSize + spaceBetween),
                (prevSlideSize = slideSize),
                (index += 1);
            }
          }
          if (
            ((swiper.virtualSize =
              Math.max(swiper.virtualSize, swiperSize) + offsetAfter),
            rtl &&
              wrongRTL &&
              ('slide' === params.effect || 'coverflow' === params.effect) &&
              $wrapperEl.css({
                width: `${swiper.virtualSize + params.spaceBetween}px`,
              }),
            params.setWrapperSize &&
              $wrapperEl.css({
                [getDirectionLabel('width')]: `${
                  swiper.virtualSize + params.spaceBetween
                }px`,
              }),
            gridEnabled &&
              swiper.grid.updateWrapperSize(
                slideSize,
                snapGrid,
                getDirectionLabel
              ),
            !params.centeredSlides)
          ) {
            const newSlidesGrid = [];
            for (let i = 0; i < snapGrid.length; i += 1) {
              let slidesGridItem = snapGrid[i];
              params.roundLengths &&
                (slidesGridItem = Math.floor(slidesGridItem)),
                snapGrid[i] <= swiper.virtualSize - swiperSize &&
                  newSlidesGrid.push(slidesGridItem);
            }
            (snapGrid = newSlidesGrid),
              Math.floor(swiper.virtualSize - swiperSize) -
                Math.floor(snapGrid[snapGrid.length - 1]) >
                1 && snapGrid.push(swiper.virtualSize - swiperSize);
          }
          if (
            (0 === snapGrid.length && (snapGrid = [0]),
            0 !== params.spaceBetween)
          ) {
            const key =
              swiper.isHorizontal() && rtl
                ? 'marginLeft'
                : getDirectionLabel('marginRight');
            slides
              .filter(
                (_, slideIndex) =>
                  !params.cssMode || slideIndex !== slides.length - 1
              )
              .css({ [key]: `${spaceBetween}px` });
          }
          if (params.centeredSlides && params.centeredSlidesBounds) {
            let allSlidesSize = 0;
            slidesSizesGrid.forEach((slideSizeValue) => {
              allSlidesSize +=
                slideSizeValue +
                (params.spaceBetween ? params.spaceBetween : 0);
            }),
              (allSlidesSize -= params.spaceBetween);
            const maxSnap = allSlidesSize - swiperSize;
            snapGrid = snapGrid.map((snap) =>
              snap < 0
                ? -offsetBefore
                : snap > maxSnap
                ? maxSnap + offsetAfter
                : snap
            );
          }
          if (params.centerInsufficientSlides) {
            let allSlidesSize = 0;
            if (
              (slidesSizesGrid.forEach((slideSizeValue) => {
                allSlidesSize +=
                  slideSizeValue +
                  (params.spaceBetween ? params.spaceBetween : 0);
              }),
              (allSlidesSize -= params.spaceBetween),
              allSlidesSize < swiperSize)
            ) {
              const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
              snapGrid.forEach((snap, snapIndex) => {
                snapGrid[snapIndex] = snap - allSlidesOffset;
              }),
                slidesGrid.forEach((snap, snapIndex) => {
                  slidesGrid[snapIndex] = snap + allSlidesOffset;
                });
            }
          }
          if (
            (Object.assign(swiper, {
              slides,
              snapGrid,
              slidesGrid,
              slidesSizesGrid,
            }),
            params.centeredSlides &&
              params.cssMode &&
              !params.centeredSlidesBounds)
          ) {
            utils_setCSSProperty(
              swiper.wrapperEl,
              '--swiper-centered-offset-before',
              -snapGrid[0] + 'px'
            ),
              utils_setCSSProperty(
                swiper.wrapperEl,
                '--swiper-centered-offset-after',
                swiper.size / 2 -
                  slidesSizesGrid[slidesSizesGrid.length - 1] / 2 +
                  'px'
              );
            const addToSnapGrid = -swiper.snapGrid[0],
              addToSlidesGrid = -swiper.slidesGrid[0];
            (swiper.snapGrid = swiper.snapGrid.map((v) => v + addToSnapGrid)),
              (swiper.slidesGrid = swiper.slidesGrid.map(
                (v) => v + addToSlidesGrid
              ));
          }
          if (
            (slidesLength !== previousSlidesLength &&
              swiper.emit('slidesLengthChange'),
            snapGrid.length !== previousSnapGridLength &&
              (swiper.params.watchOverflow && swiper.checkOverflow(),
              swiper.emit('snapGridLengthChange')),
            slidesGrid.length !== previousSlidesGridLength &&
              swiper.emit('slidesGridLengthChange'),
            params.watchSlidesProgress && swiper.updateSlidesOffset(),
            !(
              isVirtual ||
              params.cssMode ||
              ('slide' !== params.effect && 'fade' !== params.effect)
            ))
          ) {
            const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`,
              hasClassBackfaceClassAdded =
                swiper.$el.hasClass(backFaceHiddenClass);
            slidesLength <= params.maxBackfaceHiddenSlides
              ? hasClassBackfaceClassAdded ||
                swiper.$el.addClass(backFaceHiddenClass)
              : hasClassBackfaceClassAdded &&
                swiper.$el.removeClass(backFaceHiddenClass);
          }
        },
        updateAutoHeight: function updateAutoHeight(speed) {
          const swiper = this,
            activeSlides = [],
            isVirtual = swiper.virtual && swiper.params.virtual.enabled;
          let i,
            newHeight = 0;
          'number' == typeof speed
            ? swiper.setTransition(speed)
            : !0 === speed && swiper.setTransition(swiper.params.speed);
          const getSlideByIndex = (index) =>
            isVirtual
              ? swiper.slides.filter(
                  (el) =>
                    parseInt(el.getAttribute('data-swiper-slide-index'), 10) ===
                    index
                )[0]
              : swiper.slides.eq(index)[0];
          if (
            'auto' !== swiper.params.slidesPerView &&
            swiper.params.slidesPerView > 1
          )
            if (swiper.params.centeredSlides)
              (swiper.visibleSlides || dom([])).each((slide) => {
                activeSlides.push(slide);
              });
            else
              for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
                const index = swiper.activeIndex + i;
                if (index > swiper.slides.length && !isVirtual) break;
                activeSlides.push(getSlideByIndex(index));
              }
          else activeSlides.push(getSlideByIndex(swiper.activeIndex));
          for (i = 0; i < activeSlides.length; i += 1)
            if (void 0 !== activeSlides[i]) {
              const height = activeSlides[i].offsetHeight;
              newHeight = height > newHeight ? height : newHeight;
            }
          (newHeight || 0 === newHeight) &&
            swiper.$wrapperEl.css('height', `${newHeight}px`);
        },
        updateSlidesOffset: function updateSlidesOffset() {
          const swiper = this,
            slides = swiper.slides;
          for (let i = 0; i < slides.length; i += 1)
            slides[i].swiperSlideOffset = swiper.isHorizontal()
              ? slides[i].offsetLeft
              : slides[i].offsetTop;
        },
        updateSlidesProgress: function updateSlidesProgress(
          translate = (this && this.translate) || 0
        ) {
          const swiper = this,
            params = swiper.params,
            { slides, rtlTranslate: rtl, snapGrid } = swiper;
          if (0 === slides.length) return;
          void 0 === slides[0].swiperSlideOffset && swiper.updateSlidesOffset();
          let offsetCenter = -translate;
          rtl && (offsetCenter = translate),
            slides.removeClass(params.slideVisibleClass),
            (swiper.visibleSlidesIndexes = []),
            (swiper.visibleSlides = []);
          for (let i = 0; i < slides.length; i += 1) {
            const slide = slides[i];
            let slideOffset = slide.swiperSlideOffset;
            params.cssMode &&
              params.centeredSlides &&
              (slideOffset -= slides[0].swiperSlideOffset);
            const slideProgress =
                (offsetCenter +
                  (params.centeredSlides ? swiper.minTranslate() : 0) -
                  slideOffset) /
                (slide.swiperSlideSize + params.spaceBetween),
              originalSlideProgress =
                (offsetCenter -
                  snapGrid[0] +
                  (params.centeredSlides ? swiper.minTranslate() : 0) -
                  slideOffset) /
                (slide.swiperSlideSize + params.spaceBetween),
              slideBefore = -(offsetCenter - slideOffset),
              slideAfter = slideBefore + swiper.slidesSizesGrid[i];
            ((slideBefore >= 0 && slideBefore < swiper.size - 1) ||
              (slideAfter > 1 && slideAfter <= swiper.size) ||
              (slideBefore <= 0 && slideAfter >= swiper.size)) &&
              (swiper.visibleSlides.push(slide),
              swiper.visibleSlidesIndexes.push(i),
              slides.eq(i).addClass(params.slideVisibleClass)),
              (slide.progress = rtl ? -slideProgress : slideProgress),
              (slide.originalProgress = rtl
                ? -originalSlideProgress
                : originalSlideProgress);
          }
          swiper.visibleSlides = dom(swiper.visibleSlides);
        },
        updateProgress: function updateProgress(translate) {
          const swiper = this;
          if (void 0 === translate) {
            const multiplier = swiper.rtlTranslate ? -1 : 1;
            translate =
              (swiper && swiper.translate && swiper.translate * multiplier) ||
              0;
          }
          const params = swiper.params,
            translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
          let { progress, isBeginning, isEnd } = swiper;
          const wasBeginning = isBeginning,
            wasEnd = isEnd;
          0 === translatesDiff
            ? ((progress = 0), (isBeginning = !0), (isEnd = !0))
            : ((progress =
                (translate - swiper.minTranslate()) / translatesDiff),
              (isBeginning = progress <= 0),
              (isEnd = progress >= 1)),
            Object.assign(swiper, { progress, isBeginning, isEnd }),
            (params.watchSlidesProgress ||
              (params.centeredSlides && params.autoHeight)) &&
              swiper.updateSlidesProgress(translate),
            isBeginning &&
              !wasBeginning &&
              swiper.emit('reachBeginning toEdge'),
            isEnd && !wasEnd && swiper.emit('reachEnd toEdge'),
            ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) &&
              swiper.emit('fromEdge'),
            swiper.emit('progress', progress);
        },
        updateSlidesClasses: function updateSlidesClasses() {
          const swiper = this,
            { slides, params, $wrapperEl, activeIndex, realIndex } = swiper,
            isVirtual = swiper.virtual && params.virtual.enabled;
          let activeSlide;
          slides.removeClass(
            `${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`
          ),
            (activeSlide = isVirtual
              ? swiper.$wrapperEl.find(
                  `.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`
                )
              : slides.eq(activeIndex)),
            activeSlide.addClass(params.slideActiveClass),
            params.loop &&
              (activeSlide.hasClass(params.slideDuplicateClass)
                ? $wrapperEl
                    .children(
                      `.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`
                    )
                    .addClass(params.slideDuplicateActiveClass)
                : $wrapperEl
                    .children(
                      `.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`
                    )
                    .addClass(params.slideDuplicateActiveClass));
          let nextSlide = activeSlide
            .nextAll(`.${params.slideClass}`)
            .eq(0)
            .addClass(params.slideNextClass);
          params.loop &&
            0 === nextSlide.length &&
            ((nextSlide = slides.eq(0)),
            nextSlide.addClass(params.slideNextClass));
          let prevSlide = activeSlide
            .prevAll(`.${params.slideClass}`)
            .eq(0)
            .addClass(params.slidePrevClass);
          params.loop &&
            0 === prevSlide.length &&
            ((prevSlide = slides.eq(-1)),
            prevSlide.addClass(params.slidePrevClass)),
            params.loop &&
              (nextSlide.hasClass(params.slideDuplicateClass)
                ? $wrapperEl
                    .children(
                      `.${params.slideClass}:not(.${
                        params.slideDuplicateClass
                      })[data-swiper-slide-index="${nextSlide.attr(
                        'data-swiper-slide-index'
                      )}"]`
                    )
                    .addClass(params.slideDuplicateNextClass)
                : $wrapperEl
                    .children(
                      `.${params.slideClass}.${
                        params.slideDuplicateClass
                      }[data-swiper-slide-index="${nextSlide.attr(
                        'data-swiper-slide-index'
                      )}"]`
                    )
                    .addClass(params.slideDuplicateNextClass),
              prevSlide.hasClass(params.slideDuplicateClass)
                ? $wrapperEl
                    .children(
                      `.${params.slideClass}:not(.${
                        params.slideDuplicateClass
                      })[data-swiper-slide-index="${prevSlide.attr(
                        'data-swiper-slide-index'
                      )}"]`
                    )
                    .addClass(params.slideDuplicatePrevClass)
                : $wrapperEl
                    .children(
                      `.${params.slideClass}.${
                        params.slideDuplicateClass
                      }[data-swiper-slide-index="${prevSlide.attr(
                        'data-swiper-slide-index'
                      )}"]`
                    )
                    .addClass(params.slideDuplicatePrevClass)),
            swiper.emitSlidesClasses();
        },
        updateActiveIndex: function updateActiveIndex(newActiveIndex) {
          const swiper = this,
            translate = swiper.rtlTranslate
              ? swiper.translate
              : -swiper.translate,
            {
              slidesGrid,
              snapGrid,
              params,
              activeIndex: previousIndex,
              realIndex: previousRealIndex,
              snapIndex: previousSnapIndex,
            } = swiper;
          let snapIndex,
            activeIndex = newActiveIndex;
          if (void 0 === activeIndex) {
            for (let i = 0; i < slidesGrid.length; i += 1)
              void 0 !== slidesGrid[i + 1]
                ? translate >= slidesGrid[i] &&
                  translate <
                    slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2
                  ? (activeIndex = i)
                  : translate >= slidesGrid[i] &&
                    translate < slidesGrid[i + 1] &&
                    (activeIndex = i + 1)
                : translate >= slidesGrid[i] && (activeIndex = i);
            params.normalizeSlideIndex &&
              (activeIndex < 0 || void 0 === activeIndex) &&
              (activeIndex = 0);
          }
          if (snapGrid.indexOf(translate) >= 0)
            snapIndex = snapGrid.indexOf(translate);
          else {
            const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
            snapIndex =
              skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
          }
          if (
            (snapIndex >= snapGrid.length && (snapIndex = snapGrid.length - 1),
            activeIndex === previousIndex)
          )
            return void (
              snapIndex !== previousSnapIndex &&
              ((swiper.snapIndex = snapIndex), swiper.emit('snapIndexChange'))
            );
          const realIndex = parseInt(
            swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') ||
              activeIndex,
            10
          );
          Object.assign(swiper, {
            snapIndex,
            realIndex,
            previousIndex,
            activeIndex,
          }),
            swiper.emit('activeIndexChange'),
            swiper.emit('snapIndexChange'),
            previousRealIndex !== realIndex && swiper.emit('realIndexChange'),
            (swiper.initialized || swiper.params.runCallbacksOnInit) &&
              swiper.emit('slideChange');
        },
        updateClickedSlide: function updateClickedSlide(e) {
          const swiper = this,
            params = swiper.params,
            slide = dom(e).closest(`.${params.slideClass}`)[0];
          let slideIndex,
            slideFound = !1;
          if (slide)
            for (let i = 0; i < swiper.slides.length; i += 1)
              if (swiper.slides[i] === slide) {
                (slideFound = !0), (slideIndex = i);
                break;
              }
          if (!slide || !slideFound)
            return (
              (swiper.clickedSlide = void 0),
              void (swiper.clickedIndex = void 0)
            );
          (swiper.clickedSlide = slide),
            swiper.virtual && swiper.params.virtual.enabled
              ? (swiper.clickedIndex = parseInt(
                  dom(slide).attr('data-swiper-slide-index'),
                  10
                ))
              : (swiper.clickedIndex = slideIndex),
            params.slideToClickedSlide &&
              void 0 !== swiper.clickedIndex &&
              swiper.clickedIndex !== swiper.activeIndex &&
              swiper.slideToClickedSlide();
        },
      };
      const translate = {
        getTranslate: function getSwiperTranslate(
          axis = this.isHorizontal() ? 'x' : 'y'
        ) {
          const { params, rtlTranslate: rtl, translate, $wrapperEl } = this;
          if (params.virtualTranslate) return rtl ? -translate : translate;
          if (params.cssMode) return translate;
          let currentTranslate = utils_getTranslate($wrapperEl[0], axis);
          return (
            rtl && (currentTranslate = -currentTranslate), currentTranslate || 0
          );
        },
        setTranslate: function setTranslate(translate, byController) {
          const swiper = this,
            {
              rtlTranslate: rtl,
              params,
              $wrapperEl,
              wrapperEl,
              progress,
            } = swiper;
          let newProgress,
            x = 0,
            y = 0;
          swiper.isHorizontal()
            ? (x = rtl ? -translate : translate)
            : (y = translate),
            params.roundLengths && ((x = Math.floor(x)), (y = Math.floor(y))),
            params.cssMode
              ? (wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] =
                  swiper.isHorizontal() ? -x : -y)
              : params.virtualTranslate ||
                $wrapperEl.transform(`translate3d(${x}px, ${y}px, 0px)`),
            (swiper.previousTranslate = swiper.translate),
            (swiper.translate = swiper.isHorizontal() ? x : y);
          const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
          (newProgress =
            0 === translatesDiff
              ? 0
              : (translate - swiper.minTranslate()) / translatesDiff),
            newProgress !== progress && swiper.updateProgress(translate),
            swiper.emit('setTranslate', swiper.translate, byController);
        },
        minTranslate: function minTranslate() {
          return -this.snapGrid[0];
        },
        maxTranslate: function maxTranslate() {
          return -this.snapGrid[this.snapGrid.length - 1];
        },
        translateTo: function translateTo(
          translate = 0,
          speed = this.params.speed,
          runCallbacks = !0,
          translateBounds = !0,
          internal
        ) {
          const swiper = this,
            { params, wrapperEl } = swiper;
          if (swiper.animating && params.preventInteractionOnTransition)
            return !1;
          const minTranslate = swiper.minTranslate(),
            maxTranslate = swiper.maxTranslate();
          let newTranslate;
          if (
            ((newTranslate =
              translateBounds && translate > minTranslate
                ? minTranslate
                : translateBounds && translate < maxTranslate
                ? maxTranslate
                : translate),
            swiper.updateProgress(newTranslate),
            params.cssMode)
          ) {
            const isH = swiper.isHorizontal();
            if (0 === speed)
              wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
            else {
              if (!swiper.support.smoothScroll)
                return (
                  animateCSSModeScroll({
                    swiper,
                    targetPosition: -newTranslate,
                    side: isH ? 'left' : 'top',
                  }),
                  !0
                );
              wrapperEl.scrollTo({
                [isH ? 'left' : 'top']: -newTranslate,
                behavior: 'smooth',
              });
            }
            return !0;
          }
          return (
            0 === speed
              ? (swiper.setTransition(0),
                swiper.setTranslate(newTranslate),
                runCallbacks &&
                  (swiper.emit('beforeTransitionStart', speed, internal),
                  swiper.emit('transitionEnd')))
              : (swiper.setTransition(speed),
                swiper.setTranslate(newTranslate),
                runCallbacks &&
                  (swiper.emit('beforeTransitionStart', speed, internal),
                  swiper.emit('transitionStart')),
                swiper.animating ||
                  ((swiper.animating = !0),
                  swiper.onTranslateToWrapperTransitionEnd ||
                    (swiper.onTranslateToWrapperTransitionEnd =
                      function transitionEnd(e) {
                        swiper &&
                          !swiper.destroyed &&
                          e.target === this &&
                          (swiper.$wrapperEl[0].removeEventListener(
                            'transitionend',
                            swiper.onTranslateToWrapperTransitionEnd
                          ),
                          swiper.$wrapperEl[0].removeEventListener(
                            'webkitTransitionEnd',
                            swiper.onTranslateToWrapperTransitionEnd
                          ),
                          (swiper.onTranslateToWrapperTransitionEnd = null),
                          delete swiper.onTranslateToWrapperTransitionEnd,
                          runCallbacks && swiper.emit('transitionEnd'));
                      }),
                  swiper.$wrapperEl[0].addEventListener(
                    'transitionend',
                    swiper.onTranslateToWrapperTransitionEnd
                  ),
                  swiper.$wrapperEl[0].addEventListener(
                    'webkitTransitionEnd',
                    swiper.onTranslateToWrapperTransitionEnd
                  ))),
            !0
          );
        },
      };
      function transitionEmit({ swiper, runCallbacks, direction, step }) {
        const { activeIndex, previousIndex } = swiper;
        let dir = direction;
        if (
          (dir ||
            (dir =
              activeIndex > previousIndex
                ? 'next'
                : activeIndex < previousIndex
                ? 'prev'
                : 'reset'),
          swiper.emit(`transition${step}`),
          runCallbacks && activeIndex !== previousIndex)
        ) {
          if ('reset' === dir)
            return void swiper.emit(`slideResetTransition${step}`);
          swiper.emit(`slideChangeTransition${step}`),
            'next' === dir
              ? swiper.emit(`slideNextTransition${step}`)
              : swiper.emit(`slidePrevTransition${step}`);
        }
      }
      const slide = {
        slideTo: function slideTo(
          index = 0,
          speed = this.params.speed,
          runCallbacks = !0,
          internal,
          initial
        ) {
          if ('number' != typeof index && 'string' != typeof index)
            throw new Error(
              `The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`
            );
          if ('string' == typeof index) {
            const indexAsNumber = parseInt(index, 10);
            if (!isFinite(indexAsNumber))
              throw new Error(
                `The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`
              );
            index = indexAsNumber;
          }
          const swiper = this;
          let slideIndex = index;
          slideIndex < 0 && (slideIndex = 0);
          const {
            params,
            snapGrid,
            slidesGrid,
            previousIndex,
            activeIndex,
            rtlTranslate: rtl,
            wrapperEl,
            enabled,
          } = swiper;
          if (
            (swiper.animating && params.preventInteractionOnTransition) ||
            (!enabled && !internal && !initial)
          )
            return !1;
          const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
          let snapIndex =
            skip +
            Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
          snapIndex >= snapGrid.length && (snapIndex = snapGrid.length - 1);
          const translate = -snapGrid[snapIndex];
          if (params.normalizeSlideIndex)
            for (let i = 0; i < slidesGrid.length; i += 1) {
              const normalizedTranslate = -Math.floor(100 * translate),
                normalizedGrid = Math.floor(100 * slidesGrid[i]),
                normalizedGridNext = Math.floor(100 * slidesGrid[i + 1]);
              void 0 !== slidesGrid[i + 1]
                ? normalizedTranslate >= normalizedGrid &&
                  normalizedTranslate <
                    normalizedGridNext -
                      (normalizedGridNext - normalizedGrid) / 2
                  ? (slideIndex = i)
                  : normalizedTranslate >= normalizedGrid &&
                    normalizedTranslate < normalizedGridNext &&
                    (slideIndex = i + 1)
                : normalizedTranslate >= normalizedGrid && (slideIndex = i);
            }
          if (swiper.initialized && slideIndex !== activeIndex) {
            if (
              !swiper.allowSlideNext &&
              translate < swiper.translate &&
              translate < swiper.minTranslate()
            )
              return !1;
            if (
              !swiper.allowSlidePrev &&
              translate > swiper.translate &&
              translate > swiper.maxTranslate() &&
              (activeIndex || 0) !== slideIndex
            )
              return !1;
          }
          let direction;
          if (
            (slideIndex !== (previousIndex || 0) &&
              runCallbacks &&
              swiper.emit('beforeSlideChangeStart'),
            swiper.updateProgress(translate),
            (direction =
              slideIndex > activeIndex
                ? 'next'
                : slideIndex < activeIndex
                ? 'prev'
                : 'reset'),
            (rtl && -translate === swiper.translate) ||
              (!rtl && translate === swiper.translate))
          )
            return (
              swiper.updateActiveIndex(slideIndex),
              params.autoHeight && swiper.updateAutoHeight(),
              swiper.updateSlidesClasses(),
              'slide' !== params.effect && swiper.setTranslate(translate),
              'reset' !== direction &&
                (swiper.transitionStart(runCallbacks, direction),
                swiper.transitionEnd(runCallbacks, direction)),
              !1
            );
          if (params.cssMode) {
            const isH = swiper.isHorizontal(),
              t = rtl ? translate : -translate;
            if (0 === speed) {
              const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
              isVirtual &&
                ((swiper.wrapperEl.style.scrollSnapType = 'none'),
                (swiper._immediateVirtual = !0)),
                (wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t),
                isVirtual &&
                  requestAnimationFrame(() => {
                    (swiper.wrapperEl.style.scrollSnapType = ''),
                      (swiper._swiperImmediateVirtual = !1);
                  });
            } else {
              if (!swiper.support.smoothScroll)
                return (
                  animateCSSModeScroll({
                    swiper,
                    targetPosition: t,
                    side: isH ? 'left' : 'top',
                  }),
                  !0
                );
              wrapperEl.scrollTo({
                [isH ? 'left' : 'top']: t,
                behavior: 'smooth',
              });
            }
            return !0;
          }
          return (
            swiper.setTransition(speed),
            swiper.setTranslate(translate),
            swiper.updateActiveIndex(slideIndex),
            swiper.updateSlidesClasses(),
            swiper.emit('beforeTransitionStart', speed, internal),
            swiper.transitionStart(runCallbacks, direction),
            0 === speed
              ? swiper.transitionEnd(runCallbacks, direction)
              : swiper.animating ||
                ((swiper.animating = !0),
                swiper.onSlideToWrapperTransitionEnd ||
                  (swiper.onSlideToWrapperTransitionEnd =
                    function transitionEnd(e) {
                      swiper &&
                        !swiper.destroyed &&
                        e.target === this &&
                        (swiper.$wrapperEl[0].removeEventListener(
                          'transitionend',
                          swiper.onSlideToWrapperTransitionEnd
                        ),
                        swiper.$wrapperEl[0].removeEventListener(
                          'webkitTransitionEnd',
                          swiper.onSlideToWrapperTransitionEnd
                        ),
                        (swiper.onSlideToWrapperTransitionEnd = null),
                        delete swiper.onSlideToWrapperTransitionEnd,
                        swiper.transitionEnd(runCallbacks, direction));
                    }),
                swiper.$wrapperEl[0].addEventListener(
                  'transitionend',
                  swiper.onSlideToWrapperTransitionEnd
                ),
                swiper.$wrapperEl[0].addEventListener(
                  'webkitTransitionEnd',
                  swiper.onSlideToWrapperTransitionEnd
                )),
            !0
          );
        },
        slideToLoop: function slideToLoop(
          index = 0,
          speed = this.params.speed,
          runCallbacks = !0,
          internal
        ) {
          if ('string' == typeof index) {
            const indexAsNumber = parseInt(index, 10);
            if (!isFinite(indexAsNumber))
              throw new Error(
                `The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`
              );
            index = indexAsNumber;
          }
          const swiper = this;
          let newIndex = index;
          return (
            swiper.params.loop && (newIndex += swiper.loopedSlides),
            swiper.slideTo(newIndex, speed, runCallbacks, internal)
          );
        },
        slideNext: function slideNext(
          speed = this.params.speed,
          runCallbacks = !0,
          internal
        ) {
          const swiper = this,
            { animating, enabled, params } = swiper;
          if (!enabled) return swiper;
          let perGroup = params.slidesPerGroup;
          'auto' === params.slidesPerView &&
            1 === params.slidesPerGroup &&
            params.slidesPerGroupAuto &&
            (perGroup = Math.max(
              swiper.slidesPerViewDynamic('current', !0),
              1
            ));
          const increment =
            swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
          if (params.loop) {
            if (animating && params.loopPreventsSlide) return !1;
            swiper.loopFix(),
              (swiper._clientLeft = swiper.$wrapperEl[0].clientLeft);
          }
          return params.rewind && swiper.isEnd
            ? swiper.slideTo(0, speed, runCallbacks, internal)
            : swiper.slideTo(
                swiper.activeIndex + increment,
                speed,
                runCallbacks,
                internal
              );
        },
        slidePrev: function slidePrev(
          speed = this.params.speed,
          runCallbacks = !0,
          internal
        ) {
          const swiper = this,
            { params, animating, snapGrid, slidesGrid, rtlTranslate, enabled } =
              swiper;
          if (!enabled) return swiper;
          if (params.loop) {
            if (animating && params.loopPreventsSlide) return !1;
            swiper.loopFix(),
              (swiper._clientLeft = swiper.$wrapperEl[0].clientLeft);
          }
          function normalize(val) {
            return val < 0 ? -Math.floor(Math.abs(val)) : Math.floor(val);
          }
          const normalizedTranslate = normalize(
              rtlTranslate ? swiper.translate : -swiper.translate
            ),
            normalizedSnapGrid = snapGrid.map((val) => normalize(val));
          let prevSnap =
            snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
          if (void 0 === prevSnap && params.cssMode) {
            let prevSnapIndex;
            snapGrid.forEach((snap, snapIndex) => {
              normalizedTranslate >= snap && (prevSnapIndex = snapIndex);
            }),
              void 0 !== prevSnapIndex &&
                (prevSnap =
                  snapGrid[
                    prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex
                  ]);
          }
          let prevIndex = 0;
          if (
            (void 0 !== prevSnap &&
              ((prevIndex = slidesGrid.indexOf(prevSnap)),
              prevIndex < 0 && (prevIndex = swiper.activeIndex - 1),
              'auto' === params.slidesPerView &&
                1 === params.slidesPerGroup &&
                params.slidesPerGroupAuto &&
                ((prevIndex =
                  prevIndex - swiper.slidesPerViewDynamic('previous', !0) + 1),
                (prevIndex = Math.max(prevIndex, 0)))),
            params.rewind && swiper.isBeginning)
          ) {
            const lastIndex =
              swiper.params.virtual &&
              swiper.params.virtual.enabled &&
              swiper.virtual
                ? swiper.virtual.slides.length - 1
                : swiper.slides.length - 1;
            return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
          }
          return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
        },
        slideReset: function slideReset(
          speed = this.params.speed,
          runCallbacks = !0,
          internal
        ) {
          return this.slideTo(this.activeIndex, speed, runCallbacks, internal);
        },
        slideToClosest: function slideToClosest(
          speed = this.params.speed,
          runCallbacks = !0,
          internal,
          threshold = 0.5
        ) {
          const swiper = this;
          let index = swiper.activeIndex;
          const skip = Math.min(swiper.params.slidesPerGroupSkip, index),
            snapIndex =
              skip + Math.floor((index - skip) / swiper.params.slidesPerGroup),
            translate = swiper.rtlTranslate
              ? swiper.translate
              : -swiper.translate;
          if (translate >= swiper.snapGrid[snapIndex]) {
            const currentSnap = swiper.snapGrid[snapIndex];
            translate - currentSnap >
              (swiper.snapGrid[snapIndex + 1] - currentSnap) * threshold &&
              (index += swiper.params.slidesPerGroup);
          } else {
            const prevSnap = swiper.snapGrid[snapIndex - 1];
            translate - prevSnap <=
              (swiper.snapGrid[snapIndex] - prevSnap) * threshold &&
              (index -= swiper.params.slidesPerGroup);
          }
          return (
            (index = Math.max(index, 0)),
            (index = Math.min(index, swiper.slidesGrid.length - 1)),
            swiper.slideTo(index, speed, runCallbacks, internal)
          );
        },
        slideToClickedSlide: function slideToClickedSlide() {
          const swiper = this,
            { params, $wrapperEl } = swiper,
            slidesPerView =
              'auto' === params.slidesPerView
                ? swiper.slidesPerViewDynamic()
                : params.slidesPerView;
          let realIndex,
            slideToIndex = swiper.clickedIndex;
          if (params.loop) {
            if (swiper.animating) return;
            (realIndex = parseInt(
              dom(swiper.clickedSlide).attr('data-swiper-slide-index'),
              10
            )),
              params.centeredSlides
                ? slideToIndex < swiper.loopedSlides - slidesPerView / 2 ||
                  slideToIndex >
                    swiper.slides.length -
                      swiper.loopedSlides +
                      slidesPerView / 2
                  ? (swiper.loopFix(),
                    (slideToIndex = $wrapperEl
                      .children(
                        `.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`
                      )
                      .eq(0)
                      .index()),
                    utils_nextTick(() => {
                      swiper.slideTo(slideToIndex);
                    }))
                  : swiper.slideTo(slideToIndex)
                : slideToIndex > swiper.slides.length - slidesPerView
                ? (swiper.loopFix(),
                  (slideToIndex = $wrapperEl
                    .children(
                      `.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`
                    )
                    .eq(0)
                    .index()),
                  utils_nextTick(() => {
                    swiper.slideTo(slideToIndex);
                  }))
                : swiper.slideTo(slideToIndex);
          } else swiper.slideTo(slideToIndex);
        },
      };
      const loop = {
        loopCreate: function loopCreate() {
          const swiper = this,
            document = ssr_window_esm_getDocument(),
            { params, $wrapperEl } = swiper,
            $selector =
              $wrapperEl.children().length > 0
                ? dom($wrapperEl.children()[0].parentNode)
                : $wrapperEl;
          $selector
            .children(`.${params.slideClass}.${params.slideDuplicateClass}`)
            .remove();
          let slides = $selector.children(`.${params.slideClass}`);
          if (params.loopFillGroupWithBlank) {
            const blankSlidesNum =
              params.slidesPerGroup - (slides.length % params.slidesPerGroup);
            if (blankSlidesNum !== params.slidesPerGroup) {
              for (let i = 0; i < blankSlidesNum; i += 1) {
                const blankNode = dom(document.createElement('div')).addClass(
                  `${params.slideClass} ${params.slideBlankClass}`
                );
                $selector.append(blankNode);
              }
              slides = $selector.children(`.${params.slideClass}`);
            }
          }
          'auto' !== params.slidesPerView ||
            params.loopedSlides ||
            (params.loopedSlides = slides.length),
            (swiper.loopedSlides = Math.ceil(
              parseFloat(params.loopedSlides || params.slidesPerView, 10)
            )),
            (swiper.loopedSlides += params.loopAdditionalSlides),
            swiper.loopedSlides > slides.length &&
              swiper.params.loopedSlidesLimit &&
              (swiper.loopedSlides = slides.length);
          const prependSlides = [],
            appendSlides = [];
          slides.each((el, index) => {
            dom(el).attr('data-swiper-slide-index', index);
          });
          for (let i = 0; i < swiper.loopedSlides; i += 1) {
            const index = i - Math.floor(i / slides.length) * slides.length;
            appendSlides.push(slides.eq(index)[0]),
              prependSlides.unshift(slides.eq(slides.length - index - 1)[0]);
          }
          for (let i = 0; i < appendSlides.length; i += 1)
            $selector.append(
              dom(appendSlides[i].cloneNode(!0)).addClass(
                params.slideDuplicateClass
              )
            );
          for (let i = prependSlides.length - 1; i >= 0; i -= 1)
            $selector.prepend(
              dom(prependSlides[i].cloneNode(!0)).addClass(
                params.slideDuplicateClass
              )
            );
        },
        loopFix: function loopFix() {
          const swiper = this;
          swiper.emit('beforeLoopFix');
          const {
            activeIndex,
            slides,
            loopedSlides,
            allowSlidePrev,
            allowSlideNext,
            snapGrid,
            rtlTranslate: rtl,
          } = swiper;
          let newIndex;
          (swiper.allowSlidePrev = !0), (swiper.allowSlideNext = !0);
          const diff = -snapGrid[activeIndex] - swiper.getTranslate();
          if (activeIndex < loopedSlides) {
            (newIndex = slides.length - 3 * loopedSlides + activeIndex),
              (newIndex += loopedSlides);
            swiper.slideTo(newIndex, 0, !1, !0) &&
              0 !== diff &&
              swiper.setTranslate(
                (rtl ? -swiper.translate : swiper.translate) - diff
              );
          } else if (activeIndex >= slides.length - loopedSlides) {
            (newIndex = -slides.length + activeIndex + loopedSlides),
              (newIndex += loopedSlides);
            swiper.slideTo(newIndex, 0, !1, !0) &&
              0 !== diff &&
              swiper.setTranslate(
                (rtl ? -swiper.translate : swiper.translate) - diff
              );
          }
          (swiper.allowSlidePrev = allowSlidePrev),
            (swiper.allowSlideNext = allowSlideNext),
            swiper.emit('loopFix');
        },
        loopDestroy: function loopDestroy() {
          const { $wrapperEl, params, slides } = this;
          $wrapperEl
            .children(
              `.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`
            )
            .remove(),
            slides.removeAttr('data-swiper-slide-index');
        },
      };
      function onTouchStart(event) {
        const swiper = this,
          document = ssr_window_esm_getDocument(),
          window = ssr_window_esm_getWindow(),
          data = swiper.touchEventsData,
          { params, touches, enabled } = swiper;
        if (!enabled) return;
        if (swiper.animating && params.preventInteractionOnTransition) return;
        !swiper.animating && params.cssMode && params.loop && swiper.loopFix();
        let e = event;
        e.originalEvent && (e = e.originalEvent);
        let $targetEl = dom(e.target);
        if (
          'wrapper' === params.touchEventsTarget &&
          !$targetEl.closest(swiper.wrapperEl).length
        )
          return;
        if (
          ((data.isTouchEvent = 'touchstart' === e.type),
          !data.isTouchEvent && 'which' in e && 3 === e.which)
        )
          return;
        if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
        if (data.isTouched && data.isMoved) return;
        const swipingClassHasValue =
            !!params.noSwipingClass && '' !== params.noSwipingClass,
          eventPath = event.composedPath ? event.composedPath() : event.path;
        swipingClassHasValue &&
          e.target &&
          e.target.shadowRoot &&
          eventPath &&
          ($targetEl = dom(eventPath[0]));
        const noSwipingSelector = params.noSwipingSelector
            ? params.noSwipingSelector
            : `.${params.noSwipingClass}`,
          isTargetShadow = !(!e.target || !e.target.shadowRoot);
        if (
          params.noSwiping &&
          (isTargetShadow
            ? (function closestElement(selector, base = this) {
                return (function __closestFrom(el) {
                  if (
                    !el ||
                    el === ssr_window_esm_getDocument() ||
                    el === ssr_window_esm_getWindow()
                  )
                    return null;
                  el.assignedSlot && (el = el.assignedSlot);
                  const found = el.closest(selector);
                  return found || el.getRootNode
                    ? found || __closestFrom(el.getRootNode().host)
                    : null;
                })(base);
              })(noSwipingSelector, $targetEl[0])
            : $targetEl.closest(noSwipingSelector)[0])
        )
          return void (swiper.allowClick = !0);
        if (params.swipeHandler && !$targetEl.closest(params.swipeHandler)[0])
          return;
        (touches.currentX =
          'touchstart' === e.type ? e.targetTouches[0].pageX : e.pageX),
          (touches.currentY =
            'touchstart' === e.type ? e.targetTouches[0].pageY : e.pageY);
        const startX = touches.currentX,
          startY = touches.currentY,
          edgeSwipeDetection =
            params.edgeSwipeDetection || params.iOSEdgeSwipeDetection,
          edgeSwipeThreshold =
            params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
        if (
          edgeSwipeDetection &&
          (startX <= edgeSwipeThreshold ||
            startX >= window.innerWidth - edgeSwipeThreshold)
        ) {
          if ('prevent' !== edgeSwipeDetection) return;
          event.preventDefault();
        }
        if (
          (Object.assign(data, {
            isTouched: !0,
            isMoved: !1,
            allowTouchCallbacks: !0,
            isScrolling: void 0,
            startMoving: void 0,
          }),
          (touches.startX = startX),
          (touches.startY = startY),
          (data.touchStartTime = utils_now()),
          (swiper.allowClick = !0),
          swiper.updateSize(),
          (swiper.swipeDirection = void 0),
          params.threshold > 0 && (data.allowThresholdMove = !1),
          'touchstart' !== e.type)
        ) {
          let preventDefault = !0;
          $targetEl.is(data.focusableElements) &&
            ((preventDefault = !1),
            'SELECT' === $targetEl[0].nodeName && (data.isTouched = !1)),
            document.activeElement &&
              dom(document.activeElement).is(data.focusableElements) &&
              document.activeElement !== $targetEl[0] &&
              document.activeElement.blur();
          const shouldPreventDefault =
            preventDefault &&
            swiper.allowTouchMove &&
            params.touchStartPreventDefault;
          (!params.touchStartForcePreventDefault && !shouldPreventDefault) ||
            $targetEl[0].isContentEditable ||
            e.preventDefault();
        }
        swiper.params.freeMode &&
          swiper.params.freeMode.enabled &&
          swiper.freeMode &&
          swiper.animating &&
          !params.cssMode &&
          swiper.freeMode.onTouchStart(),
          swiper.emit('touchStart', e);
      }
      function onTouchMove(event) {
        const document = ssr_window_esm_getDocument(),
          swiper = this,
          data = swiper.touchEventsData,
          { params, touches, rtlTranslate: rtl, enabled } = swiper;
        if (!enabled) return;
        let e = event;
        if ((e.originalEvent && (e = e.originalEvent), !data.isTouched))
          return void (
            data.startMoving &&
            data.isScrolling &&
            swiper.emit('touchMoveOpposite', e)
          );
        if (data.isTouchEvent && 'touchmove' !== e.type) return;
        const targetTouch =
            'touchmove' === e.type &&
            e.targetTouches &&
            (e.targetTouches[0] || e.changedTouches[0]),
          pageX = 'touchmove' === e.type ? targetTouch.pageX : e.pageX,
          pageY = 'touchmove' === e.type ? targetTouch.pageY : e.pageY;
        if (e.preventedByNestedSwiper)
          return (touches.startX = pageX), void (touches.startY = pageY);
        if (!swiper.allowTouchMove)
          return (
            dom(e.target).is(data.focusableElements) ||
              (swiper.allowClick = !1),
            void (
              data.isTouched &&
              (Object.assign(touches, {
                startX: pageX,
                startY: pageY,
                currentX: pageX,
                currentY: pageY,
              }),
              (data.touchStartTime = utils_now()))
            )
          );
        if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop)
          if (swiper.isVertical()) {
            if (
              (pageY < touches.startY &&
                swiper.translate <= swiper.maxTranslate()) ||
              (pageY > touches.startY &&
                swiper.translate >= swiper.minTranslate())
            )
              return (data.isTouched = !1), void (data.isMoved = !1);
          } else if (
            (pageX < touches.startX &&
              swiper.translate <= swiper.maxTranslate()) ||
            (pageX > touches.startX &&
              swiper.translate >= swiper.minTranslate())
          )
            return;
        if (
          data.isTouchEvent &&
          document.activeElement &&
          e.target === document.activeElement &&
          dom(e.target).is(data.focusableElements)
        )
          return (data.isMoved = !0), void (swiper.allowClick = !1);
        if (
          (data.allowTouchCallbacks && swiper.emit('touchMove', e),
          e.targetTouches && e.targetTouches.length > 1)
        )
          return;
        (touches.currentX = pageX), (touches.currentY = pageY);
        const diffX = touches.currentX - touches.startX,
          diffY = touches.currentY - touches.startY;
        if (
          swiper.params.threshold &&
          Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold
        )
          return;
        if (void 0 === data.isScrolling) {
          let touchAngle;
          (swiper.isHorizontal() && touches.currentY === touches.startY) ||
          (swiper.isVertical() && touches.currentX === touches.startX)
            ? (data.isScrolling = !1)
            : diffX * diffX + diffY * diffY >= 25 &&
              ((touchAngle =
                (180 * Math.atan2(Math.abs(diffY), Math.abs(diffX))) / Math.PI),
              (data.isScrolling = swiper.isHorizontal()
                ? touchAngle > params.touchAngle
                : 90 - touchAngle > params.touchAngle));
        }
        if (
          (data.isScrolling && swiper.emit('touchMoveOpposite', e),
          void 0 === data.startMoving &&
            ((touches.currentX === touches.startX &&
              touches.currentY === touches.startY) ||
              (data.startMoving = !0)),
          data.isScrolling)
        )
          return void (data.isTouched = !1);
        if (!data.startMoving) return;
        (swiper.allowClick = !1),
          !params.cssMode && e.cancelable && e.preventDefault(),
          params.touchMoveStopPropagation &&
            !params.nested &&
            e.stopPropagation(),
          data.isMoved ||
            (params.loop && !params.cssMode && swiper.loopFix(),
            (data.startTranslate = swiper.getTranslate()),
            swiper.setTransition(0),
            swiper.animating &&
              swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend'),
            (data.allowMomentumBounce = !1),
            !params.grabCursor ||
              (!0 !== swiper.allowSlideNext && !0 !== swiper.allowSlidePrev) ||
              swiper.setGrabCursor(!0),
            swiper.emit('sliderFirstMove', e)),
          swiper.emit('sliderMove', e),
          (data.isMoved = !0);
        let diff = swiper.isHorizontal() ? diffX : diffY;
        (touches.diff = diff),
          (diff *= params.touchRatio),
          rtl && (diff = -diff),
          (swiper.swipeDirection = diff > 0 ? 'prev' : 'next'),
          (data.currentTranslate = diff + data.startTranslate);
        let disableParentSwiper = !0,
          resistanceRatio = params.resistanceRatio;
        if (
          (params.touchReleaseOnEdges && (resistanceRatio = 0),
          diff > 0 && data.currentTranslate > swiper.minTranslate()
            ? ((disableParentSwiper = !1),
              params.resistance &&
                (data.currentTranslate =
                  swiper.minTranslate() -
                  1 +
                  (-swiper.minTranslate() + data.startTranslate + diff) **
                    resistanceRatio))
            : diff < 0 &&
              data.currentTranslate < swiper.maxTranslate() &&
              ((disableParentSwiper = !1),
              params.resistance &&
                (data.currentTranslate =
                  swiper.maxTranslate() +
                  1 -
                  (swiper.maxTranslate() - data.startTranslate - diff) **
                    resistanceRatio)),
          disableParentSwiper && (e.preventedByNestedSwiper = !0),
          !swiper.allowSlideNext &&
            'next' === swiper.swipeDirection &&
            data.currentTranslate < data.startTranslate &&
            (data.currentTranslate = data.startTranslate),
          !swiper.allowSlidePrev &&
            'prev' === swiper.swipeDirection &&
            data.currentTranslate > data.startTranslate &&
            (data.currentTranslate = data.startTranslate),
          swiper.allowSlidePrev ||
            swiper.allowSlideNext ||
            (data.currentTranslate = data.startTranslate),
          params.threshold > 0)
        ) {
          if (!(Math.abs(diff) > params.threshold || data.allowThresholdMove))
            return void (data.currentTranslate = data.startTranslate);
          if (!data.allowThresholdMove)
            return (
              (data.allowThresholdMove = !0),
              (touches.startX = touches.currentX),
              (touches.startY = touches.currentY),
              (data.currentTranslate = data.startTranslate),
              void (touches.diff = swiper.isHorizontal()
                ? touches.currentX - touches.startX
                : touches.currentY - touches.startY)
            );
        }
        params.followFinger &&
          !params.cssMode &&
          (((params.freeMode && params.freeMode.enabled && swiper.freeMode) ||
            params.watchSlidesProgress) &&
            (swiper.updateActiveIndex(), swiper.updateSlidesClasses()),
          swiper.params.freeMode &&
            params.freeMode.enabled &&
            swiper.freeMode &&
            swiper.freeMode.onTouchMove(),
          swiper.updateProgress(data.currentTranslate),
          swiper.setTranslate(data.currentTranslate));
      }
      function onTouchEnd(event) {
        const swiper = this,
          data = swiper.touchEventsData,
          { params, touches, rtlTranslate: rtl, slidesGrid, enabled } = swiper;
        if (!enabled) return;
        let e = event;
        if (
          (e.originalEvent && (e = e.originalEvent),
          data.allowTouchCallbacks && swiper.emit('touchEnd', e),
          (data.allowTouchCallbacks = !1),
          !data.isTouched)
        )
          return (
            data.isMoved && params.grabCursor && swiper.setGrabCursor(!1),
            (data.isMoved = !1),
            void (data.startMoving = !1)
          );
        params.grabCursor &&
          data.isMoved &&
          data.isTouched &&
          (!0 === swiper.allowSlideNext || !0 === swiper.allowSlidePrev) &&
          swiper.setGrabCursor(!1);
        const touchEndTime = utils_now(),
          timeDiff = touchEndTime - data.touchStartTime;
        if (swiper.allowClick) {
          const pathTree = e.path || (e.composedPath && e.composedPath());
          swiper.updateClickedSlide((pathTree && pathTree[0]) || e.target),
            swiper.emit('tap click', e),
            timeDiff < 300 &&
              touchEndTime - data.lastClickTime < 300 &&
              swiper.emit('doubleTap doubleClick', e);
        }
        if (
          ((data.lastClickTime = utils_now()),
          utils_nextTick(() => {
            swiper.destroyed || (swiper.allowClick = !0);
          }),
          !data.isTouched ||
            !data.isMoved ||
            !swiper.swipeDirection ||
            0 === touches.diff ||
            data.currentTranslate === data.startTranslate)
        )
          return (
            (data.isTouched = !1),
            (data.isMoved = !1),
            void (data.startMoving = !1)
          );
        let currentPos;
        if (
          ((data.isTouched = !1),
          (data.isMoved = !1),
          (data.startMoving = !1),
          (currentPos = params.followFinger
            ? rtl
              ? swiper.translate
              : -swiper.translate
            : -data.currentTranslate),
          params.cssMode)
        )
          return;
        if (swiper.params.freeMode && params.freeMode.enabled)
          return void swiper.freeMode.onTouchEnd({ currentPos });
        let stopIndex = 0,
          groupSize = swiper.slidesSizesGrid[0];
        for (
          let i = 0;
          i < slidesGrid.length;
          i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup
        ) {
          const increment =
            i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
          void 0 !== slidesGrid[i + increment]
            ? currentPos >= slidesGrid[i] &&
              currentPos < slidesGrid[i + increment] &&
              ((stopIndex = i),
              (groupSize = slidesGrid[i + increment] - slidesGrid[i]))
            : currentPos >= slidesGrid[i] &&
              ((stopIndex = i),
              (groupSize =
                slidesGrid[slidesGrid.length - 1] -
                slidesGrid[slidesGrid.length - 2]));
        }
        let rewindFirstIndex = null,
          rewindLastIndex = null;
        params.rewind &&
          (swiper.isBeginning
            ? (rewindLastIndex =
                swiper.params.virtual &&
                swiper.params.virtual.enabled &&
                swiper.virtual
                  ? swiper.virtual.slides.length - 1
                  : swiper.slides.length - 1)
            : swiper.isEnd && (rewindFirstIndex = 0));
        const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize,
          increment =
            stopIndex < params.slidesPerGroupSkip - 1
              ? 1
              : params.slidesPerGroup;
        if (timeDiff > params.longSwipesMs) {
          if (!params.longSwipes)
            return void swiper.slideTo(swiper.activeIndex);
          'next' === swiper.swipeDirection &&
            (ratio >= params.longSwipesRatio
              ? swiper.slideTo(
                  params.rewind && swiper.isEnd
                    ? rewindFirstIndex
                    : stopIndex + increment
                )
              : swiper.slideTo(stopIndex)),
            'prev' === swiper.swipeDirection &&
              (ratio > 1 - params.longSwipesRatio
                ? swiper.slideTo(stopIndex + increment)
                : null !== rewindLastIndex &&
                  ratio < 0 &&
                  Math.abs(ratio) > params.longSwipesRatio
                ? swiper.slideTo(rewindLastIndex)
                : swiper.slideTo(stopIndex));
        } else {
          if (!params.shortSwipes)
            return void swiper.slideTo(swiper.activeIndex);
          swiper.navigation &&
          (e.target === swiper.navigation.nextEl ||
            e.target === swiper.navigation.prevEl)
            ? e.target === swiper.navigation.nextEl
              ? swiper.slideTo(stopIndex + increment)
              : swiper.slideTo(stopIndex)
            : ('next' === swiper.swipeDirection &&
                swiper.slideTo(
                  null !== rewindFirstIndex
                    ? rewindFirstIndex
                    : stopIndex + increment
                ),
              'prev' === swiper.swipeDirection &&
                swiper.slideTo(
                  null !== rewindLastIndex ? rewindLastIndex : stopIndex
                ));
        }
      }
      function onResize() {
        const swiper = this,
          { params, el } = swiper;
        if (el && 0 === el.offsetWidth) return;
        params.breakpoints && swiper.setBreakpoint();
        const { allowSlideNext, allowSlidePrev, snapGrid } = swiper;
        (swiper.allowSlideNext = !0),
          (swiper.allowSlidePrev = !0),
          swiper.updateSize(),
          swiper.updateSlides(),
          swiper.updateSlidesClasses(),
          ('auto' === params.slidesPerView || params.slidesPerView > 1) &&
          swiper.isEnd &&
          !swiper.isBeginning &&
          !swiper.params.centeredSlides
            ? swiper.slideTo(swiper.slides.length - 1, 0, !1, !0)
            : swiper.slideTo(swiper.activeIndex, 0, !1, !0),
          swiper.autoplay &&
            swiper.autoplay.running &&
            swiper.autoplay.paused &&
            swiper.autoplay.run(),
          (swiper.allowSlidePrev = allowSlidePrev),
          (swiper.allowSlideNext = allowSlideNext),
          swiper.params.watchOverflow &&
            snapGrid !== swiper.snapGrid &&
            swiper.checkOverflow();
      }
      function onClick(e) {
        const swiper = this;
        swiper.enabled &&
          (swiper.allowClick ||
            (swiper.params.preventClicks && e.preventDefault(),
            swiper.params.preventClicksPropagation &&
              swiper.animating &&
              (e.stopPropagation(), e.stopImmediatePropagation())));
      }
      function onScroll() {
        const swiper = this,
          { wrapperEl, rtlTranslate, enabled } = swiper;
        if (!enabled) return;
        let newProgress;
        (swiper.previousTranslate = swiper.translate),
          swiper.isHorizontal()
            ? (swiper.translate = -wrapperEl.scrollLeft)
            : (swiper.translate = -wrapperEl.scrollTop),
          0 === swiper.translate && (swiper.translate = 0),
          swiper.updateActiveIndex(),
          swiper.updateSlidesClasses();
        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
        (newProgress =
          0 === translatesDiff
            ? 0
            : (swiper.translate - swiper.minTranslate()) / translatesDiff),
          newProgress !== swiper.progress &&
            swiper.updateProgress(
              rtlTranslate ? -swiper.translate : swiper.translate
            ),
          swiper.emit('setTranslate', swiper.translate, !1);
      }
      let dummyEventAttached = !1;
      function dummyEventListener() {}
      const events = (swiper, method) => {
        const document = ssr_window_esm_getDocument(),
          { params, touchEvents, el, wrapperEl, device, support } = swiper,
          capture = !!params.nested,
          domMethod =
            'on' === method ? 'addEventListener' : 'removeEventListener',
          swiperMethod = method;
        if (support.touch) {
          const passiveListener = !(
            'touchstart' !== touchEvents.start ||
            !support.passiveListener ||
            !params.passiveListeners
          ) && { passive: !0, capture: !1 };
          el[domMethod](
            touchEvents.start,
            swiper.onTouchStart,
            passiveListener
          ),
            el[domMethod](
              touchEvents.move,
              swiper.onTouchMove,
              support.passiveListener ? { passive: !1, capture } : capture
            ),
            el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener),
            touchEvents.cancel &&
              el[domMethod](
                touchEvents.cancel,
                swiper.onTouchEnd,
                passiveListener
              );
        } else
          el[domMethod](touchEvents.start, swiper.onTouchStart, !1),
            document[domMethod](touchEvents.move, swiper.onTouchMove, capture),
            document[domMethod](touchEvents.end, swiper.onTouchEnd, !1);
        (params.preventClicks || params.preventClicksPropagation) &&
          el[domMethod]('click', swiper.onClick, !0),
          params.cssMode && wrapperEl[domMethod]('scroll', swiper.onScroll),
          params.updateOnWindowResize
            ? swiper[swiperMethod](
                device.ios || device.android
                  ? 'resize orientationchange observerUpdate'
                  : 'resize observerUpdate',
                onResize,
                !0
              )
            : swiper[swiperMethod]('observerUpdate', onResize, !0);
      };
      const core_events = {
          attachEvents: function attachEvents() {
            const swiper = this,
              document = ssr_window_esm_getDocument(),
              { params, support } = swiper;
            (swiper.onTouchStart = onTouchStart.bind(swiper)),
              (swiper.onTouchMove = onTouchMove.bind(swiper)),
              (swiper.onTouchEnd = onTouchEnd.bind(swiper)),
              params.cssMode && (swiper.onScroll = onScroll.bind(swiper)),
              (swiper.onClick = onClick.bind(swiper)),
              support.touch &&
                !dummyEventAttached &&
                (document.addEventListener('touchstart', dummyEventListener),
                (dummyEventAttached = !0)),
              events(swiper, 'on');
          },
          detachEvents: function detachEvents() {
            events(this, 'off');
          },
        },
        isGridEnabled = (swiper, params) =>
          swiper.grid && params.grid && params.grid.rows > 1;
      const breakpoints = {
        setBreakpoint: function setBreakpoint() {
          const swiper = this,
            {
              activeIndex,
              initialized,
              loopedSlides = 0,
              params,
              $el,
            } = swiper,
            breakpoints = params.breakpoints;
          if (
            !breakpoints ||
            (breakpoints && 0 === Object.keys(breakpoints).length)
          )
            return;
          const breakpoint = swiper.getBreakpoint(
            breakpoints,
            swiper.params.breakpointsBase,
            swiper.el
          );
          if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
          const breakpointParams =
              (breakpoint in breakpoints ? breakpoints[breakpoint] : void 0) ||
              swiper.originalParams,
            wasMultiRow = isGridEnabled(swiper, params),
            isMultiRow = isGridEnabled(swiper, breakpointParams),
            wasEnabled = params.enabled;
          wasMultiRow && !isMultiRow
            ? ($el.removeClass(
                `${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`
              ),
              swiper.emitContainerClasses())
            : !wasMultiRow &&
              isMultiRow &&
              ($el.addClass(`${params.containerModifierClass}grid`),
              ((breakpointParams.grid.fill &&
                'column' === breakpointParams.grid.fill) ||
                (!breakpointParams.grid.fill &&
                  'column' === params.grid.fill)) &&
                $el.addClass(`${params.containerModifierClass}grid-column`),
              swiper.emitContainerClasses()),
            ['navigation', 'pagination', 'scrollbar'].forEach((prop) => {
              const wasModuleEnabled = params[prop] && params[prop].enabled,
                isModuleEnabled =
                  breakpointParams[prop] && breakpointParams[prop].enabled;
              wasModuleEnabled && !isModuleEnabled && swiper[prop].disable(),
                !wasModuleEnabled && isModuleEnabled && swiper[prop].enable();
            });
          const directionChanged =
              breakpointParams.direction &&
              breakpointParams.direction !== params.direction,
            needsReLoop =
              params.loop &&
              (breakpointParams.slidesPerView !== params.slidesPerView ||
                directionChanged);
          directionChanged && initialized && swiper.changeDirection(),
            utils_extend(swiper.params, breakpointParams);
          const isEnabled = swiper.params.enabled;
          Object.assign(swiper, {
            allowTouchMove: swiper.params.allowTouchMove,
            allowSlideNext: swiper.params.allowSlideNext,
            allowSlidePrev: swiper.params.allowSlidePrev,
          }),
            wasEnabled && !isEnabled
              ? swiper.disable()
              : !wasEnabled && isEnabled && swiper.enable(),
            (swiper.currentBreakpoint = breakpoint),
            swiper.emit('_beforeBreakpoint', breakpointParams),
            needsReLoop &&
              initialized &&
              (swiper.loopDestroy(),
              swiper.loopCreate(),
              swiper.updateSlides(),
              swiper.slideTo(
                activeIndex - loopedSlides + swiper.loopedSlides,
                0,
                !1
              )),
            swiper.emit('breakpoint', breakpointParams);
        },
        getBreakpoint: function getBreakpoint(
          breakpoints,
          base = 'window',
          containerEl
        ) {
          if (!breakpoints || ('container' === base && !containerEl)) return;
          let breakpoint = !1;
          const window = ssr_window_esm_getWindow(),
            currentHeight =
              'window' === base ? window.innerHeight : containerEl.clientHeight,
            points = Object.keys(breakpoints).map((point) => {
              if ('string' == typeof point && 0 === point.indexOf('@')) {
                const minRatio = parseFloat(point.substr(1));
                return { value: currentHeight * minRatio, point };
              }
              return { value: point, point };
            });
          points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
          for (let i = 0; i < points.length; i += 1) {
            const { point, value } = points[i];
            'window' === base
              ? window.matchMedia(`(min-width: ${value}px)`).matches &&
                (breakpoint = point)
              : value <= containerEl.clientWidth && (breakpoint = point);
          }
          return breakpoint || 'max';
        },
      };
      const classes = {
        addClasses: function addClasses() {
          const { classNames, params, rtl, $el, device, support } = this,
            suffixes = (function prepareClasses(entries, prefix) {
              const resultClasses = [];
              return (
                entries.forEach((item) => {
                  'object' == typeof item
                    ? Object.keys(item).forEach((classNames) => {
                        item[classNames] &&
                          resultClasses.push(prefix + classNames);
                      })
                    : 'string' == typeof item &&
                      resultClasses.push(prefix + item);
                }),
                resultClasses
              );
            })(
              [
                'initialized',
                params.direction,
                { 'pointer-events': !support.touch },
                {
                  'free-mode': this.params.freeMode && params.freeMode.enabled,
                },
                { autoheight: params.autoHeight },
                { rtl },
                { grid: params.grid && params.grid.rows > 1 },
                {
                  'grid-column':
                    params.grid &&
                    params.grid.rows > 1 &&
                    'column' === params.grid.fill,
                },
                { android: device.android },
                { ios: device.ios },
                { 'css-mode': params.cssMode },
                { centered: params.cssMode && params.centeredSlides },
                { 'watch-progress': params.watchSlidesProgress },
              ],
              params.containerModifierClass
            );
          classNames.push(...suffixes),
            $el.addClass([...classNames].join(' ')),
            this.emitContainerClasses();
        },
        removeClasses: function removeClasses() {
          const { $el, classNames } = this;
          $el.removeClass(classNames.join(' ')), this.emitContainerClasses();
        },
      };
      const defaults = {
        init: !0,
        direction: 'horizontal',
        touchEventsTarget: 'wrapper',
        initialSlide: 0,
        speed: 300,
        cssMode: !1,
        updateOnWindowResize: !0,
        resizeObserver: !0,
        nested: !1,
        createElements: !1,
        enabled: !0,
        focusableElements:
          'input, select, option, textarea, button, video, label',
        width: null,
        height: null,
        preventInteractionOnTransition: !1,
        userAgent: null,
        url: null,
        edgeSwipeDetection: !1,
        edgeSwipeThreshold: 20,
        autoHeight: !1,
        setWrapperSize: !1,
        virtualTranslate: !1,
        effect: 'slide',
        breakpoints: void 0,
        breakpointsBase: 'window',
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerGroup: 1,
        slidesPerGroupSkip: 0,
        slidesPerGroupAuto: !1,
        centeredSlides: !1,
        centeredSlidesBounds: !1,
        slidesOffsetBefore: 0,
        slidesOffsetAfter: 0,
        normalizeSlideIndex: !0,
        centerInsufficientSlides: !1,
        watchOverflow: !0,
        roundLengths: !1,
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: !0,
        shortSwipes: !0,
        longSwipes: !0,
        longSwipesRatio: 0.5,
        longSwipesMs: 300,
        followFinger: !0,
        allowTouchMove: !0,
        threshold: 0,
        touchMoveStopPropagation: !1,
        touchStartPreventDefault: !0,
        touchStartForcePreventDefault: !1,
        touchReleaseOnEdges: !1,
        uniqueNavElements: !0,
        resistance: !0,
        resistanceRatio: 0.85,
        watchSlidesProgress: !1,
        grabCursor: !1,
        preventClicks: !0,
        preventClicksPropagation: !0,
        slideToClickedSlide: !1,
        preloadImages: !0,
        updateOnImagesReady: !0,
        loop: !1,
        loopAdditionalSlides: 0,
        loopedSlides: null,
        loopedSlidesLimit: !0,
        loopFillGroupWithBlank: !1,
        loopPreventsSlide: !0,
        rewind: !1,
        allowSlidePrev: !0,
        allowSlideNext: !0,
        swipeHandler: null,
        noSwiping: !0,
        noSwipingClass: 'swiper-no-swiping',
        noSwipingSelector: null,
        passiveListeners: !0,
        maxBackfaceHiddenSlides: 10,
        containerModifierClass: 'swiper-',
        slideClass: 'swiper-slide',
        slideBlankClass: 'swiper-slide-invisible-blank',
        slideActiveClass: 'swiper-slide-active',
        slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
        slideVisibleClass: 'swiper-slide-visible',
        slideDuplicateClass: 'swiper-slide-duplicate',
        slideNextClass: 'swiper-slide-next',
        slideDuplicateNextClass: 'swiper-slide-duplicate-next',
        slidePrevClass: 'swiper-slide-prev',
        slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
        wrapperClass: 'swiper-wrapper',
        runCallbacksOnInit: !0,
        _emitClasses: !1,
      };
      function moduleExtendParams(params, allModulesParams) {
        return function extendParams(obj = {}) {
          const moduleParamName = Object.keys(obj)[0],
            moduleParams = obj[moduleParamName];
          'object' == typeof moduleParams && null !== moduleParams
            ? (['navigation', 'pagination', 'scrollbar'].indexOf(
                moduleParamName
              ) >= 0 &&
                !0 === params[moduleParamName] &&
                (params[moduleParamName] = { auto: !0 }),
              moduleParamName in params && 'enabled' in moduleParams
                ? (!0 === params[moduleParamName] &&
                    (params[moduleParamName] = { enabled: !0 }),
                  'object' != typeof params[moduleParamName] ||
                    'enabled' in params[moduleParamName] ||
                    (params[moduleParamName].enabled = !0),
                  params[moduleParamName] ||
                    (params[moduleParamName] = { enabled: !1 }),
                  utils_extend(allModulesParams, obj))
                : utils_extend(allModulesParams, obj))
            : utils_extend(allModulesParams, obj);
        };
      }
      const prototypes = {
          eventsEmitter: events_emitter,
          update,
          translate,
          transition: {
            setTransition: function setTransition(duration, byController) {
              const swiper = this;
              swiper.params.cssMode || swiper.$wrapperEl.transition(duration),
                swiper.emit('setTransition', duration, byController);
            },
            transitionStart: function transitionStart(
              runCallbacks = !0,
              direction
            ) {
              const swiper = this,
                { params } = swiper;
              params.cssMode ||
                (params.autoHeight && swiper.updateAutoHeight(),
                transitionEmit({
                  swiper,
                  runCallbacks,
                  direction,
                  step: 'Start',
                }));
            },
            transitionEnd: function transitionEnd_transitionEnd(
              runCallbacks = !0,
              direction
            ) {
              const { params } = this;
              (this.animating = !1),
                params.cssMode ||
                  (this.setTransition(0),
                  transitionEmit({
                    swiper: this,
                    runCallbacks,
                    direction,
                    step: 'End',
                  }));
            },
          },
          slide,
          loop,
          grabCursor: {
            setGrabCursor: function setGrabCursor(moving) {
              if (
                this.support.touch ||
                !this.params.simulateTouch ||
                (this.params.watchOverflow && this.isLocked) ||
                this.params.cssMode
              )
                return;
              const el =
                'container' === this.params.touchEventsTarget
                  ? this.el
                  : this.wrapperEl;
              (el.style.cursor = 'move'),
                (el.style.cursor = moving ? 'grabbing' : 'grab');
            },
            unsetGrabCursor: function unsetGrabCursor() {
              this.support.touch ||
                (this.params.watchOverflow && this.isLocked) ||
                this.params.cssMode ||
                (this[
                  'container' === this.params.touchEventsTarget
                    ? 'el'
                    : 'wrapperEl'
                ].style.cursor = '');
            },
          },
          events: core_events,
          breakpoints,
          checkOverflow: {
            checkOverflow: function checkOverflow() {
              const swiper = this,
                { isLocked: wasLocked, params } = swiper,
                { slidesOffsetBefore } = params;
              if (slidesOffsetBefore) {
                const lastSlideIndex = swiper.slides.length - 1,
                  lastSlideRightEdge =
                    swiper.slidesGrid[lastSlideIndex] +
                    swiper.slidesSizesGrid[lastSlideIndex] +
                    2 * slidesOffsetBefore;
                swiper.isLocked = swiper.size > lastSlideRightEdge;
              } else swiper.isLocked = 1 === swiper.snapGrid.length;
              !0 === params.allowSlideNext &&
                (swiper.allowSlideNext = !swiper.isLocked),
                !0 === params.allowSlidePrev &&
                  (swiper.allowSlidePrev = !swiper.isLocked),
                wasLocked &&
                  wasLocked !== swiper.isLocked &&
                  (swiper.isEnd = !1),
                wasLocked !== swiper.isLocked &&
                  swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
            },
          },
          classes,
          images: {
            loadImage: function loadImage(
              imageEl,
              src,
              srcset,
              sizes,
              checkForComplete,
              callback
            ) {
              const window = ssr_window_esm_getWindow();
              let image;
              function onReady() {
                callback && callback();
              }
              dom(imageEl).parent('picture')[0] ||
              (imageEl.complete && checkForComplete)
                ? onReady()
                : src
                ? ((image = new window.Image()),
                  (image.onload = onReady),
                  (image.onerror = onReady),
                  sizes && (image.sizes = sizes),
                  srcset && (image.srcset = srcset),
                  src && (image.src = src))
                : onReady();
            },
            preloadImages: function preloadImages() {
              const swiper = this;
              function onReady() {
                null != swiper &&
                  swiper &&
                  !swiper.destroyed &&
                  (void 0 !== swiper.imagesLoaded && (swiper.imagesLoaded += 1),
                  swiper.imagesLoaded === swiper.imagesToLoad.length &&
                    (swiper.params.updateOnImagesReady && swiper.update(),
                    swiper.emit('imagesReady')));
              }
              swiper.imagesToLoad = swiper.$el.find('img');
              for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
                const imageEl = swiper.imagesToLoad[i];
                swiper.loadImage(
                  imageEl,
                  imageEl.currentSrc || imageEl.getAttribute('src'),
                  imageEl.srcset || imageEl.getAttribute('srcset'),
                  imageEl.sizes || imageEl.getAttribute('sizes'),
                  !0,
                  onReady
                );
              }
            },
          },
        },
        extendedDefaults = {};
      class Swiper {
        constructor(...args) {
          let el, params;
          if (
            (1 === args.length &&
            args[0].constructor &&
            'Object' === Object.prototype.toString.call(args[0]).slice(8, -1)
              ? (params = args[0])
              : ([el, params] = args),
            params || (params = {}),
            (params = utils_extend({}, params)),
            el && !params.el && (params.el = el),
            params.el && dom(params.el).length > 1)
          ) {
            const swipers = [];
            return (
              dom(params.el).each((containerEl) => {
                const newParams = utils_extend({}, params, { el: containerEl });
                swipers.push(new Swiper(newParams));
              }),
              swipers
            );
          }
          const swiper = this;
          (swiper.__swiper__ = !0),
            (swiper.support = getSupport()),
            (swiper.device = getDevice({ userAgent: params.userAgent })),
            (swiper.browser = getBrowser()),
            (swiper.eventsListeners = {}),
            (swiper.eventsAnyListeners = []),
            (swiper.modules = [...swiper.__modules__]),
            params.modules &&
              Array.isArray(params.modules) &&
              swiper.modules.push(...params.modules);
          const allModulesParams = {};
          swiper.modules.forEach((mod) => {
            mod({
              swiper,
              extendParams: moduleExtendParams(params, allModulesParams),
              on: swiper.on.bind(swiper),
              once: swiper.once.bind(swiper),
              off: swiper.off.bind(swiper),
              emit: swiper.emit.bind(swiper),
            });
          });
          const swiperParams = utils_extend({}, defaults, allModulesParams);
          return (
            (swiper.params = utils_extend(
              {},
              swiperParams,
              extendedDefaults,
              params
            )),
            (swiper.originalParams = utils_extend({}, swiper.params)),
            (swiper.passedParams = utils_extend({}, params)),
            swiper.params &&
              swiper.params.on &&
              Object.keys(swiper.params.on).forEach((eventName) => {
                swiper.on(eventName, swiper.params.on[eventName]);
              }),
            swiper.params &&
              swiper.params.onAny &&
              swiper.onAny(swiper.params.onAny),
            (swiper.$ = dom),
            Object.assign(swiper, {
              enabled: swiper.params.enabled,
              el,
              classNames: [],
              slides: dom(),
              slidesGrid: [],
              snapGrid: [],
              slidesSizesGrid: [],
              isHorizontal: () => 'horizontal' === swiper.params.direction,
              isVertical: () => 'vertical' === swiper.params.direction,
              activeIndex: 0,
              realIndex: 0,
              isBeginning: !0,
              isEnd: !1,
              translate: 0,
              previousTranslate: 0,
              progress: 0,
              velocity: 0,
              animating: !1,
              allowSlideNext: swiper.params.allowSlideNext,
              allowSlidePrev: swiper.params.allowSlidePrev,
              touchEvents: (function touchEvents() {
                const touch = [
                    'touchstart',
                    'touchmove',
                    'touchend',
                    'touchcancel',
                  ],
                  desktop = ['pointerdown', 'pointermove', 'pointerup'];
                return (
                  (swiper.touchEventsTouch = {
                    start: touch[0],
                    move: touch[1],
                    end: touch[2],
                    cancel: touch[3],
                  }),
                  (swiper.touchEventsDesktop = {
                    start: desktop[0],
                    move: desktop[1],
                    end: desktop[2],
                  }),
                  swiper.support.touch || !swiper.params.simulateTouch
                    ? swiper.touchEventsTouch
                    : swiper.touchEventsDesktop
                );
              })(),
              touchEventsData: {
                isTouched: void 0,
                isMoved: void 0,
                allowTouchCallbacks: void 0,
                touchStartTime: void 0,
                isScrolling: void 0,
                currentTranslate: void 0,
                startTranslate: void 0,
                allowThresholdMove: void 0,
                focusableElements: swiper.params.focusableElements,
                lastClickTime: utils_now(),
                clickTimeout: void 0,
                velocities: [],
                allowMomentumBounce: void 0,
                isTouchEvent: void 0,
                startMoving: void 0,
              },
              allowClick: !0,
              allowTouchMove: swiper.params.allowTouchMove,
              touches: {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                diff: 0,
              },
              imagesToLoad: [],
              imagesLoaded: 0,
            }),
            swiper.emit('_swiper'),
            swiper.params.init && swiper.init(),
            swiper
          );
        }
        enable() {
          const swiper = this;
          swiper.enabled ||
            ((swiper.enabled = !0),
            swiper.params.grabCursor && swiper.setGrabCursor(),
            swiper.emit('enable'));
        }
        disable() {
          const swiper = this;
          swiper.enabled &&
            ((swiper.enabled = !1),
            swiper.params.grabCursor && swiper.unsetGrabCursor(),
            swiper.emit('disable'));
        }
        setProgress(progress, speed) {
          progress = Math.min(Math.max(progress, 0), 1);
          const min = this.minTranslate(),
            current = (this.maxTranslate() - min) * progress + min;
          this.translateTo(current, void 0 === speed ? 0 : speed),
            this.updateActiveIndex(),
            this.updateSlidesClasses();
        }
        emitContainerClasses() {
          const swiper = this;
          if (!swiper.params._emitClasses || !swiper.el) return;
          const cls = swiper.el.className
            .split(' ')
            .filter(
              (className) =>
                0 === className.indexOf('swiper') ||
                0 === className.indexOf(swiper.params.containerModifierClass)
            );
          swiper.emit('_containerClasses', cls.join(' '));
        }
        getSlideClasses(slideEl) {
          const swiper = this;
          return swiper.destroyed
            ? ''
            : slideEl.className
                .split(' ')
                .filter(
                  (className) =>
                    0 === className.indexOf('swiper-slide') ||
                    0 === className.indexOf(swiper.params.slideClass)
                )
                .join(' ');
        }
        emitSlidesClasses() {
          const swiper = this;
          if (!swiper.params._emitClasses || !swiper.el) return;
          const updates = [];
          swiper.slides.each((slideEl) => {
            const classNames = swiper.getSlideClasses(slideEl);
            updates.push({ slideEl, classNames }),
              swiper.emit('_slideClass', slideEl, classNames);
          }),
            swiper.emit('_slideClasses', updates);
        }
        slidesPerViewDynamic(view = 'current', exact = !1) {
          const {
            params,
            slides,
            slidesGrid,
            slidesSizesGrid,
            size: swiperSize,
            activeIndex,
          } = this;
          let spv = 1;
          if (params.centeredSlides) {
            let breakLoop,
              slideSize = slides[activeIndex].swiperSlideSize;
            for (let i = activeIndex + 1; i < slides.length; i += 1)
              slides[i] &&
                !breakLoop &&
                ((slideSize += slides[i].swiperSlideSize),
                (spv += 1),
                slideSize > swiperSize && (breakLoop = !0));
            for (let i = activeIndex - 1; i >= 0; i -= 1)
              slides[i] &&
                !breakLoop &&
                ((slideSize += slides[i].swiperSlideSize),
                (spv += 1),
                slideSize > swiperSize && (breakLoop = !0));
          } else if ('current' === view)
            for (let i = activeIndex + 1; i < slides.length; i += 1) {
              (exact
                ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] <
                  swiperSize
                : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize) &&
                (spv += 1);
            }
          else
            for (let i = activeIndex - 1; i >= 0; i -= 1) {
              slidesGrid[activeIndex] - slidesGrid[i] < swiperSize &&
                (spv += 1);
            }
          return spv;
        }
        update() {
          const swiper = this;
          if (!swiper || swiper.destroyed) return;
          const { snapGrid, params } = swiper;
          function setTranslate() {
            const translateValue = swiper.rtlTranslate
                ? -1 * swiper.translate
                : swiper.translate,
              newTranslate = Math.min(
                Math.max(translateValue, swiper.maxTranslate()),
                swiper.minTranslate()
              );
            swiper.setTranslate(newTranslate),
              swiper.updateActiveIndex(),
              swiper.updateSlidesClasses();
          }
          let translated;
          params.breakpoints && swiper.setBreakpoint(),
            swiper.updateSize(),
            swiper.updateSlides(),
            swiper.updateProgress(),
            swiper.updateSlidesClasses(),
            swiper.params.freeMode && swiper.params.freeMode.enabled
              ? (setTranslate(),
                swiper.params.autoHeight && swiper.updateAutoHeight())
              : ((translated =
                  ('auto' === swiper.params.slidesPerView ||
                    swiper.params.slidesPerView > 1) &&
                  swiper.isEnd &&
                  !swiper.params.centeredSlides
                    ? swiper.slideTo(swiper.slides.length - 1, 0, !1, !0)
                    : swiper.slideTo(swiper.activeIndex, 0, !1, !0)),
                translated || setTranslate()),
            params.watchOverflow &&
              snapGrid !== swiper.snapGrid &&
              swiper.checkOverflow(),
            swiper.emit('update');
        }
        changeDirection(newDirection, needUpdate = !0) {
          const swiper = this,
            currentDirection = swiper.params.direction;
          return (
            newDirection ||
              (newDirection =
                'horizontal' === currentDirection ? 'vertical' : 'horizontal'),
            newDirection === currentDirection ||
              ('horizontal' !== newDirection && 'vertical' !== newDirection) ||
              (swiper.$el
                .removeClass(
                  `${swiper.params.containerModifierClass}${currentDirection}`
                )
                .addClass(
                  `${swiper.params.containerModifierClass}${newDirection}`
                ),
              swiper.emitContainerClasses(),
              (swiper.params.direction = newDirection),
              swiper.slides.each((slideEl) => {
                'vertical' === newDirection
                  ? (slideEl.style.width = '')
                  : (slideEl.style.height = '');
              }),
              swiper.emit('changeDirection'),
              needUpdate && swiper.update()),
            swiper
          );
        }
        changeLanguageDirection(direction) {
          const swiper = this;
          (swiper.rtl && 'rtl' === direction) ||
            (!swiper.rtl && 'ltr' === direction) ||
            ((swiper.rtl = 'rtl' === direction),
            (swiper.rtlTranslate =
              'horizontal' === swiper.params.direction && swiper.rtl),
            swiper.rtl
              ? (swiper.$el.addClass(
                  `${swiper.params.containerModifierClass}rtl`
                ),
                (swiper.el.dir = 'rtl'))
              : (swiper.$el.removeClass(
                  `${swiper.params.containerModifierClass}rtl`
                ),
                (swiper.el.dir = 'ltr')),
            swiper.update());
        }
        mount(el) {
          const swiper = this;
          if (swiper.mounted) return !0;
          const $el = dom(el || swiper.params.el);
          if (!(el = $el[0])) return !1;
          el.swiper = swiper;
          const getWrapperSelector = () =>
            `.${(swiper.params.wrapperClass || '')
              .trim()
              .split(' ')
              .join('.')}`;
          let $wrapperEl = (() => {
            if (el && el.shadowRoot && el.shadowRoot.querySelector) {
              const res = dom(
                el.shadowRoot.querySelector(getWrapperSelector())
              );
              return (res.children = (options) => $el.children(options)), res;
            }
            return $el.children
              ? $el.children(getWrapperSelector())
              : dom($el).children(getWrapperSelector());
          })();
          if (0 === $wrapperEl.length && swiper.params.createElements) {
            const wrapper = ssr_window_esm_getDocument().createElement('div');
            ($wrapperEl = dom(wrapper)),
              (wrapper.className = swiper.params.wrapperClass),
              $el.append(wrapper),
              $el.children(`.${swiper.params.slideClass}`).each((slideEl) => {
                $wrapperEl.append(slideEl);
              });
          }
          return (
            Object.assign(swiper, {
              $el,
              el,
              $wrapperEl,
              wrapperEl: $wrapperEl[0],
              mounted: !0,
              rtl:
                'rtl' === el.dir.toLowerCase() ||
                'rtl' === $el.css('direction'),
              rtlTranslate:
                'horizontal' === swiper.params.direction &&
                ('rtl' === el.dir.toLowerCase() ||
                  'rtl' === $el.css('direction')),
              wrongRTL: '-webkit-box' === $wrapperEl.css('display'),
            }),
            !0
          );
        }
        init(el) {
          const swiper = this;
          if (swiper.initialized) return swiper;
          return (
            !1 === swiper.mount(el) ||
              (swiper.emit('beforeInit'),
              swiper.params.breakpoints && swiper.setBreakpoint(),
              swiper.addClasses(),
              swiper.params.loop && swiper.loopCreate(),
              swiper.updateSize(),
              swiper.updateSlides(),
              swiper.params.watchOverflow && swiper.checkOverflow(),
              swiper.params.grabCursor &&
                swiper.enabled &&
                swiper.setGrabCursor(),
              swiper.params.preloadImages && swiper.preloadImages(),
              swiper.params.loop
                ? swiper.slideTo(
                    swiper.params.initialSlide + swiper.loopedSlides,
                    0,
                    swiper.params.runCallbacksOnInit,
                    !1,
                    !0
                  )
                : swiper.slideTo(
                    swiper.params.initialSlide,
                    0,
                    swiper.params.runCallbacksOnInit,
                    !1,
                    !0
                  ),
              swiper.attachEvents(),
              (swiper.initialized = !0),
              swiper.emit('init'),
              swiper.emit('afterInit')),
            swiper
          );
        }
        destroy(deleteInstance = !0, cleanStyles = !0) {
          const swiper = this,
            { params, $el, $wrapperEl, slides } = swiper;
          return (
            void 0 === swiper.params ||
              swiper.destroyed ||
              (swiper.emit('beforeDestroy'),
              (swiper.initialized = !1),
              swiper.detachEvents(),
              params.loop && swiper.loopDestroy(),
              cleanStyles &&
                (swiper.removeClasses(),
                $el.removeAttr('style'),
                $wrapperEl.removeAttr('style'),
                slides &&
                  slides.length &&
                  slides
                    .removeClass(
                      [
                        params.slideVisibleClass,
                        params.slideActiveClass,
                        params.slideNextClass,
                        params.slidePrevClass,
                      ].join(' ')
                    )
                    .removeAttr('style')
                    .removeAttr('data-swiper-slide-index')),
              swiper.emit('destroy'),
              Object.keys(swiper.eventsListeners).forEach((eventName) => {
                swiper.off(eventName);
              }),
              !1 !== deleteInstance &&
                ((swiper.$el[0].swiper = null),
                (function deleteProps(obj) {
                  const object = obj;
                  Object.keys(object).forEach((key) => {
                    try {
                      object[key] = null;
                    } catch (e) {}
                    try {
                      delete object[key];
                    } catch (e) {}
                  });
                })(swiper)),
              (swiper.destroyed = !0)),
            null
          );
        }
        static extendDefaults(newDefaults) {
          utils_extend(extendedDefaults, newDefaults);
        }
        static get extendedDefaults() {
          return extendedDefaults;
        }
        static get defaults() {
          return defaults;
        }
        static installModule(mod) {
          Swiper.prototype.__modules__ || (Swiper.prototype.__modules__ = []);
          const modules = Swiper.prototype.__modules__;
          'function' == typeof mod &&
            modules.indexOf(mod) < 0 &&
            modules.push(mod);
        }
        static use(module) {
          return Array.isArray(module)
            ? (module.forEach((m) => Swiper.installModule(m)), Swiper)
            : (Swiper.installModule(module), Swiper);
        }
      }
      Object.keys(prototypes).forEach((prototypeGroup) => {
        Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
          Swiper.prototype[protoMethod] =
            prototypes[prototypeGroup][protoMethod];
        });
      }),
        Swiper.use([
          function Resize({ swiper, on, emit }) {
            const window = ssr_window_esm_getWindow();
            let observer = null,
              animationFrame = null;
            const resizeHandler = () => {
                swiper &&
                  !swiper.destroyed &&
                  swiper.initialized &&
                  (emit('beforeResize'), emit('resize'));
              },
              orientationChangeHandler = () => {
                swiper &&
                  !swiper.destroyed &&
                  swiper.initialized &&
                  emit('orientationchange');
              };
            on('init', () => {
              swiper.params.resizeObserver && void 0 !== window.ResizeObserver
                ? swiper &&
                  !swiper.destroyed &&
                  swiper.initialized &&
                  ((observer = new ResizeObserver((entries) => {
                    animationFrame = window.requestAnimationFrame(() => {
                      const { width, height } = swiper;
                      let newWidth = width,
                        newHeight = height;
                      entries.forEach(
                        ({ contentBoxSize, contentRect, target }) => {
                          (target && target !== swiper.el) ||
                            ((newWidth = contentRect
                              ? contentRect.width
                              : (contentBoxSize[0] || contentBoxSize)
                                  .inlineSize),
                            (newHeight = contentRect
                              ? contentRect.height
                              : (contentBoxSize[0] || contentBoxSize)
                                  .blockSize));
                        }
                      ),
                        (newWidth === width && newHeight === height) ||
                          resizeHandler();
                    });
                  })),
                  observer.observe(swiper.el))
                : (window.addEventListener('resize', resizeHandler),
                  window.addEventListener(
                    'orientationchange',
                    orientationChangeHandler
                  ));
            }),
              on('destroy', () => {
                animationFrame && window.cancelAnimationFrame(animationFrame),
                  observer &&
                    observer.unobserve &&
                    swiper.el &&
                    (observer.unobserve(swiper.el), (observer = null)),
                  window.removeEventListener('resize', resizeHandler),
                  window.removeEventListener(
                    'orientationchange',
                    orientationChangeHandler
                  );
              });
          },
          function Observer({ swiper, extendParams, on, emit }) {
            const observers = [],
              window = ssr_window_esm_getWindow(),
              attach = (target, options = {}) => {
                const observer = new (window.MutationObserver ||
                  window.WebkitMutationObserver)((mutations) => {
                  if (1 === mutations.length)
                    return void emit('observerUpdate', mutations[0]);
                  const observerUpdate = function observerUpdate() {
                    emit('observerUpdate', mutations[0]);
                  };
                  window.requestAnimationFrame
                    ? window.requestAnimationFrame(observerUpdate)
                    : window.setTimeout(observerUpdate, 0);
                });
                observer.observe(target, {
                  attributes:
                    void 0 === options.attributes || options.attributes,
                  childList: void 0 === options.childList || options.childList,
                  characterData:
                    void 0 === options.characterData || options.characterData,
                }),
                  observers.push(observer);
              };
            extendParams({
              observer: !1,
              observeParents: !1,
              observeSlideChildren: !1,
            }),
              on('init', () => {
                if (swiper.params.observer) {
                  if (swiper.params.observeParents) {
                    const containerParents = swiper.$el.parents();
                    for (let i = 0; i < containerParents.length; i += 1)
                      attach(containerParents[i]);
                  }
                  attach(swiper.$el[0], {
                    childList: swiper.params.observeSlideChildren,
                  }),
                    attach(swiper.$wrapperEl[0], { attributes: !1 });
                }
              }),
              on('destroy', () => {
                observers.forEach((observer) => {
                  observer.disconnect();
                }),
                  observers.splice(0, observers.length);
              });
          },
        ]);
      const core = Swiper;
      function create_element_if_not_defined_createElementIfNotDefined(
        swiper,
        originalParams,
        params,
        checkProps
      ) {
        const document = ssr_window_esm_getDocument();
        return (
          swiper.params.createElements &&
            Object.keys(checkProps).forEach((key) => {
              if (!params[key] && !0 === params.auto) {
                let element = swiper.$el.children(`.${checkProps[key]}`)[0];
                element ||
                  ((element = document.createElement('div')),
                  (element.className = checkProps[key]),
                  swiper.$el.append(element)),
                  (params[key] = element),
                  (originalParams[key] = element);
              }
            }),
          params
        );
      }
      function Navigation({ swiper, extendParams, on, emit }) {
        function getEl(el) {
          let $el;
          return (
            el &&
              (($el = dom(el)),
              swiper.params.uniqueNavElements &&
                'string' == typeof el &&
                $el.length > 1 &&
                1 === swiper.$el.find(el).length &&
                ($el = swiper.$el.find(el))),
            $el
          );
        }
        function toggleEl($el, disabled) {
          const params = swiper.params.navigation;
          $el &&
            $el.length > 0 &&
            ($el[disabled ? 'addClass' : 'removeClass'](params.disabledClass),
            $el[0] &&
              'BUTTON' === $el[0].tagName &&
              ($el[0].disabled = disabled),
            swiper.params.watchOverflow &&
              swiper.enabled &&
              $el[swiper.isLocked ? 'addClass' : 'removeClass'](
                params.lockClass
              ));
        }
        function update() {
          if (swiper.params.loop) return;
          const { $nextEl, $prevEl } = swiper.navigation;
          toggleEl($prevEl, swiper.isBeginning && !swiper.params.rewind),
            toggleEl($nextEl, swiper.isEnd && !swiper.params.rewind);
        }
        function onPrevClick(e) {
          e.preventDefault(),
            (!swiper.isBeginning ||
              swiper.params.loop ||
              swiper.params.rewind) &&
              (swiper.slidePrev(), emit('navigationPrev'));
        }
        function onNextClick(e) {
          e.preventDefault(),
            (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) &&
              (swiper.slideNext(), emit('navigationNext'));
        }
        function init() {
          const params = swiper.params.navigation;
          if (
            ((swiper.params.navigation =
              create_element_if_not_defined_createElementIfNotDefined(
                swiper,
                swiper.originalParams.navigation,
                swiper.params.navigation,
                { nextEl: 'swiper-button-next', prevEl: 'swiper-button-prev' }
              )),
            !params.nextEl && !params.prevEl)
          )
            return;
          const $nextEl = getEl(params.nextEl),
            $prevEl = getEl(params.prevEl);
          $nextEl && $nextEl.length > 0 && $nextEl.on('click', onNextClick),
            $prevEl && $prevEl.length > 0 && $prevEl.on('click', onPrevClick),
            Object.assign(swiper.navigation, {
              $nextEl,
              nextEl: $nextEl && $nextEl[0],
              $prevEl,
              prevEl: $prevEl && $prevEl[0],
            }),
            swiper.enabled ||
              ($nextEl && $nextEl.addClass(params.lockClass),
              $prevEl && $prevEl.addClass(params.lockClass));
        }
        function destroy() {
          const { $nextEl, $prevEl } = swiper.navigation;
          $nextEl &&
            $nextEl.length &&
            ($nextEl.off('click', onNextClick),
            $nextEl.removeClass(swiper.params.navigation.disabledClass)),
            $prevEl &&
              $prevEl.length &&
              ($prevEl.off('click', onPrevClick),
              $prevEl.removeClass(swiper.params.navigation.disabledClass));
        }
        extendParams({
          navigation: {
            nextEl: null,
            prevEl: null,
            hideOnClick: !1,
            disabledClass: 'swiper-button-disabled',
            hiddenClass: 'swiper-button-hidden',
            lockClass: 'swiper-button-lock',
            navigationDisabledClass: 'swiper-navigation-disabled',
          },
        }),
          (swiper.navigation = {
            nextEl: null,
            $nextEl: null,
            prevEl: null,
            $prevEl: null,
          }),
          on('init', () => {
            !1 === swiper.params.navigation.enabled
              ? disable()
              : (init(), update());
          }),
          on('toEdge fromEdge lock unlock', () => {
            update();
          }),
          on('destroy', () => {
            destroy();
          }),
          on('enable disable', () => {
            const { $nextEl, $prevEl } = swiper.navigation;
            $nextEl &&
              $nextEl[swiper.enabled ? 'removeClass' : 'addClass'](
                swiper.params.navigation.lockClass
              ),
              $prevEl &&
                $prevEl[swiper.enabled ? 'removeClass' : 'addClass'](
                  swiper.params.navigation.lockClass
                );
          }),
          on('click', (_s, e) => {
            const { $nextEl, $prevEl } = swiper.navigation,
              targetEl = e.target;
            if (
              swiper.params.navigation.hideOnClick &&
              !dom(targetEl).is($prevEl) &&
              !dom(targetEl).is($nextEl)
            ) {
              if (
                swiper.pagination &&
                swiper.params.pagination &&
                swiper.params.pagination.clickable &&
                (swiper.pagination.el === targetEl ||
                  swiper.pagination.el.contains(targetEl))
              )
                return;
              let isHidden;
              $nextEl
                ? (isHidden = $nextEl.hasClass(
                    swiper.params.navigation.hiddenClass
                  ))
                : $prevEl &&
                  (isHidden = $prevEl.hasClass(
                    swiper.params.navigation.hiddenClass
                  )),
                emit(!0 === isHidden ? 'navigationShow' : 'navigationHide'),
                $nextEl &&
                  $nextEl.toggleClass(swiper.params.navigation.hiddenClass),
                $prevEl &&
                  $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
            }
          });
        const disable = () => {
          swiper.$el.addClass(swiper.params.navigation.navigationDisabledClass),
            destroy();
        };
        Object.assign(swiper.navigation, {
          enable: () => {
            swiper.$el.removeClass(
              swiper.params.navigation.navigationDisabledClass
            ),
              init(),
              update();
          },
          disable,
          update,
          init,
          destroy,
        });
      }
      function classes_to_selector_classesToSelector(classes = '') {
        return `.${classes
          .trim()
          .replace(/([\.:!\/])/g, '\\$1')
          .replace(/ /g, '.')}`;
      }
      function Pagination({ swiper, extendParams, on, emit }) {
        const pfx = 'swiper-pagination';
        let bulletSize;
        extendParams({
          pagination: {
            el: null,
            bulletElement: 'span',
            clickable: !1,
            hideOnClick: !1,
            renderBullet: null,
            renderProgressbar: null,
            renderFraction: null,
            renderCustom: null,
            progressbarOpposite: !1,
            type: 'bullets',
            dynamicBullets: !1,
            dynamicMainBullets: 1,
            formatFractionCurrent: (number) => number,
            formatFractionTotal: (number) => number,
            bulletClass: `${pfx}-bullet`,
            bulletActiveClass: `${pfx}-bullet-active`,
            modifierClass: `${pfx}-`,
            currentClass: `${pfx}-current`,
            totalClass: `${pfx}-total`,
            hiddenClass: `${pfx}-hidden`,
            progressbarFillClass: `${pfx}-progressbar-fill`,
            progressbarOppositeClass: `${pfx}-progressbar-opposite`,
            clickableClass: `${pfx}-clickable`,
            lockClass: `${pfx}-lock`,
            horizontalClass: `${pfx}-horizontal`,
            verticalClass: `${pfx}-vertical`,
            paginationDisabledClass: `${pfx}-disabled`,
          },
        }),
          (swiper.pagination = { el: null, $el: null, bullets: [] });
        let dynamicBulletIndex = 0;
        function isPaginationDisabled() {
          return (
            !swiper.params.pagination.el ||
            !swiper.pagination.el ||
            !swiper.pagination.$el ||
            0 === swiper.pagination.$el.length
          );
        }
        function setSideBullets($bulletEl, position) {
          const { bulletActiveClass } = swiper.params.pagination;
          $bulletEl[position]()
            .addClass(`${bulletActiveClass}-${position}`)
            [position]()
            .addClass(`${bulletActiveClass}-${position}-${position}`);
        }
        function update() {
          const rtl = swiper.rtl,
            params = swiper.params.pagination;
          if (isPaginationDisabled()) return;
          const slidesLength =
              swiper.virtual && swiper.params.virtual.enabled
                ? swiper.virtual.slides.length
                : swiper.slides.length,
            $el = swiper.pagination.$el;
          let current;
          const total = swiper.params.loop
            ? Math.ceil(
                (slidesLength - 2 * swiper.loopedSlides) /
                  swiper.params.slidesPerGroup
              )
            : swiper.snapGrid.length;
          if (
            (swiper.params.loop
              ? ((current = Math.ceil(
                  (swiper.activeIndex - swiper.loopedSlides) /
                    swiper.params.slidesPerGroup
                )),
                current > slidesLength - 1 - 2 * swiper.loopedSlides &&
                  (current -= slidesLength - 2 * swiper.loopedSlides),
                current > total - 1 && (current -= total),
                current < 0 &&
                  'bullets' !== swiper.params.paginationType &&
                  (current = total + current))
              : (current =
                  void 0 !== swiper.snapIndex
                    ? swiper.snapIndex
                    : swiper.activeIndex || 0),
            'bullets' === params.type &&
              swiper.pagination.bullets &&
              swiper.pagination.bullets.length > 0)
          ) {
            const bullets = swiper.pagination.bullets;
            let firstIndex, lastIndex, midIndex;
            if (
              (params.dynamicBullets &&
                ((bulletSize = bullets
                  .eq(0)
                  [swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](!0)),
                $el.css(
                  swiper.isHorizontal() ? 'width' : 'height',
                  bulletSize * (params.dynamicMainBullets + 4) + 'px'
                ),
                params.dynamicMainBullets > 1 &&
                  void 0 !== swiper.previousIndex &&
                  ((dynamicBulletIndex +=
                    current -
                    (swiper.previousIndex - swiper.loopedSlides || 0)),
                  dynamicBulletIndex > params.dynamicMainBullets - 1
                    ? (dynamicBulletIndex = params.dynamicMainBullets - 1)
                    : dynamicBulletIndex < 0 && (dynamicBulletIndex = 0)),
                (firstIndex = Math.max(current - dynamicBulletIndex, 0)),
                (lastIndex =
                  firstIndex +
                  (Math.min(bullets.length, params.dynamicMainBullets) - 1)),
                (midIndex = (lastIndex + firstIndex) / 2)),
              bullets.removeClass(
                ['', '-next', '-next-next', '-prev', '-prev-prev', '-main']
                  .map((suffix) => `${params.bulletActiveClass}${suffix}`)
                  .join(' ')
              ),
              $el.length > 1)
            )
              bullets.each((bullet) => {
                const $bullet = dom(bullet),
                  bulletIndex = $bullet.index();
                bulletIndex === current &&
                  $bullet.addClass(params.bulletActiveClass),
                  params.dynamicBullets &&
                    (bulletIndex >= firstIndex &&
                      bulletIndex <= lastIndex &&
                      $bullet.addClass(`${params.bulletActiveClass}-main`),
                    bulletIndex === firstIndex &&
                      setSideBullets($bullet, 'prev'),
                    bulletIndex === lastIndex &&
                      setSideBullets($bullet, 'next'));
              });
            else {
              const $bullet = bullets.eq(current),
                bulletIndex = $bullet.index();
              if (
                ($bullet.addClass(params.bulletActiveClass),
                params.dynamicBullets)
              ) {
                const $firstDisplayedBullet = bullets.eq(firstIndex),
                  $lastDisplayedBullet = bullets.eq(lastIndex);
                for (let i = firstIndex; i <= lastIndex; i += 1)
                  bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
                if (swiper.params.loop)
                  if (bulletIndex >= bullets.length) {
                    for (let i = params.dynamicMainBullets; i >= 0; i -= 1)
                      bullets
                        .eq(bullets.length - i)
                        .addClass(`${params.bulletActiveClass}-main`);
                    bullets
                      .eq(bullets.length - params.dynamicMainBullets - 1)
                      .addClass(`${params.bulletActiveClass}-prev`);
                  } else
                    setSideBullets($firstDisplayedBullet, 'prev'),
                      setSideBullets($lastDisplayedBullet, 'next');
                else
                  setSideBullets($firstDisplayedBullet, 'prev'),
                    setSideBullets($lastDisplayedBullet, 'next');
              }
            }
            if (params.dynamicBullets) {
              const dynamicBulletsLength = Math.min(
                  bullets.length,
                  params.dynamicMainBullets + 4
                ),
                bulletsOffset =
                  (bulletSize * dynamicBulletsLength - bulletSize) / 2 -
                  midIndex * bulletSize,
                offsetProp = rtl ? 'right' : 'left';
              bullets.css(
                swiper.isHorizontal() ? offsetProp : 'top',
                `${bulletsOffset}px`
              );
            }
          }
          if (
            ('fraction' === params.type &&
              ($el
                .find(
                  classes_to_selector_classesToSelector(params.currentClass)
                )
                .text(params.formatFractionCurrent(current + 1)),
              $el
                .find(classes_to_selector_classesToSelector(params.totalClass))
                .text(params.formatFractionTotal(total))),
            'progressbar' === params.type)
          ) {
            let progressbarDirection;
            progressbarDirection = params.progressbarOpposite
              ? swiper.isHorizontal()
                ? 'vertical'
                : 'horizontal'
              : swiper.isHorizontal()
              ? 'horizontal'
              : 'vertical';
            const scale = (current + 1) / total;
            let scaleX = 1,
              scaleY = 1;
            'horizontal' === progressbarDirection
              ? (scaleX = scale)
              : (scaleY = scale),
              $el
                .find(
                  classes_to_selector_classesToSelector(
                    params.progressbarFillClass
                  )
                )
                .transform(
                  `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`
                )
                .transition(swiper.params.speed);
          }
          'custom' === params.type && params.renderCustom
            ? ($el.html(params.renderCustom(swiper, current + 1, total)),
              emit('paginationRender', $el[0]))
            : emit('paginationUpdate', $el[0]),
            swiper.params.watchOverflow &&
              swiper.enabled &&
              $el[swiper.isLocked ? 'addClass' : 'removeClass'](
                params.lockClass
              );
        }
        function render() {
          const params = swiper.params.pagination;
          if (isPaginationDisabled()) return;
          const slidesLength =
              swiper.virtual && swiper.params.virtual.enabled
                ? swiper.virtual.slides.length
                : swiper.slides.length,
            $el = swiper.pagination.$el;
          let paginationHTML = '';
          if ('bullets' === params.type) {
            let numberOfBullets = swiper.params.loop
              ? Math.ceil(
                  (slidesLength - 2 * swiper.loopedSlides) /
                    swiper.params.slidesPerGroup
                )
              : swiper.snapGrid.length;
            swiper.params.freeMode &&
              swiper.params.freeMode.enabled &&
              !swiper.params.loop &&
              numberOfBullets > slidesLength &&
              (numberOfBullets = slidesLength);
            for (let i = 0; i < numberOfBullets; i += 1)
              params.renderBullet
                ? (paginationHTML += params.renderBullet.call(
                    swiper,
                    i,
                    params.bulletClass
                  ))
                : (paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`);
            $el.html(paginationHTML),
              (swiper.pagination.bullets = $el.find(
                classes_to_selector_classesToSelector(params.bulletClass)
              ));
          }
          'fraction' === params.type &&
            ((paginationHTML = params.renderFraction
              ? params.renderFraction.call(
                  swiper,
                  params.currentClass,
                  params.totalClass
                )
              : `<span class="${params.currentClass}"></span> / <span class="${params.totalClass}"></span>`),
            $el.html(paginationHTML)),
            'progressbar' === params.type &&
              ((paginationHTML = params.renderProgressbar
                ? params.renderProgressbar.call(
                    swiper,
                    params.progressbarFillClass
                  )
                : `<span class="${params.progressbarFillClass}"></span>`),
              $el.html(paginationHTML)),
            'custom' !== params.type &&
              emit('paginationRender', swiper.pagination.$el[0]);
        }
        function init() {
          swiper.params.pagination =
            create_element_if_not_defined_createElementIfNotDefined(
              swiper,
              swiper.originalParams.pagination,
              swiper.params.pagination,
              { el: 'swiper-pagination' }
            );
          const params = swiper.params.pagination;
          if (!params.el) return;
          let $el = dom(params.el);
          0 !== $el.length &&
            (swiper.params.uniqueNavElements &&
              'string' == typeof params.el &&
              $el.length > 1 &&
              (($el = swiper.$el.find(params.el)),
              $el.length > 1 &&
                ($el = $el.filter(
                  (el) => dom(el).parents('.swiper')[0] === swiper.el
                ))),
            'bullets' === params.type &&
              params.clickable &&
              $el.addClass(params.clickableClass),
            $el.addClass(params.modifierClass + params.type),
            $el.addClass(
              swiper.isHorizontal()
                ? params.horizontalClass
                : params.verticalClass
            ),
            'bullets' === params.type &&
              params.dynamicBullets &&
              ($el.addClass(`${params.modifierClass}${params.type}-dynamic`),
              (dynamicBulletIndex = 0),
              params.dynamicMainBullets < 1 && (params.dynamicMainBullets = 1)),
            'progressbar' === params.type &&
              params.progressbarOpposite &&
              $el.addClass(params.progressbarOppositeClass),
            params.clickable &&
              $el.on(
                'click',
                classes_to_selector_classesToSelector(params.bulletClass),
                function onClick(e) {
                  e.preventDefault();
                  let index = dom(this).index() * swiper.params.slidesPerGroup;
                  swiper.params.loop && (index += swiper.loopedSlides),
                    swiper.slideTo(index);
                }
              ),
            Object.assign(swiper.pagination, { $el, el: $el[0] }),
            swiper.enabled || $el.addClass(params.lockClass));
        }
        function destroy() {
          const params = swiper.params.pagination;
          if (isPaginationDisabled()) return;
          const $el = swiper.pagination.$el;
          $el.removeClass(params.hiddenClass),
            $el.removeClass(params.modifierClass + params.type),
            $el.removeClass(
              swiper.isHorizontal()
                ? params.horizontalClass
                : params.verticalClass
            ),
            swiper.pagination.bullets &&
              swiper.pagination.bullets.removeClass &&
              swiper.pagination.bullets.removeClass(params.bulletActiveClass),
            params.clickable &&
              $el.off(
                'click',
                classes_to_selector_classesToSelector(params.bulletClass)
              );
        }
        on('init', () => {
          !1 === swiper.params.pagination.enabled
            ? disable()
            : (init(), render(), update());
        }),
          on('activeIndexChange', () => {
            (swiper.params.loop || void 0 === swiper.snapIndex) && update();
          }),
          on('snapIndexChange', () => {
            swiper.params.loop || update();
          }),
          on('slidesLengthChange', () => {
            swiper.params.loop && (render(), update());
          }),
          on('snapGridLengthChange', () => {
            swiper.params.loop || (render(), update());
          }),
          on('destroy', () => {
            destroy();
          }),
          on('enable disable', () => {
            const { $el } = swiper.pagination;
            $el &&
              $el[swiper.enabled ? 'removeClass' : 'addClass'](
                swiper.params.pagination.lockClass
              );
          }),
          on('lock unlock', () => {
            update();
          }),
          on('click', (_s, e) => {
            const targetEl = e.target,
              { $el } = swiper.pagination;
            if (
              swiper.params.pagination.el &&
              swiper.params.pagination.hideOnClick &&
              $el &&
              $el.length > 0 &&
              !dom(targetEl).hasClass(swiper.params.pagination.bulletClass)
            ) {
              if (
                swiper.navigation &&
                ((swiper.navigation.nextEl &&
                  targetEl === swiper.navigation.nextEl) ||
                  (swiper.navigation.prevEl &&
                    targetEl === swiper.navigation.prevEl))
              )
                return;
              const isHidden = $el.hasClass(
                swiper.params.pagination.hiddenClass
              );
              emit(!0 === isHidden ? 'paginationShow' : 'paginationHide'),
                $el.toggleClass(swiper.params.pagination.hiddenClass);
            }
          });
        const disable = () => {
          swiper.$el.addClass(swiper.params.pagination.paginationDisabledClass),
            swiper.pagination.$el &&
              swiper.pagination.$el.addClass(
                swiper.params.pagination.paginationDisabledClass
              ),
            destroy();
        };
        Object.assign(swiper.pagination, {
          enable: () => {
            swiper.$el.removeClass(
              swiper.params.pagination.paginationDisabledClass
            ),
              swiper.pagination.$el &&
                swiper.pagination.$el.removeClass(
                  swiper.params.pagination.paginationDisabledClass
                ),
              init(),
              render(),
              update();
          },
          disable,
          render,
          update,
          init,
          destroy,
        });
      }
    },
  },
]);
